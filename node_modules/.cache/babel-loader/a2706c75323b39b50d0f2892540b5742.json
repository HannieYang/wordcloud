{"ast":null,"code":"import { each } from '@antv/util';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\n\nfunction getPath(points, isInCircle, smooth, registeredShape, constraint) {\n  var path = [];\n\n  if (points.length) {\n    var topLinePoints_1 = []; // area 区域上部分\n\n    var bottomLinePoints_1 = []; // area 区域下部分\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var point = points[i];\n      topLinePoints_1.push(point[1]);\n      bottomLinePoints_1.push(point[0]);\n    }\n\n    bottomLinePoints_1 = bottomLinePoints_1.reverse();\n    each([topLinePoints_1, bottomLinePoints_1], function (pointsData, index) {\n      var subPath = [];\n      var parsedPoints = registeredShape.parsePoints(pointsData);\n      var p1 = parsedPoints[0];\n\n      if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {\n        // 都只有一个点，绘制一条竖线\n        subPath = index === 0 ? [['M', p1.x - 0.5, p1.y], ['L', p1.x + 0.5, p1.y]] : [['L', p1.x + 0.5, p1.y], ['L', p1.x - 0.5, p1.y]];\n      } else {\n        if (isInCircle) {\n          parsedPoints.push({\n            x: p1.x,\n            y: p1.y\n          });\n        }\n\n        if (smooth) {\n          subPath = getSplinePath(parsedPoints, false, constraint);\n        } else {\n          subPath = getLinePath(parsedPoints, false);\n        }\n\n        if (index > 0) {\n          subPath[0][0] = 'L';\n        }\n      }\n\n      path = path.concat(subPath);\n    });\n    path.push(['Z']);\n  }\n\n  return path;\n}\n/**\n * @ignore\n * Gets shape attrs\n * @param cfg\n * @param isStroke\n * @param smooth\n * @param registeredShape\n * @param [constraint]\n * @returns\n */\n\n\nexport function getShapeAttrs(cfg, isStroke, smooth, registeredShape, constraint) {\n  var attrs = getStyle(cfg, isStroke, !isStroke, 'lineWidth');\n  var connectNulls = cfg.connectNulls,\n      isInCircle = cfg.isInCircle,\n      points = cfg.points,\n      showSinglePoint = cfg.showSinglePoint;\n  var pathPoints = getPathPoints(points, connectNulls, showSinglePoint); // 根据 connectNulls 配置获取图形关键点\n\n  var path = [];\n\n  for (var i = 0, len = pathPoints.length; i < len; i++) {\n    var eachPoints = pathPoints[i];\n    path = path.concat(getPath(eachPoints, isInCircle, smooth, registeredShape, constraint));\n  }\n\n  attrs.path = path;\n  return attrs;\n}\n/**\n * @ignore\n * Gets constraint\n * @param coordinate\n * @returns constraint\n */\n\nexport function getConstraint(coordinate) {\n  var start = coordinate.start,\n      end = coordinate.end;\n  return [[start.x, end.y], [end.x, start.y]];\n}","map":{"version":3,"mappings":"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","names":["each","getPathPoints","getStyle","getLinePath","getSplinePath","getPath","points","isInCircle","smooth","registeredShape","constraint","path","length","topLinePoints_1","bottomLinePoints_1","i","len","point","push","reverse","pointsData","index","subPath","parsedPoints","parsePoints","p1","x","y","concat","getShapeAttrs","cfg","isStroke","attrs","showSinglePoint","pathPoints","connectNulls","eachPoints","getConstraint","coordinate","end","start"],"sourceRoot":"","sources":["../../../../src/geometry/shape/area/util.ts"],"sourcesContent":["import { each } from '@antv/util';\nimport { Coordinate, PathCommand } from '../../../dependents';\nimport { Point, Position, Shape, ShapeInfo } from '../../../interface';\n\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\n\nfunction getPath(\n  points: Point[],\n  isInCircle: boolean,\n  smooth: boolean,\n  registeredShape: Shape,\n  constraint?: Position[]\n): PathCommand[] {\n  let path = [];\n\n  if (points.length) {\n    const topLinePoints = []; // area 区域上部分\n    let bottomLinePoints = []; // area 区域下部分\n    for (let i = 0, len = points.length; i < len; i++) {\n      const point = points[i];\n      topLinePoints.push(point[1]);\n      bottomLinePoints.push(point[0]);\n    }\n    bottomLinePoints = bottomLinePoints.reverse();\n\n    each([topLinePoints, bottomLinePoints], (pointsData, index) => {\n      let subPath = [];\n      const parsedPoints = registeredShape.parsePoints(pointsData);\n      const p1 = parsedPoints[0];\n\n      if (topLinePoints.length === 1 && bottomLinePoints.length === 1) {\n        // 都只有一个点，绘制一条竖线\n        subPath =\n          index === 0\n            ? [\n                ['M', p1.x - 0.5, p1.y],\n                ['L', p1.x + 0.5, p1.y],\n              ]\n            : [\n                ['L', p1.x + 0.5, p1.y],\n                ['L', p1.x - 0.5, p1.y],\n              ];\n      } else {\n        if (isInCircle) {\n          parsedPoints.push({ x: p1.x, y: p1.y });\n        }\n        if (smooth) {\n          subPath = getSplinePath(parsedPoints, false, constraint);\n        } else {\n          subPath = getLinePath(parsedPoints, false);\n        }\n        if (index > 0) {\n          subPath[0][0] = 'L';\n        }\n      }\n\n      path = path.concat(subPath);\n    });\n\n    path.push(['Z']);\n  }\n\n  return path;\n}\n\n/**\n * @ignore\n * Gets shape attrs\n * @param cfg\n * @param isStroke\n * @param smooth\n * @param registeredShape\n * @param [constraint]\n * @returns\n */\nexport function getShapeAttrs(\n  cfg: ShapeInfo,\n  isStroke: boolean,\n  smooth: boolean,\n  registeredShape: Shape,\n  constraint?: Position[]\n) {\n  const attrs = getStyle(cfg, isStroke, !isStroke, 'lineWidth');\n  const { connectNulls, isInCircle, points, showSinglePoint } = cfg;\n  const pathPoints = getPathPoints(points, connectNulls, showSinglePoint); // 根据 connectNulls 配置获取图形关键点\n\n  let path = [];\n  for (let i = 0, len = pathPoints.length; i < len; i++) {\n    const eachPoints = pathPoints[i];\n    path = path.concat(getPath(eachPoints, isInCircle, smooth, registeredShape, constraint));\n  }\n  attrs.path = path;\n\n  return attrs;\n}\n\n/**\n * @ignore\n * Gets constraint\n * @param coordinate\n * @returns constraint\n */\nexport function getConstraint(coordinate: Coordinate): Position[] {\n  const { start, end } = coordinate;\n  return [\n    [start.x, end.y],\n    [end.x, start.y],\n  ];\n}\n"]},"metadata":{},"sourceType":"module"}