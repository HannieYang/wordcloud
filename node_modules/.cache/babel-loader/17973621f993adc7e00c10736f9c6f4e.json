{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { each, groupBy, uniq, map, size } from '@antv/util';\nimport { checkShapeOverlap } from '../../util';\n\nfunction filterLabel(labels) {\n  var MAX_CNT = 500; // 最多显示 500 个数据标签\n\n  var filteredLabels = [];\n  var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);\n  each(labels, function (label, idx) {\n    if (idx % pages === 0) {\n      filteredLabels.push(label);\n    } else {\n      label.set('visible', false);\n    }\n  });\n  return filteredLabels;\n}\n/**\n * 为 interval geometry 定制的数据标签重叠自动隐藏布局方法\n * @param items\n * @param labels\n * @param shapes\n */\n\n\nexport function intervalHideOverlap(items, labels, shapes) {\n  var _a;\n\n  if (shapes.length === 0) {\n    return;\n  }\n\n  var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');\n  var geometry = element === null || element === void 0 ? void 0 : element.geometry;\n\n  if (!geometry || geometry.type !== 'interval') {\n    return;\n  }\n\n  var filteredLabels = filterLabel(labels);\n\n  var _b = __read(geometry.getXYFields(), 1),\n      xField = _b[0];\n\n  var dones = [];\n  var todo = [];\n  var groupedLabels = groupBy(filteredLabels, function (label) {\n    return label.get('data')[xField];\n  });\n  var xValues = uniq(map(filteredLabels, function (label) {\n    return label.get('data')[xField];\n  }));\n  var xValue;\n  filteredLabels.forEach(function (label) {\n    label.set('visible', true);\n  });\n\n  var addCurrentGroup = function (curItems) {\n    if (curItems) {\n      if (curItems.length) {\n        // 最后一个\n        todo.push(curItems.pop());\n      }\n\n      todo.push.apply(todo, __spreadArray([], __read(curItems), false));\n    }\n  };\n\n  if (size(xValues) > 0) {\n    // 第一组\n    xValue = xValues.shift();\n    addCurrentGroup(groupedLabels[xValue]);\n  }\n\n  if (size(xValues) > 0) {\n    // 最后一组\n    xValue = xValues.pop();\n    addCurrentGroup(groupedLabels[xValue]);\n  }\n\n  each(xValues.reverse(), function (val) {\n    // 其他组\n    addCurrentGroup(groupedLabels[val]);\n  });\n\n  while (todo.length > 0) {\n    var cur = todo.shift();\n\n    if (cur.get('visible')) {\n      if (checkShapeOverlap(cur, dones)) {\n        cur.set('visible', false);\n      } else {\n        dones.push(cur);\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["each","groupBy","uniq","map","size","checkShapeOverlap","filterLabel","labels","MAX_CNT","filteredLabels","pages","Math","max","floor","length","label","idx","push","set","intervalHideOverlap","items","shapes","element","_a","get","geometry","type","getXYFields","xField","dones","todo","groupedLabels","xValues","xValue","forEach","addCurrentGroup","curItems","pop","apply","__spreadArray","shift","reverse","val","cur"],"sourceRoot":"","sources":["../../../../../src/geometry/label/layout/interval/hide-overlap.ts"],"sourcesContent":["import { IGroup, IShape } from '../../../../dependents';\nimport { each, groupBy, uniq, map, size, filter } from '@antv/util';\nimport Geometry from '../../../base';\nimport Element from '../../../element';\nimport { LabelItem } from '../../interface';\nimport { checkShapeOverlap } from '../../util';\n\nfunction filterLabel(labels: IShape[] | IGroup[]) {\n  const MAX_CNT = 500; // 最多显示 500 个数据标签\n  const filteredLabels = [];\n  const pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);\n  each(labels, (label, idx) => {\n    if (idx % pages === 0) {\n      filteredLabels.push(label);\n    } else {\n      label.set('visible', false);\n    }\n  });\n\n  return filteredLabels;\n}\n\n/**\n * 为 interval geometry 定制的数据标签重叠自动隐藏布局方法\n * @param items\n * @param labels\n * @param shapes\n */\nexport function intervalHideOverlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[]) {\n  if (shapes.length === 0) {\n    return;\n  }\n  const element: Element = shapes[0]?.get('element');\n  const geometry: Geometry = element?.geometry;\n  if (!geometry || geometry.type !== 'interval') {\n    return;\n  }\n\n  const filteredLabels = filterLabel(labels);\n  const [xField] = geometry.getXYFields();\n  const dones: IShape[] = [];\n  const todo: IShape[] = [];\n  const groupedLabels = groupBy(filteredLabels, (label) => label.get('data')[xField]);\n  const xValues = uniq(map(filteredLabels, (label: IShape) => label.get('data')[xField]));\n  let xValue;\n\n  filteredLabels.forEach((label) => {\n    label.set('visible', true);\n  });\n\n  const addCurrentGroup = (curItems: IShape[]) => {\n    if (curItems) {\n      if (curItems.length) {\n        // 最后一个\n        todo.push(curItems.pop());\n      }\n      todo.push(...curItems);\n    }\n  };\n\n  if (size(xValues) > 0) {\n    // 第一组\n    xValue = xValues.shift();\n    addCurrentGroup(groupedLabels[xValue]);\n  }\n  if (size(xValues) > 0) {\n    // 最后一组\n    xValue = xValues.pop();\n    addCurrentGroup(groupedLabels[xValue]);\n  }\n  each(xValues.reverse(), (val) => {\n    // 其他组\n    addCurrentGroup(groupedLabels[val]);\n  });\n\n  while (todo.length > 0) {\n    const cur = todo.shift();\n    if (cur.get('visible')) {\n      if (checkShapeOverlap(cur, dones)) {\n        cur.set('visible', false);\n      } else {\n        dones.push(cur);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}