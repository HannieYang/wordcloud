{"ast":null,"code":"import { __values } from \"tslib\";\nimport { isObject, each, find, get } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\n/** label text和line距离 4px */\n\nvar MARGIN = 4;\n\nfunction antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {\n  var e_1, _a; // adjust y position of labels to avoid overlapping\n\n\n  var overlapping = true;\n  var start = plotRange.start;\n  var end = plotRange.end;\n  var startY = Math.min(start.y, end.y);\n  var totalHeight = Math.abs(start.y - end.y);\n  var i;\n  var maxY = 0;\n  var minY = Number.MIN_VALUE;\n  var boxes = labels.map(function (label) {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n\n    if (label.y < minY) {\n      minY = label.y;\n    }\n\n    return {\n      size: lineHeight,\n      targets: [label.y - startY]\n    };\n  });\n  minY -= startY;\n\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach(function (box) {\n      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size); // box.pos = Math.max(0, target - box.size / 2);\n    }); // detect overlapping and join boxes\n\n    overlapping = false;\n    i = boxes.length;\n\n    while (i--) {\n      if (i > 0) {\n        var previousBox = boxes[i - 1];\n        var box = boxes[i];\n\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets); // overflow, shift up\n\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n\n          boxes.splice(i, 1); // removing box\n\n          overlapping = true;\n        }\n      }\n    }\n  }\n\n  i = 0; // step 4: normalize y and adjust x\n\n  boxes.forEach(function (b) {\n    var posInCompositeBox = startY + lineHeight / 2; // middle of the label\n\n    b.targets.forEach(function () {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += lineHeight;\n      i++;\n    });\n  });\n  var labelsMap = {};\n\n  try {\n    for (var labelShapes_1 = __values(labelShapes), labelShapes_1_1 = labelShapes_1.next(); !labelShapes_1_1.done; labelShapes_1_1 = labelShapes_1.next()) {\n      var labelShape = labelShapes_1_1.value;\n      labelsMap[labelShape.get('id')] = labelShape;\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (labelShapes_1_1 && !labelShapes_1_1.done && (_a = labelShapes_1.return)) _a.call(labelShapes_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  } // (x - cx)^2 + (y - cy)^2 = totalR^2\n\n\n  labels.forEach(function (label) {\n    var rPow2 = label.r * label.r;\n    var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);\n\n    if (rPow2 < dyPow2) {\n      label.x = center.x;\n    } else {\n      var dx = Math.sqrt(rPow2 - dyPow2);\n\n      if (!isRight) {\n        // left\n        label.x = center.x - dx;\n      } else {\n        // right\n        label.x = center.x + dx;\n      }\n    } // adjust labelShape\n\n\n    var labelShape = labelsMap[label.id];\n    labelShape.attr('x', label.x);\n    labelShape.attr('y', label.y); // because group could not effect text-shape, should set text-shape position manually\n\n    var textShape = find(labelShape.getChildren(), function (ele) {\n      return ele.get('type') === 'text';\n    }); // @ts-ignore\n\n    if (textShape) {\n      textShape.attr('y', label.y);\n      textShape.attr('x', label.x);\n    }\n  });\n}\n\nexport function distribute(items, labels, shapes, region) {\n  if (!items.length || !labels.length) {\n    return;\n  }\n\n  var offset = items[0] ? items[0].offset : 0;\n  var coordinate = labels[0].get('coordinate');\n  var radius = coordinate.getRadius();\n  var center = coordinate.getCenter();\n\n  if (offset > 0) {\n    // const lineHeight = get(this.geometry.theme, ['pieLabels', 'labelHeight'], 14);\n    var lineHeight_1 = 14; // TODO\n\n    var totalR = radius + offset;\n    var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;\n    var plotRange_1 = {\n      start: coordinate.start,\n      end: coordinate.end\n    }; // step 1: separate labels\n\n    var halves_1 = [[], [] // right\n    ];\n    items.forEach(function (labelItem) {\n      if (!labelItem) {\n        return;\n      }\n\n      if (labelItem.textAlign === 'right') {\n        // left\n        halves_1[0].push(labelItem);\n      } else {\n        // right or center will be put on the right side\n        halves_1[1].push(labelItem);\n      }\n    });\n    halves_1.forEach(function (half, index) {\n      // step 2: reduce labels\n      var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;\n\n      if (half.length > maxLabelsCountForOneSide) {\n        half.sort(function (a, b) {\n          // sort by percentage DESC\n          return b['..percent'] - a['..percent'];\n        });\n        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);\n      } // step 3: distribute position (x and y)\n\n\n      half.sort(function (a, b) {\n        // sort by y ASC\n        return a.y - b.y;\n      });\n      antiCollision(labels, half, lineHeight_1, plotRange_1, center, index);\n    });\n  } // 配置 labelLine\n\n\n  each(items, function (item) {\n    if (item && item.labelLine) {\n      var distance = item.offset;\n      var angle = item.angle; // 贴近圆周\n\n      var startPoint = polarToCartesian(center.x, center.y, radius, angle);\n      var innerPoint = polarToCartesian(center.x, center.y, radius + distance / 2, angle);\n      var itemX = item.x + get(item, 'offsetX', 0);\n      var itemY = item.y + get(item, 'offsetY', 0);\n      var endPoint = {\n        x: itemX - Math.cos(angle) * MARGIN,\n        y: itemY - Math.sin(angle) * MARGIN\n      };\n\n      if (!isObject(item.labelLine)) {\n        // labelLine: true\n        item.labelLine = {};\n      }\n\n      item.labelLine.path = [\"M \".concat(startPoint.x), \"\".concat(startPoint.y, \" Q\").concat(innerPoint.x), \"\".concat(innerPoint.y, \" \").concat(endPoint.x), endPoint.y].join(',');\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["isObject","each","find","get","polarToCartesian","MARGIN","antiCollision","labelShapes","labels","lineHeight","plotRange","center","isRight","overlapping","start","end","startY","Math","min","y","totalHeight","abs","i","maxY","minY","Number","MIN_VALUE","boxes","map","label","size","targets","forEach","box","target","apply","max","pos","length","previousBox","concat","splice","b","posInCompositeBox","labelsMap","labelShapes_1_1","labelShape","rPow2","r","dyPow2","pow","x","dx","sqrt","id","attr","textShape","getChildren","ele","distribute","items","shapes","region","offset","coordinate","radius","getRadius","getCenter","lineHeight_1","totalR","totalHeight_1","plotRange_1","halves_1","labelItem","textAlign","push","half","index","maxLabelsCountForOneSide","sort","a","item","labelLine","distance","angle","startPoint","innerPoint","itemX","itemY","endPoint","cos","sin","path","join"],"sourceRoot":"","sources":["../../../../../src/geometry/label/layout/pie/distribute.ts"],"sourcesContent":["import { isObject, each, find, get } from '@antv/util';\n\nimport { BBox, IGroup, IShape } from '../../../../dependents';\nimport { LabelItem } from '../../interface';\n\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { IElement } from '@antv/g-base';\n\n/** label text和line距离 4px */\nconst MARGIN = 4;\n\nfunction antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {\n  // adjust y position of labels to avoid overlapping\n  let overlapping = true;\n  const start = plotRange.start;\n  const end = plotRange.end;\n  const startY = Math.min(start.y, end.y);\n  let totalHeight = Math.abs(start.y - end.y);\n  let i;\n\n  let maxY = 0;\n  let minY = Number.MIN_VALUE;\n  const boxes = labels.map((label) => {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n    if (label.y < minY) {\n      minY = label.y;\n    }\n    return {\n      size: lineHeight,\n      targets: [label.y - startY],\n    };\n  });\n  minY -= startY;\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach((box) => {\n      const target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      // box.pos = Math.max(0, target - box.size / 2);\n    });\n\n    // detect overlapping and join boxes\n    overlapping = false;\n    i = boxes.length;\n    while (i--) {\n      if (i > 0) {\n        const previousBox = boxes[i - 1];\n        const box = boxes[i];\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets);\n\n          // overflow, shift up\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n          boxes.splice(i, 1); // removing box\n          overlapping = true;\n        }\n      }\n    }\n  }\n\n  i = 0;\n  // step 4: normalize y and adjust x\n  boxes.forEach((b) => {\n    let posInCompositeBox = startY + lineHeight / 2; // middle of the label\n    b.targets.forEach(() => {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += lineHeight;\n      i++;\n    });\n  });\n\n  const labelsMap = {};\n  for (const labelShape of labelShapes) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  // (x - cx)^2 + (y - cy)^2 = totalR^2\n  labels.forEach((label) => {\n    const rPow2 = label.r * label.r;\n    const dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);\n    if (rPow2 < dyPow2) {\n      label.x = center.x;\n    } else {\n      const dx = Math.sqrt(rPow2 - dyPow2);\n      if (!isRight) {\n        // left\n        label.x = center.x - dx;\n      } else {\n        // right\n        label.x = center.x + dx;\n      }\n    }\n\n    // adjust labelShape\n    const labelShape = labelsMap[label.id];\n    labelShape.attr('x', label.x);\n    labelShape.attr('y', label.y);\n\n    // because group could not effect text-shape, should set text-shape position manually\n    const textShape = find(labelShape.getChildren(), (ele) => ele.get('type') === 'text') as IElement;\n    // @ts-ignore\n    if (textShape) {\n      textShape.attr('y', label.y);\n      textShape.attr('x', label.x);\n    }\n  });\n}\n\nexport function distribute(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  if (!items.length || !labels.length) {\n    return;\n  }\n  const offset = items[0] ? items[0].offset : 0;\n  const coordinate = labels[0].get('coordinate');\n  const radius = coordinate.getRadius();\n  const center = coordinate.getCenter();\n\n  if (offset > 0) {\n    // const lineHeight = get(this.geometry.theme, ['pieLabels', 'labelHeight'], 14);\n    const lineHeight = 14; // TODO\n    const totalR = radius + offset;\n    const totalHeight = totalR * 2 + lineHeight * 2;\n    const plotRange = {\n      start: coordinate.start,\n      end: coordinate.end,\n    };\n\n    // step 1: separate labels\n    const halves = [\n      [], // left\n      [], // right\n    ];\n    items.forEach((labelItem) => {\n      if (!labelItem) {\n        return;\n      }\n      if (labelItem.textAlign === 'right') {\n        // left\n        halves[0].push(labelItem);\n      } else {\n        // right or center will be put on the right side\n        halves[1].push(labelItem);\n      }\n    });\n\n    halves.forEach((half, index) => {\n      // step 2: reduce labels\n      const maxLabelsCountForOneSide = totalHeight / lineHeight;\n      if (half.length > maxLabelsCountForOneSide) {\n        half.sort((a, b) => {\n          // sort by percentage DESC\n          return b['..percent'] - a['..percent'];\n        });\n        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);\n      }\n\n      // step 3: distribute position (x and y)\n      half.sort((a, b) => {\n        // sort by y ASC\n        return a.y - b.y;\n      });\n\n      antiCollision(labels, half, lineHeight, plotRange, center, index);\n    });\n  }\n\n  // 配置 labelLine\n  each(items, (item) => {\n    if (item && item.labelLine) {\n      const distance = item.offset;\n      const angle = item.angle;\n      // 贴近圆周\n      const startPoint = polarToCartesian(center.x, center.y, radius, angle);\n      const innerPoint = polarToCartesian(center.x, center.y, radius + distance / 2, angle);\n      const itemX = item.x + get(item, 'offsetX', 0);\n      const itemY = item.y + get(item, 'offsetY', 0);\n      const endPoint = {\n        x: itemX - Math.cos(angle) * MARGIN,\n        y: itemY - Math.sin(angle) * MARGIN,\n      };\n      if (!isObject(item.labelLine)) {\n        // labelLine: true\n        item.labelLine = {};\n      }\n      item.labelLine.path = [\n        `M ${startPoint.x}`,\n        `${startPoint.y} Q${innerPoint.x}`,\n        `${innerPoint.y} ${endPoint.x}`,\n        endPoint.y,\n      ].join(',');\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}