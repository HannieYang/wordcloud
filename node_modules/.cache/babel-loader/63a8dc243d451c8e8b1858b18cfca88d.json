{"ast":null,"code":"import { groupBy } from '@antv/util';\n/**\n * bidirectional-bar 处理数据, 通过 SERIES_FIELD_KEY 字段分成左右数据\n * @param xField\n * @param yField\n * @param data\n */\n\nexport function transformData(xField, yField, seriesField, data, reverse) {\n  var hopeData = [];\n  yField.forEach(function (d) {\n    data.forEach(function (k) {\n      var _a;\n\n      var obj = (_a = {}, _a[xField] = k[xField], _a[seriesField] = d, _a[d] = k[d], _a);\n      hopeData.push(obj);\n    });\n  });\n  var groupData = Object.values(groupBy(hopeData, seriesField));\n  var _a = groupData[0],\n      data1 = _a === void 0 ? [] : _a,\n      _b = groupData[1],\n      data2 = _b === void 0 ? [] : _b;\n  return reverse ? [data1.reverse(), data2.reverse()] : [data1, data2];\n}\n/**\n * 是否横向，默认空为横向\n * @param layout\n */\n\nexport function isHorizontal(layout) {\n  return layout !== 'vertical';\n}\n/**\n * 多 view 进行同步 padding 的自定义逻辑\n * @param chart\n * @param views\n * @param p\n */\n\nexport function syncViewPadding(chart, views, p) {\n  var v1 = views[0],\n      v2 = views[1];\n  var p1 = v1.autoPadding;\n  var p2 = v2.autoPadding;\n  var _a = chart.__axisPosition,\n      layout = _a.layout,\n      position = _a.position; // 目前只能根据布局的比例来判断 layout\n\n  if (isHorizontal(layout) && position === 'top') {\n    /**\n     * 保证 v1 的 left 和 v2 right 的间隔相等，因为 v1 有轴\n     * position top 即为 v1 左边，中间间距设置就为 0\n     */\n    v1.autoPadding = p.instance(p1.top, 0, p1.bottom, p1.left);\n    v2.autoPadding = p.instance(p2.top, p1.left, p2.bottom, 0);\n  }\n\n  if (isHorizontal(layout) && position === 'bottom') {\n    /**\n     * 保证 v1 的 left 和 v2 right 的间隔相等，因为 v1 有轴\n     * position bottom 即为 v1 的右边，v1 right = right / 2  v2 left = right / 2\n     * + 5 是为了 让那个轴不要太贴近了，更好看\n     */\n    v1.autoPadding = p.instance(p1.top, p1.right / 2 + 5, p1.bottom, p1.left);\n    v2.autoPadding = p.instance(p2.top, p2.right, p2.bottom, p1.right / 2 + 5);\n  }\n\n  if (!isHorizontal(layout) && position === 'bottom') {\n    /**\n     * 保证 v1 的 left 和 v2 left 的间隔相等 left 取最大值\n     * position bottom 即为 v1 下边，v1 bottom = bottom / 2  v2 top = bottom / 2\n     * + 5 是为了 让那个轴不要太贴近了，更好看\n     */\n    var left = p1.left >= p2.left ? p1.left : p2.left;\n    v1.autoPadding = p.instance(p1.top, p1.right, p1.bottom / 2 + 5, left);\n    v2.autoPadding = p.instance(p1.bottom / 2 + 5, p2.right, p2.bottom, left);\n  } // 垂直状态，不建议设置position 为 top， 还是做个兼容处理\n\n\n  if (!isHorizontal(layout) && position === 'top') {\n    var left = p1.left >= p2.left ? p1.left : p2.left;\n    v1.autoPadding = p.instance(p1.top, p1.right, 0, left);\n    v2.autoPadding = p.instance(0, p2.right, p1.top, left);\n  }\n}","map":{"version":3,"mappings":"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","names":["groupBy","transformData","xField","yField","seriesField","data","reverse","hopeData","forEach","d","k","obj","_a","push","groupData","Object","values","_b","data2","data1","isHorizontal","layout","syncViewPadding","chart","views","p","v2","p1","v1","autoPadding","p2","__axisPosition","position","instance","top","bottom","left","right"],"sourceRoot":"","sources":["../../../src/plots/bidirectional-bar/utils.ts"],"sourcesContent":["import { groupBy } from '@antv/util';\nimport { Types } from '@antv/g2';\nimport { Datum } from '../../types';\nimport { BidirectionalBarOptions } from './types';\n\ntype TransformData = {\n  [key: string]: string | number;\n}[];\n\n/**\n * bidirectional-bar 处理数据, 通过 SERIES_FIELD_KEY 字段分成左右数据\n * @param xField\n * @param yField\n * @param data\n */\nexport function transformData(\n  xField: string,\n  yField: string[],\n  seriesField: string,\n  data: Datum,\n  reverse?: boolean\n): Types.Data[] {\n  const hopeData: TransformData = [];\n  yField.forEach((d: string) => {\n    data.forEach((k: any) => {\n      const obj = {\n        [xField]: k[xField],\n        [seriesField]: d,\n        [d]: k[d],\n      };\n      hopeData.push(obj);\n    });\n  });\n  const groupData = Object.values(groupBy(hopeData, seriesField));\n  const [data1 = [], data2 = []] = groupData;\n  return reverse ? [data1.reverse(), data2.reverse()] : [data1, data2];\n}\n\n/**\n * 是否横向，默认空为横向\n * @param layout\n */\nexport function isHorizontal(layout: BidirectionalBarOptions['layout']) {\n  return layout !== 'vertical';\n}\n\n/**\n * 多 view 进行同步 padding 的自定义逻辑\n * @param chart\n * @param views\n * @param p\n */\nexport function syncViewPadding(chart: any, views: any, p: any) {\n  const [v1, v2] = views;\n  const p1 = v1.autoPadding;\n  const p2 = v2.autoPadding;\n  const { layout, position } = chart.__axisPosition;\n  // 目前只能根据布局的比例来判断 layout\n  if (isHorizontal(layout) && position === 'top') {\n    /**\n     * 保证 v1 的 left 和 v2 right 的间隔相等，因为 v1 有轴\n     * position top 即为 v1 左边，中间间距设置就为 0\n     */\n    v1.autoPadding = p.instance(p1.top, 0, p1.bottom, p1.left);\n    v2.autoPadding = p.instance(p2.top, p1.left, p2.bottom, 0);\n  }\n  if (isHorizontal(layout) && position === 'bottom') {\n    /**\n     * 保证 v1 的 left 和 v2 right 的间隔相等，因为 v1 有轴\n     * position bottom 即为 v1 的右边，v1 right = right / 2  v2 left = right / 2\n     * + 5 是为了 让那个轴不要太贴近了，更好看\n     */\n    v1.autoPadding = p.instance(p1.top, p1.right / 2 + 5, p1.bottom, p1.left);\n    v2.autoPadding = p.instance(p2.top, p2.right, p2.bottom, p1.right / 2 + 5);\n  }\n  if (!isHorizontal(layout) && position === 'bottom') {\n    /**\n     * 保证 v1 的 left 和 v2 left 的间隔相等 left 取最大值\n     * position bottom 即为 v1 下边，v1 bottom = bottom / 2  v2 top = bottom / 2\n     * + 5 是为了 让那个轴不要太贴近了，更好看\n     */\n    const left = p1.left >= p2.left ? p1.left : p2.left;\n    v1.autoPadding = p.instance(p1.top, p1.right, p1.bottom / 2 + 5, left);\n    v2.autoPadding = p.instance(p1.bottom / 2 + 5, p2.right, p2.bottom, left);\n  }\n  // 垂直状态，不建议设置position 为 top， 还是做个兼容处理\n  if (!isHorizontal(layout) && position === 'top') {\n    const left = p1.left >= p2.left ? p1.left : p2.left;\n    v1.autoPadding = p.instance(p1.top, p1.right, 0, left);\n    v2.autoPadding = p.instance(0, p2.right, p1.top, left);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}