{"ast":null,"code":"/**\n * 碰撞检测算法\n */\nexport function antiCollision(items, labelHeight, plotRange) {\n  var labels = items.filter(function (item) {\n    return !item.invisible;\n  }); // sorted by y, mutable\n\n  labels.sort(function (a, b) {\n    return a.y - b.y;\n  }); // adjust y position of labels to avoid overlapping\n\n  var overlapping = true;\n  var startY = plotRange.minY;\n  var endY = plotRange.maxY;\n  var totalHeight = Math.abs(startY - endY);\n  var i;\n  var maxY = 0;\n  var minY = Number.MIN_VALUE;\n  var boxes = labels.map(function (label) {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n\n    if (label.y < minY) {\n      minY = label.y;\n    }\n\n    return {\n      content: label.content,\n      size: labelHeight,\n      targets: [label.y - startY],\n      pos: null\n    };\n  });\n  minY -= startY;\n\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach(function (box) {\n      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      box.pos = Math.max(0, box.pos);\n    }); // detect overlapping and join boxes\n\n    overlapping = false;\n    i = boxes.length;\n\n    while (i--) {\n      if (i > 0) {\n        var previousBox = boxes[i - 1];\n        var box = boxes[i];\n\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets); // overflow, shift up\n\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n\n          boxes.splice(i, 1); // removing box\n\n          overlapping = true;\n        }\n      }\n    }\n  }\n\n  i = 0; // step 4: normalize y and adjust x\n\n  boxes.forEach(function (b) {\n    var posInCompositeBox = startY + labelHeight / 2; // middle of the label\n\n    b.targets.forEach(function () {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["antiCollision","items","labelHeight","plotRange","labels","filter","item","invisible","sort","a","b","y","overlapping","startY","minY","endY","maxY","totalHeight","Math","abs","i","Number","MIN_VALUE","boxes","map","label","content","size","targets","pos","forEach","box","target","min","apply","max","length","previousBox","concat","splice","posInCompositeBox"],"sourceRoot":"","sources":["../../../../../src/geometry/label/layout/pie/util.ts"],"sourcesContent":["import { PolarLabelItem } from '../../interface';\n\n/**\n * 碰撞检测算法\n */\nexport function antiCollision(\n  items: PolarLabelItem[],\n  labelHeight: number,\n  plotRange: { minY: number; maxY: number; minX: number; maxX: number }\n) {\n  const labels = items.filter((item) => !item.invisible);\n\n  // sorted by y, mutable\n  labels.sort((a, b) => a.y - b.y);\n  // adjust y position of labels to avoid overlapping\n  let overlapping = true;\n  const startY = plotRange.minY;\n  const endY = plotRange.maxY;\n  let totalHeight = Math.abs(startY - endY);\n  let i;\n\n  let maxY = 0;\n  let minY = Number.MIN_VALUE;\n  const boxes = labels.map((label) => {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n    if (label.y < minY) {\n      minY = label.y;\n    }\n    return {\n      content: label.content,\n      size: labelHeight,\n      targets: [label.y - startY],\n      pos: null,\n    };\n  });\n\n  minY -= startY;\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach((box) => {\n      const target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      box.pos = Math.max(0, box.pos);\n    });\n\n    // detect overlapping and join boxes\n    overlapping = false;\n    i = boxes.length;\n    while (i--) {\n      if (i > 0) {\n        const previousBox = boxes[i - 1];\n        const box = boxes[i];\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets);\n\n          // overflow, shift up\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n          boxes.splice(i, 1); // removing box\n          overlapping = true;\n        }\n      }\n    }\n  }\n\n  i = 0;\n  // step 4: normalize y and adjust x\n  boxes.forEach((b) => {\n    let posInCompositeBox = startY + labelHeight / 2; // middle of the label\n    b.targets.forEach(() => {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module"}