{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { __assign, __extends } from \"tslib\";\nimport { deepMix, each, get, isArray, isEmpty, isEqual, isFunction, isString } from '@antv/util'; // 暂未发包\n// @ts-ignore\n\nimport { propagationDelegate } from '@antv/component';\nimport { doAnimate } from '../../animate';\nimport Base from '../../base';\nimport { getReplaceAttrs } from '../../util/graphics';\nimport { GEOMETRY_LIFE_CIRCLE } from '../../constant';\nimport { BACKGROUND_SHAPE } from '../shape/constant';\n/**\n * Element 图形元素。\n * 定义：在 G2 中，我们会将数据通过图形语法映射成不同的图形，比如点图，数据集中的每条数据会对应一个点，柱状图每条数据对应一个柱子，线图则是一组数据对应一条折线，Element 即一条/一组数据对应的图形元素，它代表一条数据或者一个数据集，在图形层面，它可以是单个 Shape 也可以是多个 Shape，我们称之为图形元素。\n */\n\nvar Element =\n/** @class */\nfunction (_super) {\n  __extends(Element, _super);\n\n  function Element(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    /** 保存 shape 对应的 label */\n\n\n    _this.labelShape = []; // 存储当前开启的状态\n\n    _this.states = [];\n    var shapeFactory = cfg.shapeFactory,\n        container = cfg.container,\n        offscreenGroup = cfg.offscreenGroup,\n        elementIndex = cfg.elementIndex,\n        _a = cfg.visible,\n        visible = _a === void 0 ? true : _a;\n    _this.shapeFactory = shapeFactory;\n    _this.container = container;\n    _this.offscreenGroup = offscreenGroup;\n    _this.visible = visible;\n    _this.elementIndex = elementIndex;\n    return _this;\n  }\n  /**\n   * 绘制图形。\n   * @param model 绘制数据。\n   * @param isUpdate 可选，是否是更新发生后的绘制。\n   */\n\n\n  Element.prototype.draw = function (model, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n\n    this.model = model;\n    this.data = model.data; // 存储原始数据\n\n    this.shapeType = this.getShapeType(model); // 绘制图形\n\n    this.drawShape(model, isUpdate);\n\n    if (this.visible === false) {\n      // 用户在初始化的时候声明 visible: false\n      this.changeVisible(false);\n    }\n  };\n  /**\n   * 更新图形。\n   * @param model 更新的绘制数据。\n   */\n\n\n  Element.prototype.update = function (model) {\n    var _a = this,\n        shapeFactory = _a.shapeFactory,\n        shape = _a.shape;\n\n    if (!shape) {\n      return;\n    } // 更新数据\n\n\n    this.model = model;\n    this.data = model.data;\n    this.shapeType = this.getShapeType(model); // step 1: 更新 shape 携带的信息\n\n    this.setShapeInfo(shape, model); // step 2: 使用虚拟 Group 重新绘制 shape，然后更新当前 shape\n\n    var offscreenGroup = this.getOffscreenGroup();\n    var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup); // @ts-ignore\n\n    newShape.cfg.data = this.data; // @ts-ignore\n\n    newShape.cfg.origin = model; // label 需要使用\n\n    newShape.cfg.element = this; // step 3: 同步 shape 样式\n\n    this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg('update'));\n  };\n  /**\n   * 销毁 element 实例。\n   */\n\n\n  Element.prototype.destroy = function () {\n    var _a = this,\n        shapeFactory = _a.shapeFactory,\n        shape = _a.shape;\n\n    if (shape) {\n      var animateCfg = this.getAnimateCfg('leave');\n\n      if (animateCfg) {\n        // 指定了动画配置则执行销毁动画\n        doAnimate(shape, animateCfg, {\n          coordinate: shapeFactory.coordinate,\n          toAttrs: __assign({}, shape.attr())\n        });\n      } else {\n        // 否则直接销毁\n        shape.remove(true);\n      }\n    } // reset\n\n\n    this.states = [];\n    this.shapeFactory = undefined;\n    this.container = undefined;\n    this.shape = undefined;\n    this.animate = undefined;\n    this.geometry = undefined;\n    this.labelShape = [];\n    this.model = undefined;\n    this.data = undefined;\n    this.offscreenGroup = undefined;\n    this.statesStyle = undefined;\n\n    _super.prototype.destroy.call(this);\n  };\n  /**\n   * 显示或者隐藏 element。\n   * @param visible 是否可见。\n   */\n\n\n  Element.prototype.changeVisible = function (visible) {\n    _super.prototype.changeVisible.call(this, visible);\n\n    if (visible) {\n      if (this.shape) {\n        this.shape.show();\n      }\n\n      if (this.labelShape) {\n        this.labelShape.forEach(function (label) {\n          label.show();\n        });\n      }\n    } else {\n      if (this.shape) {\n        this.shape.hide();\n      }\n\n      if (this.labelShape) {\n        this.labelShape.forEach(function (label) {\n          label.hide();\n        });\n      }\n    }\n  };\n  /**\n   * 设置 Element 的状态。\n   *\n   * 目前 Element 开放三种状态：\n   * 1. active\n   * 2. selected\n   * 3. inactive\n   *\n   * 这三种状态相互独立，可以进行叠加。\n   *\n   * 这三种状态的样式可在 [[Theme]] 主题中或者通过 `geometry.state()` 接口进行配置。\n   *\n   * ```ts\n   * // 激活 active 状态\n   * setState('active', true);\n   * ```\n   *\n   * @param stateName 状态名\n   * @param stateStatus 是否开启状态\n   */\n\n\n  Element.prototype.setState = function (stateName, stateStatus) {\n    var _a = this,\n        states = _a.states,\n        shapeFactory = _a.shapeFactory,\n        model = _a.model,\n        shape = _a.shape,\n        shapeType = _a.shapeType;\n\n    var index = states.indexOf(stateName);\n\n    if (stateStatus) {\n      // 开启状态\n      if (index > -1) {\n        // 该状态已经开启，则返回\n        return;\n      }\n\n      states.push(stateName);\n\n      if (stateName === 'active' || stateName === 'selected') {\n        shape === null || shape === void 0 ? void 0 : shape.toFront();\n      }\n    } else {\n      if (index === -1) {\n        // 关闭状态，但是状态未设置过\n        return;\n      }\n\n      states.splice(index, 1);\n\n      if (stateName === 'active' || stateName === 'selected') {\n        var _b = this.geometry,\n            sortZIndex = _b.sortZIndex,\n            zIndexReversed = _b.zIndexReversed;\n        var idx = zIndexReversed ? this.geometry.elements.length - this.elementIndex : this.elementIndex;\n        sortZIndex ? shape.setZIndex(idx) : shape.set('zIndex', idx);\n      }\n    } // 使用虚拟 group 重新绘制 shape，然后对这个 shape 应用状态样式后，更新当前 shape。\n\n\n    var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());\n\n    if (states.length) {\n      // 应用当前状态\n      this.syncShapeStyle(shape, offscreenShape, states, null);\n    } else {\n      // 如果没有状态，则需要恢复至原始状态\n      this.syncShapeStyle(shape, offscreenShape, ['reset'], null);\n    }\n\n    offscreenShape.remove(true); // 销毁，减少内存占用\n\n    var eventObject = {\n      state: stateName,\n      stateStatus: stateStatus,\n      element: this,\n      target: this.container\n    };\n    this.container.emit('statechange', eventObject); // @ts-ignore\n\n    propagationDelegate(this.shape, 'statechange', eventObject);\n  };\n  /**\n   * 清空状量态，恢复至初始状态。\n   */\n\n\n  Element.prototype.clearStates = function () {\n    var _this = this;\n\n    var states = this.states;\n    each(states, function (state) {\n      _this.setState(state, false);\n    });\n    this.states = [];\n  };\n  /**\n   * 查询当前 Element 上是否已设置 `stateName` 对应的状态。\n   * @param stateName 状态名称。\n   * @returns true 表示存在，false 表示不存在。\n   */\n\n\n  Element.prototype.hasState = function (stateName) {\n    return this.states.includes(stateName);\n  };\n  /**\n   * 获取当前 Element 上所有的状态。\n   * @returns 当前 Element 上所有的状态数组。\n   */\n\n\n  Element.prototype.getStates = function () {\n    return this.states;\n  };\n  /**\n   * 获取 Element 对应的原始数据。\n   * @returns 原始数据。\n   */\n\n\n  Element.prototype.getData = function () {\n    return this.data;\n  };\n  /**\n   * 获取 Element 对应的图形绘制数据。\n   * @returns 图形绘制数据。\n   */\n\n\n  Element.prototype.getModel = function () {\n    return this.model;\n  };\n  /**\n   * 返回 Element 元素整体的 bbox，包含文本及文本连线（有的话）。\n   * @returns 整体包围盒。\n   */\n\n\n  Element.prototype.getBBox = function () {\n    var _a = this,\n        shape = _a.shape,\n        labelShape = _a.labelShape;\n\n    var bbox = {\n      x: 0,\n      y: 0,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: 0,\n      height: 0\n    };\n\n    if (shape) {\n      bbox = shape.getCanvasBBox();\n    }\n\n    if (labelShape) {\n      labelShape.forEach(function (label) {\n        var labelBBox = label.getCanvasBBox();\n        bbox.x = Math.min(labelBBox.x, bbox.x);\n        bbox.y = Math.min(labelBBox.y, bbox.y);\n        bbox.minX = Math.min(labelBBox.minX, bbox.minX);\n        bbox.minY = Math.min(labelBBox.minY, bbox.minY);\n        bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);\n        bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);\n      });\n    }\n\n    bbox.width = bbox.maxX - bbox.minX;\n    bbox.height = bbox.maxY - bbox.minY;\n    return bbox;\n  };\n\n  Element.prototype.getStatesStyle = function () {\n    if (!this.statesStyle) {\n      var _a = this,\n          shapeType = _a.shapeType,\n          geometry = _a.geometry,\n          shapeFactory = _a.shapeFactory;\n\n      var stateOption = geometry.stateOption;\n      var defaultShapeType = shapeFactory.defaultShapeType;\n      var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];\n      this.statesStyle = deepMix({}, stateTheme, stateOption);\n    }\n\n    return this.statesStyle;\n  }; // 从主题中获取对应状态量的样式\n\n\n  Element.prototype.getStateStyle = function (stateName, shapeKey) {\n    var statesStyle = this.getStatesStyle();\n    var stateCfg = get(statesStyle, [stateName, 'style'], {});\n    var shapeStyle = stateCfg[shapeKey] || stateCfg;\n\n    if (isFunction(shapeStyle)) {\n      return shapeStyle(this);\n    }\n\n    return shapeStyle;\n  }; // 获取动画配置\n\n\n  Element.prototype.getAnimateCfg = function (animateType) {\n    var _this = this;\n\n    var animate = this.animate;\n\n    if (animate) {\n      var cfg_1 = animate[animateType];\n\n      if (cfg_1) {\n        // 增加动画的回调函数，如果外部传入了，则先执行外部，然后发射 geometry 的 animate 事件\n        return __assign(__assign({}, cfg_1), {\n          callback: function () {\n            var _a;\n\n            isFunction(cfg_1.callback) && cfg_1.callback();\n            (_a = _this.geometry) === null || _a === void 0 ? void 0 : _a.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);\n          }\n        });\n      }\n\n      return cfg_1;\n    }\n\n    return null;\n  }; // 绘制图形\n\n\n  Element.prototype.drawShape = function (model, isUpdate) {\n    var _a;\n\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n\n    var _b = this,\n        shapeFactory = _b.shapeFactory,\n        container = _b.container,\n        shapeType = _b.shapeType; // 自定义 shape 有可能返回空 shape\n\n\n    this.shape = shapeFactory.drawShape(shapeType, model, container);\n\n    if (this.shape) {\n      this.setShapeInfo(this.shape, model); // 存储绘图数据\n      // @ts-ignore\n\n      var name_1 = this.shape.cfg.name; // 附加 element 的 name, name 现在支持数组了，很好用了\n\n      if (!name_1) {\n        // 这个地方如果用户添加了 name, 则附加 name ，否则就添加自己的 name\n        // @ts-ignore\n        this.shape.cfg.name = ['element', this.shapeFactory.geometryType];\n      } else if (isString(name_1)) {\n        // @ts-ignore\n        this.shape.cfg.name = ['element', name_1];\n      } // 执行入场动画\n\n\n      var animateType = isUpdate ? 'enter' : 'appear';\n      var animateCfg = this.getAnimateCfg(animateType);\n\n      if (animateCfg) {\n        // 开始执行动画的生命周期\n        (_a = this.geometry) === null || _a === void 0 ? void 0 : _a.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);\n        doAnimate(this.shape, animateCfg, {\n          coordinate: shapeFactory.coordinate,\n          toAttrs: __assign({}, this.shape.attr())\n        });\n      }\n    }\n  }; // 获取虚拟 Group\n\n\n  Element.prototype.getOffscreenGroup = function () {\n    if (!this.offscreenGroup) {\n      var GroupCtor = this.container.getGroupBase(); // 获取分组的构造函数\n\n      this.offscreenGroup = new GroupCtor({});\n    }\n\n    return this.offscreenGroup;\n  }; // 设置 shape 上需要携带的信息\n\n\n  Element.prototype.setShapeInfo = function (shape, data) {\n    var _this = this; // @ts-ignore\n\n\n    shape.cfg.origin = data; // @ts-ignore\n\n    shape.cfg.element = this;\n\n    if (shape.isGroup()) {\n      var children = shape.get('children');\n      children.forEach(function (child) {\n        _this.setShapeInfo(child, data);\n      });\n    }\n  }; // 更新当前 shape 的样式\n\n\n  Element.prototype.syncShapeStyle = function (sourceShape, targetShape, states, animateCfg, index) {\n    var _this = this;\n\n    var _a;\n\n    if (states === void 0) {\n      states = [];\n    }\n\n    if (index === void 0) {\n      index = 0;\n    }\n\n    if (!sourceShape || !targetShape) {\n      return;\n    } // 所有的 shape 都需要同步 clip\n\n\n    var clip = sourceShape.get('clipShape');\n    var newClip = targetShape.get('clipShape');\n    this.syncShapeStyle(clip, newClip, states, animateCfg);\n\n    if (sourceShape.isGroup()) {\n      var children = sourceShape.get('children');\n      var newChildren = targetShape.get('children');\n\n      for (var i = 0; i < children.length; i++) {\n        this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);\n      }\n    } else {\n      if (!isEmpty(states) && !isEqual(states, ['reset'])) {\n        var name_2 = sourceShape.get('name');\n\n        if (isArray(name_2)) {\n          // 会附加 element 的 name\n          name_2 = name_2[1];\n        }\n\n        each(states, function (state) {\n          // background shape 不进行状态样式设置\n          if (targetShape.get('name') !== BACKGROUND_SHAPE) {\n            var style = _this.getStateStyle(state, name_2 || index); // 如果用户没有设置 name，则默认根据索引值\n\n\n            targetShape.attr(style);\n          }\n        });\n      }\n\n      var newAttrs = getReplaceAttrs(sourceShape, targetShape);\n\n      if (this.animate) {\n        if (animateCfg) {\n          (_a = this.geometry) === null || _a === void 0 ? void 0 : _a.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE); // 需要进行动画\n\n          doAnimate(sourceShape, animateCfg, {\n            coordinate: this.shapeFactory.coordinate,\n            toAttrs: newAttrs,\n            shapeModel: this.model\n          });\n        } else if (!isEmpty(states)) {\n          sourceShape.stopAnimate();\n          sourceShape.animate(newAttrs, {\n            duration: 300\n          });\n        } else {\n          sourceShape.attr(newAttrs);\n        }\n      } else {\n        sourceShape.attr(newAttrs);\n      }\n    }\n  };\n\n  Element.prototype.getShapeType = function (model) {\n    var shape = get(model, 'shape');\n    return isArray(shape) ? shape[0] : shape;\n  };\n\n  return Element;\n}(Base);\n\nexport default Element;","map":{"version":3,"mappings":"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","names":["deepMix","each","get","isArray","isEmpty","isEqual","isFunction","isString","propagationDelegate","doAnimate","Base","getReplaceAttrs","GEOMETRY_LIFE_CIRCLE","BACKGROUND_SHAPE","__extends","cfg","_super","_this","container","offscreenGroup","elementIndex","_a","visible","shapeFactory","Element","model","isUpdate","data","shapeType","getShapeType","drawShape","changeVisible","shape","setShapeInfo","getOffscreenGroup","newShape","origin","element","syncShapeStyle","getStates","getAnimateCfg","animateCfg","coordinate","toAttrs","attr","remove","states","undefined","animate","geometry","labelShape","statesStyle","destroy","call","show","forEach","label","hide","stateName","stateStatus","index","indexOf","push","toFront","splice","sortZIndex","zIndexReversed","idx","elements","length","setZIndex","set","offscreenShape","eventObject","state","target","emit","setState","includes","bbox","x","y","minX","minY","maxX","maxY","width","height","getCanvasBBox","labelBBox","Math","min","max","stateOption","defaultShapeType","stateTheme","theme","shapeKey","getStatesStyle","stateCfg","shapeStyle","animateType","cfg_1","callback","AFTER_DRAW_ANIMATE","name_1","name","geometryType","BEFORE_DRAW_ANIMATE","GroupCtor","getGroupBase","isGroup","children","child","sourceShape","targetShape","clip","newClip","newChildren","i","name_2","style","getStateStyle","newAttrs","shapeModel","stopAnimate","duration"],"sourceRoot":"","sources":["../../../src/geometry/element/index.ts"],"sourcesContent":["import { deepMix, each, get, isArray, isEmpty, isEqual, isFunction, isString } from '@antv/util';\n// 暂未发包\n// @ts-ignore\nimport { propagationDelegate } from '@antv/component';\nimport { doAnimate } from '../../animate';\nimport Base from '../../base';\nimport { BBox, IGroup, IShape } from '../../dependents';\nimport { AnimateOption, Datum, ShapeFactory, ShapeInfo, StateCfg } from '../../interface';\nimport { getReplaceAttrs } from '../../util/graphics';\nimport Geometry from '../base';\nimport { GEOMETRY_LIFE_CIRCLE } from '../../constant';\nimport { BACKGROUND_SHAPE } from '../shape/constant';\n\n/** Element 构造函数传入参数类型 */\ninterface ElementCfg {\n  /** 用于创建各种 shape 的工厂对象 */\n  shapeFactory: ShapeFactory;\n  /** shape 容器 */\n  container: IGroup;\n  /** element 的索引 */\n  elementIndex?: number;\n  /** 虚拟 group，用户可以不传入 */\n  offscreenGroup?: IGroup;\n  /** 是否可见 */\n  visible?: boolean;\n}\n\n/**\n * Element 图形元素。\n * 定义：在 G2 中，我们会将数据通过图形语法映射成不同的图形，比如点图，数据集中的每条数据会对应一个点，柱状图每条数据对应一个柱子，线图则是一组数据对应一条折线，Element 即一条/一组数据对应的图形元素，它代表一条数据或者一个数据集，在图形层面，它可以是单个 Shape 也可以是多个 Shape，我们称之为图形元素。\n */\nexport default class Element extends Base {\n  /** 用于创建各种 shape 的工厂对象 */\n  public shapeFactory: ShapeFactory;\n  /** shape 容器 */\n  public container: IGroup;\n  /** element 索引 */\n  public elementIndex: number;\n  /** 最后创建的图形对象 */\n  public shape: IShape | IGroup;\n  /** shape 的动画配置 */\n  public animate: AnimateOption | boolean;\n\n  // 非构造函数属性，需要外部赋值\n  /** element 对应的 Geometry 实例 */\n  public geometry: Geometry;\n  /** 保存 shape 对应的 label */\n  public labelShape: IGroup[] = [];\n\n  /** 绘制的 shape 类型 */\n  private shapeType: string;\n\n  /** shape 绘制需要的数据 */\n  private model: ShapeInfo;\n  /** 原始数据 */\n  private data: Datum;\n  // 存储当前开启的状态\n  private states: string[] = [];\n  private statesStyle;\n  // 虚拟 Group\n  private offscreenGroup: IGroup;\n\n  constructor(cfg: ElementCfg) {\n    super(cfg);\n\n    const { shapeFactory, container, offscreenGroup, elementIndex, visible = true } = cfg;\n    this.shapeFactory = shapeFactory;\n    this.container = container;\n    this.offscreenGroup = offscreenGroup;\n    this.visible = visible;\n    this.elementIndex = elementIndex;\n  }\n\n  /**\n   * 绘制图形。\n   * @param model 绘制数据。\n   * @param isUpdate 可选，是否是更新发生后的绘制。\n   */\n  public draw(model: ShapeInfo, isUpdate: boolean = false) {\n    this.model = model;\n    this.data = model.data; // 存储原始数据\n    this.shapeType = this.getShapeType(model);\n\n    // 绘制图形\n    this.drawShape(model, isUpdate);\n\n    if (this.visible === false) {\n      // 用户在初始化的时候声明 visible: false\n      this.changeVisible(false);\n    }\n  }\n\n  /**\n   * 更新图形。\n   * @param model 更新的绘制数据。\n   */\n  public update(model: ShapeInfo) {\n    const { shapeFactory, shape } = this;\n    if (!shape) {\n      return;\n    }\n\n    // 更新数据\n    this.model = model;\n    this.data = model.data;\n    this.shapeType = this.getShapeType(model);\n\n    // step 1: 更新 shape 携带的信息\n    this.setShapeInfo(shape, model);\n\n    // step 2: 使用虚拟 Group 重新绘制 shape，然后更新当前 shape\n    const offscreenGroup = this.getOffscreenGroup();\n    const newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);\n    // @ts-ignore\n    newShape.cfg.data = this.data;\n    // @ts-ignore\n    newShape.cfg.origin = model;\n    // label 需要使用\n    newShape.cfg.element = this;\n\n    // step 3: 同步 shape 样式\n    this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg('update'));\n  }\n\n  /**\n   * 销毁 element 实例。\n   */\n  public destroy() {\n    const { shapeFactory, shape } = this;\n\n    if (shape) {\n      const animateCfg = this.getAnimateCfg('leave');\n      if (animateCfg) {\n        // 指定了动画配置则执行销毁动画\n        doAnimate(shape, animateCfg, {\n          coordinate: shapeFactory.coordinate,\n          toAttrs: {\n            ...shape.attr(),\n          },\n        });\n      } else {\n        // 否则直接销毁\n        shape.remove(true);\n      }\n    }\n\n    // reset\n    this.states = [];\n    this.shapeFactory = undefined;\n    this.container = undefined;\n    this.shape = undefined;\n    this.animate = undefined;\n    this.geometry = undefined;\n    this.labelShape = [];\n    this.model = undefined;\n    this.data = undefined;\n    this.offscreenGroup = undefined;\n    this.statesStyle = undefined;\n\n    super.destroy();\n  }\n\n  /**\n   * 显示或者隐藏 element。\n   * @param visible 是否可见。\n   */\n  public changeVisible(visible: boolean) {\n    super.changeVisible(visible);\n\n    if (visible) {\n      if (this.shape) {\n        this.shape.show();\n      }\n      if (this.labelShape) {\n        this.labelShape.forEach((label: IGroup) => {\n          label.show();\n        });\n      }\n    } else {\n      if (this.shape) {\n        this.shape.hide();\n      }\n      if (this.labelShape) {\n        this.labelShape.forEach((label: IGroup) => {\n          label.hide();\n        });\n      }\n    }\n  }\n\n  /**\n   * 设置 Element 的状态。\n   *\n   * 目前 Element 开放三种状态：\n   * 1. active\n   * 2. selected\n   * 3. inactive\n   *\n   * 这三种状态相互独立，可以进行叠加。\n   *\n   * 这三种状态的样式可在 [[Theme]] 主题中或者通过 `geometry.state()` 接口进行配置。\n   *\n   * ```ts\n   * // 激活 active 状态\n   * setState('active', true);\n   * ```\n   *\n   * @param stateName 状态名\n   * @param stateStatus 是否开启状态\n   */\n  public setState(stateName: string, stateStatus: boolean) {\n    const { states, shapeFactory, model, shape, shapeType } = this;\n\n    const index = states.indexOf(stateName);\n    if (stateStatus) {\n      // 开启状态\n      if (index > -1) {\n        // 该状态已经开启，则返回\n        return;\n      }\n      states.push(stateName);\n      if (stateName === 'active' || stateName === 'selected') {\n        shape?.toFront();\n      }\n    } else {\n      if (index === -1) {\n        // 关闭状态，但是状态未设置过\n        return;\n      }\n      states.splice(index, 1);\n      if (stateName === 'active' || stateName === 'selected') {\n        const { sortZIndex, zIndexReversed } = this.geometry;\n        const idx = zIndexReversed ? this.geometry.elements.length - this.elementIndex : this.elementIndex;\n        sortZIndex ? shape.setZIndex(idx) : shape.set('zIndex', idx);\n      }\n    }\n\n    // 使用虚拟 group 重新绘制 shape，然后对这个 shape 应用状态样式后，更新当前 shape。\n    const offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());\n    if (states.length) {\n      // 应用当前状态\n      this.syncShapeStyle(shape, offscreenShape, states, null);\n    } else {\n      // 如果没有状态，则需要恢复至原始状态\n      this.syncShapeStyle(shape, offscreenShape, ['reset'], null);\n    }\n\n    offscreenShape.remove(true); // 销毁，减少内存占用\n\n    const eventObject = {\n      state: stateName,\n      stateStatus,\n      element: this,\n      target: this.container,\n    };\n    this.container.emit('statechange', eventObject);\n    // @ts-ignore\n    propagationDelegate(this.shape, 'statechange', eventObject);\n  }\n\n  /**\n   * 清空状量态，恢复至初始状态。\n   */\n  public clearStates() {\n    const states = this.states;\n\n    each(states, (state) => {\n      this.setState(state, false);\n    });\n\n    this.states = [];\n  }\n\n  /**\n   * 查询当前 Element 上是否已设置 `stateName` 对应的状态。\n   * @param stateName 状态名称。\n   * @returns true 表示存在，false 表示不存在。\n   */\n  public hasState(stateName: string): boolean {\n    return this.states.includes(stateName);\n  }\n\n  /**\n   * 获取当前 Element 上所有的状态。\n   * @returns 当前 Element 上所有的状态数组。\n   */\n  public getStates(): string[] {\n    return this.states;\n  }\n\n  /**\n   * 获取 Element 对应的原始数据。\n   * @returns 原始数据。\n   */\n  public getData(): Datum {\n    return this.data;\n  }\n\n  /**\n   * 获取 Element 对应的图形绘制数据。\n   * @returns 图形绘制数据。\n   */\n  public getModel(): ShapeInfo {\n    return this.model;\n  }\n\n  /**\n   * 返回 Element 元素整体的 bbox，包含文本及文本连线（有的话）。\n   * @returns 整体包围盒。\n   */\n  public getBBox(): BBox {\n    const { shape, labelShape } = this;\n    let bbox = {\n      x: 0,\n      y: 0,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: 0,\n      height: 0,\n    };\n    if (shape) {\n      bbox = shape.getCanvasBBox();\n    }\n    if (labelShape) {\n      labelShape.forEach((label: IGroup) => {\n        const labelBBox = label.getCanvasBBox();\n        bbox.x = Math.min(labelBBox.x, bbox.x);\n        bbox.y = Math.min(labelBBox.y, bbox.y);\n        bbox.minX = Math.min(labelBBox.minX, bbox.minX);\n        bbox.minY = Math.min(labelBBox.minY, bbox.minY);\n        bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);\n        bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);\n      });\n    }\n\n    bbox.width = bbox.maxX - bbox.minX;\n    bbox.height = bbox.maxY - bbox.minY;\n\n    return bbox;\n  }\n\n  private getStatesStyle() {\n    if (!this.statesStyle) {\n      const { shapeType, geometry, shapeFactory } = this;\n      const stateOption = geometry.stateOption;\n      const defaultShapeType = shapeFactory.defaultShapeType;\n      const stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];\n      this.statesStyle = deepMix({}, stateTheme, stateOption);\n    }\n\n    return this.statesStyle;\n  }\n\n  // 从主题中获取对应状态量的样式\n  private getStateStyle(stateName: string, shapeKey?: string): StateCfg {\n    const statesStyle = this.getStatesStyle();\n    const stateCfg = get(statesStyle, [stateName, 'style'], {});\n    const shapeStyle = stateCfg[shapeKey] || stateCfg;\n    if (isFunction(shapeStyle)) {\n      return shapeStyle(this);\n    }\n\n    return shapeStyle;\n  }\n\n  // 获取动画配置\n  private getAnimateCfg(animateType: string) {\n    const animate = this.animate;\n    if (animate) {\n      const cfg = animate[animateType];\n\n      if (cfg) {\n        // 增加动画的回调函数，如果外部传入了，则先执行外部，然后发射 geometry 的 animate 事件\n        return {\n          ...cfg,\n          callback: () => {\n            isFunction(cfg.callback) && cfg.callback();\n            this.geometry?.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);\n          },\n        };\n      }\n      return cfg;\n    }\n\n    return null;\n  }\n\n  // 绘制图形\n  private drawShape(model: ShapeInfo, isUpdate: boolean = false) {\n    const { shapeFactory, container, shapeType } = this;\n\n    // 自定义 shape 有可能返回空 shape\n    this.shape = shapeFactory.drawShape(shapeType, model, container);\n\n    if (this.shape) {\n      this.setShapeInfo(this.shape, model); // 存储绘图数据\n      // @ts-ignore\n      const name = this.shape.cfg.name;\n      // 附加 element 的 name, name 现在支持数组了，很好用了\n      if (!name) {\n        // 这个地方如果用户添加了 name, 则附加 name ，否则就添加自己的 name\n        // @ts-ignore\n        this.shape.cfg.name = ['element', this.shapeFactory.geometryType];\n      } else if (isString(name)) {\n        // @ts-ignore\n        this.shape.cfg.name = ['element', name];\n      }\n      // 执行入场动画\n      const animateType = isUpdate ? 'enter' : 'appear';\n      const animateCfg = this.getAnimateCfg(animateType);\n      if (animateCfg) {\n        // 开始执行动画的生命周期\n        this.geometry?.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);\n\n        doAnimate(this.shape, animateCfg, {\n          coordinate: shapeFactory.coordinate,\n          toAttrs: {\n            ...this.shape.attr(),\n          },\n        });\n      }\n    }\n  }\n\n  // 获取虚拟 Group\n  private getOffscreenGroup() {\n    if (!this.offscreenGroup) {\n      const GroupCtor = this.container.getGroupBase(); // 获取分组的构造函数\n      this.offscreenGroup = new GroupCtor({});\n    }\n\n    return this.offscreenGroup;\n  }\n\n  // 设置 shape 上需要携带的信息\n  private setShapeInfo(shape: IShape | IGroup, data: ShapeInfo) {\n    // @ts-ignore\n    shape.cfg.origin = data;\n    // @ts-ignore\n    shape.cfg.element = this;\n    if (shape.isGroup()) {\n      const children = shape.get('children');\n      children.forEach((child) => {\n        this.setShapeInfo(child, data);\n      });\n    }\n  }\n\n  // 更新当前 shape 的样式\n  private syncShapeStyle(\n    sourceShape: IGroup | IShape,\n    targetShape: IGroup | IShape,\n    states: string[] = [],\n    animateCfg,\n    index: number = 0\n  ) {\n    if (!sourceShape || !targetShape) {\n      return;\n    }\n    // 所有的 shape 都需要同步 clip\n    const clip = sourceShape.get('clipShape');\n    const newClip = targetShape.get('clipShape');\n\n    this.syncShapeStyle(clip, newClip, states, animateCfg);\n\n    if (sourceShape.isGroup()) {\n      const children = sourceShape.get('children');\n      const newChildren = targetShape.get('children');\n      for (let i = 0; i < children.length; i++) {\n        this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);\n      }\n    } else {\n      if (!isEmpty(states) && !isEqual(states, ['reset'])) {\n        let name = sourceShape.get('name');\n        if (isArray(name)) {\n          // 会附加 element 的 name\n          name = name[1];\n        }\n\n        each(states, (state) => {\n          // background shape 不进行状态样式设置\n          if (targetShape.get('name') !== BACKGROUND_SHAPE) {\n            const style = this.getStateStyle(state, name || index); // 如果用户没有设置 name，则默认根据索引值\n            targetShape.attr(style);\n          }\n        });\n      }\n      const newAttrs = getReplaceAttrs(sourceShape as IShape, targetShape as IShape);\n\n      if (this.animate) {\n        if (animateCfg) {\n          this.geometry?.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);\n          // 需要进行动画\n          doAnimate(sourceShape, animateCfg, {\n            coordinate: this.shapeFactory.coordinate,\n            toAttrs: newAttrs,\n            shapeModel: this.model,\n          });\n        } else if (!isEmpty(states)) {\n          sourceShape.stopAnimate();\n          sourceShape.animate(newAttrs, {\n            duration: 300,\n          });\n        } else {\n          sourceShape.attr(newAttrs);\n        }\n      } else {\n        sourceShape.attr(newAttrs);\n      }\n    }\n  }\n\n  private getShapeType(model: ShapeInfo) {\n    const shape = get(model, 'shape');\n    return isArray(shape) ? shape[0] : shape;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}