{"ast":null,"code":"import { nelderMead, bisect, conjugateGradient, zeros, zerosM, norm2, scale } from 'fmin';\nimport { intersectionArea, circleOverlap, circleCircleIntersection, distance } from './circleintersection';\n/** given a list of set objects, and their corresponding overlaps.\nupdates the (x, y, radius) attribute on each set such that their positions\nroughly correspond to the desired overlaps */\n\nexport function venn(areas, parameters) {\n  parameters = parameters || {};\n  parameters.maxIterations = parameters.maxIterations || 500;\n  var initialLayout = parameters.initialLayout || bestInitialLayout;\n  var loss = parameters.lossFunction || lossFunction; // add in missing pairwise areas as having 0 size\n\n  areas = addMissingAreas(areas); // initial layout is done greedily\n\n  var circles = initialLayout(areas, parameters); // transform x/y coordinates to a vector to optimize\n\n  var initial = [],\n      setids = [];\n  var setid;\n\n  for (setid in circles) {\n    // eslint-disable-next-line\n    if (circles.hasOwnProperty(setid)) {\n      initial.push(circles[setid].x);\n      initial.push(circles[setid].y);\n      setids.push(setid);\n    }\n  } // optimize initial layout from our loss function\n\n\n  var solution = nelderMead(function (values) {\n    var current = {};\n\n    for (var i = 0; i < setids.length; ++i) {\n      var setid_1 = setids[i];\n      current[setid_1] = {\n        x: values[2 * i],\n        y: values[2 * i + 1],\n        radius: circles[setid_1].radius\n      };\n    }\n\n    return loss(current, areas);\n  }, initial, parameters); // transform solution vector back to x/y points\n\n  var positions = solution.x;\n\n  for (var i = 0; i < setids.length; ++i) {\n    setid = setids[i];\n    circles[setid].x = positions[2 * i];\n    circles[setid].y = positions[2 * i + 1];\n  }\n\n  return circles;\n}\nvar SMALL = 1e-10;\n/** Returns the distance necessary for two circles of radius r1 + r2 to\nhave the overlap area 'overlap' */\n\nexport function distanceFromIntersectArea(r1, r2, overlap) {\n  // handle complete overlapped circles\n  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL) {\n    return Math.abs(r1 - r2);\n  }\n\n  return bisect(function (distance) {\n    return circleOverlap(r1, r2, distance) - overlap;\n  }, 0, r1 + r2);\n}\n/** Missing pair-wise intersection area data can cause problems:\n treating as an unknown means that sets will be laid out overlapping,\n which isn't what people expect. To reflect that we want disjoint sets\n here, set the overlap to 0 for all missing pairwise set intersections */\n\nfunction addMissingAreas(areas) {\n  areas = areas.slice(); // two circle intersections that aren't defined\n\n  var ids = [],\n      pairs = {};\n  var i, j, a, b;\n\n  for (i = 0; i < areas.length; ++i) {\n    var area = areas[i];\n\n    if (area.sets.length == 1) {\n      ids.push(area.sets[0]);\n    } else if (area.sets.length == 2) {\n      a = area.sets[0];\n      b = area.sets[1]; // @ts-ignore\n\n      pairs[[a, b]] = true; // @ts-ignore\n\n      pairs[[b, a]] = true;\n    }\n  }\n\n  ids.sort(function (a, b) {\n    return a > b ? 1 : -1;\n  });\n\n  for (i = 0; i < ids.length; ++i) {\n    a = ids[i];\n\n    for (j = i + 1; j < ids.length; ++j) {\n      b = ids[j]; // @ts-ignore\n\n      if (!([a, b] in pairs)) {\n        areas.push({\n          sets: [a, b],\n          size: 0\n        });\n      }\n    }\n  }\n\n  return areas;\n} /// Returns two matrices, one of the euclidean distances between the sets\n/// and the other indicating if there are subset or disjoint set relationships\n\n\nexport function getDistanceMatrices(areas, sets, setids) {\n  // initialize an empty distance matrix between all the points\n  var distances = zerosM(sets.length, sets.length),\n      constraints = zerosM(sets.length, sets.length); // compute required distances between all the sets such that\n  // the areas match\n\n  areas.filter(function (x) {\n    return x.sets.length == 2;\n  }).map(function (current) {\n    var left = setids[current.sets[0]],\n        right = setids[current.sets[1]],\n        r1 = Math.sqrt(sets[left].size / Math.PI),\n        r2 = Math.sqrt(sets[right].size / Math.PI),\n        distance = distanceFromIntersectArea(r1, r2, current.size);\n    distances[left][right] = distances[right][left] = distance; // also update constraints to indicate if its a subset or disjoint\n    // relationship\n\n    var c = 0;\n\n    if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n      c = 1;\n    } else if (current.size <= 1e-10) {\n      c = -1;\n    }\n\n    constraints[left][right] = constraints[right][left] = c;\n  });\n  return {\n    distances: distances,\n    constraints: constraints\n  };\n} /// computes the gradient and loss simulatenously for our constrained MDS optimizer\n\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n  var loss = 0,\n      i;\n\n  for (i = 0; i < fxprime.length; ++i) {\n    fxprime[i] = 0;\n  }\n\n  for (i = 0; i < distances.length; ++i) {\n    var xi = x[2 * i],\n        yi = x[2 * i + 1];\n\n    for (var j = i + 1; j < distances.length; ++j) {\n      var xj = x[2 * j],\n          yj = x[2 * j + 1],\n          dij = distances[i][j],\n          constraint = constraints[i][j];\n      var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n          distance_1 = Math.sqrt(squaredDistance),\n          delta = squaredDistance - dij * dij;\n\n      if (constraint > 0 && distance_1 <= dij || constraint < 0 && distance_1 >= dij) {\n        continue;\n      }\n\n      loss += 2 * delta * delta;\n      fxprime[2 * i] += 4 * delta * (xi - xj);\n      fxprime[2 * i + 1] += 4 * delta * (yi - yj);\n      fxprime[2 * j] += 4 * delta * (xj - xi);\n      fxprime[2 * j + 1] += 4 * delta * (yj - yi);\n    }\n  }\n\n  return loss;\n} /// takes the best working variant of either constrained MDS or greedy\n\n\nexport function bestInitialLayout(areas, params) {\n  var initial = greedyLayout(areas, params);\n  var loss = params.lossFunction || lossFunction; // greedylayout is sufficient for all 2/3 circle cases. try out\n  // constrained MDS for higher order problems, take its output\n  // if it outperforms. (greedy is aesthetically better on 2/3 circles\n  // since it axis aligns)\n\n  if (areas.length >= 8) {\n    var constrained = constrainedMDSLayout(areas, params),\n        constrainedLoss = loss(constrained, areas),\n        greedyLoss = loss(initial, areas);\n\n    if (constrainedLoss + 1e-8 < greedyLoss) {\n      initial = constrained;\n    }\n  }\n\n  return initial;\n} /// use the constrained MDS variant to generate an initial layout\n\nexport function constrainedMDSLayout(areas, params) {\n  params = params || {};\n  var restarts = params.restarts || 10; // bidirectionally map sets to a rowid  (so we can create a matrix)\n\n  var sets = [],\n      setids = {};\n  var i;\n\n  for (i = 0; i < areas.length; ++i) {\n    var area = areas[i];\n\n    if (area.sets.length == 1) {\n      setids[area.sets[0]] = sets.length;\n      sets.push(area);\n    }\n  }\n\n  var matrices = getDistanceMatrices(areas, sets, setids);\n  var distances = matrices.distances;\n  var constraints = matrices.constraints; // keep distances bounded, things get messed up otherwise.\n  // TODO: proper preconditioner?\n\n  var norm = norm2(distances.map(norm2)) / distances.length;\n  distances = distances.map(function (row) {\n    return row.map(function (value) {\n      return value / norm;\n    });\n  });\n\n  var obj = function (x, fxprime) {\n    return constrainedMDSGradient(x, fxprime, distances, constraints);\n  };\n\n  var best, current;\n\n  for (i = 0; i < restarts; ++i) {\n    var initial = zeros(distances.length * 2).map(Math.random);\n    current = conjugateGradient(obj, initial, params);\n\n    if (!best || current.fx < best.fx) {\n      best = current;\n    }\n  }\n\n  var positions = best.x; // translate rows back to (x,y,radius) coordinates\n\n  var circles = {};\n\n  for (i = 0; i < sets.length; ++i) {\n    var set = sets[i];\n    circles[set.sets[0]] = {\n      x: positions[2 * i] * norm,\n      y: positions[2 * i + 1] * norm,\n      radius: Math.sqrt(set.size / Math.PI)\n    };\n  }\n\n  if (params.history) {\n    for (i = 0; i < params.history.length; ++i) {\n      scale(params.history[i].x, norm);\n    }\n  }\n\n  return circles;\n}\n/** Lays out a Venn diagram greedily, going from most overlapped sets to\nleast overlapped, attempting to position each new set such that the\noverlapping areas to already positioned sets are basically right */\n\nexport function greedyLayout(areas, params) {\n  var loss = params && params.lossFunction ? params.lossFunction : lossFunction; // define a circle for each set\n\n  var circles = {},\n      setOverlaps = {};\n  var set;\n\n  for (var i = 0; i < areas.length; ++i) {\n    var area = areas[i];\n\n    if (area.sets.length == 1) {\n      set = area.sets[0];\n      circles[set] = {\n        x: 1e10,\n        y: 1e10,\n        // rowid: circles.length, // fix to ->\n        rowid: Object.keys(circles).length,\n        size: area.size,\n        radius: Math.sqrt(area.size / Math.PI)\n      };\n      setOverlaps[set] = [];\n    }\n  }\n\n  areas = areas.filter(function (a) {\n    return a.sets.length == 2;\n  }); // map each set to a list of all the other sets that overlap it\n\n  for (var i = 0; i < areas.length; ++i) {\n    var current = areas[i]; // eslint-disable-next-line\n\n    var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n    var left = current.sets[0],\n        right = current.sets[1]; // completely overlapped circles shouldn't be positioned early here\n\n    if (current.size + SMALL >= Math.min(circles[left].size, circles[right].size)) {\n      weight = 0;\n    }\n\n    setOverlaps[left].push({\n      set: right,\n      size: current.size,\n      weight: weight\n    });\n    setOverlaps[right].push({\n      set: left,\n      size: current.size,\n      weight: weight\n    });\n  } // get list of most overlapped sets\n\n\n  var mostOverlapped = [];\n\n  for (set in setOverlaps) {\n    // eslint-disable-next-line\n    if (setOverlaps.hasOwnProperty(set)) {\n      var size = 0;\n\n      for (var i = 0; i < setOverlaps[set].length; ++i) {\n        size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n      }\n\n      mostOverlapped.push({\n        set: set,\n        size: size\n      });\n    }\n  } // sort by size desc\n\n\n  function sortOrder(a, b) {\n    return b.size - a.size;\n  }\n\n  mostOverlapped.sort(sortOrder); // keep track of what sets have been laid out\n\n  var positioned = {};\n\n  function isPositioned(element) {\n    return element.set in positioned;\n  } // adds a point to the output\n\n\n  function positionSet(point, index) {\n    circles[index].x = point.x;\n    circles[index].y = point.y;\n    positioned[index] = true;\n  } // add most overlapped set at (0,0)\n\n\n  positionSet({\n    x: 0,\n    y: 0\n  }, mostOverlapped[0].set); // get distances between all points. TODO, necessary?\n  // answer: probably not\n  // var distances = venn.getDistanceMatrices(circles, areas).distances;\n\n  for (var i = 1; i < mostOverlapped.length; ++i) {\n    var setIndex = mostOverlapped[i].set,\n        overlap = setOverlaps[setIndex].filter(isPositioned);\n    set = circles[setIndex];\n    overlap.sort(sortOrder);\n\n    if (overlap.length === 0) {\n      // this shouldn't happen anymore with addMissingAreas\n      throw 'ERROR: missing pairwise overlap information';\n    }\n\n    var points = [];\n\n    for (var j = 0; j < overlap.length; ++j) {\n      // get appropriate distance from most overlapped already added set\n      var p1 = circles[overlap[j].set],\n          d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size); // sample positions at 90 degrees for maximum aesthetics\n\n      points.push({\n        x: p1.x + d1,\n        y: p1.y\n      });\n      points.push({\n        x: p1.x - d1,\n        y: p1.y\n      });\n      points.push({\n        y: p1.y + d1,\n        x: p1.x\n      });\n      points.push({\n        y: p1.y - d1,\n        x: p1.x\n      }); // if we have at least 2 overlaps, then figure out where the\n      // set should be positioned analytically and try those too\n\n      for (var k = j + 1; k < overlap.length; ++k) {\n        var p2 = circles[overlap[k].set],\n            d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n        var extraPoints = circleCircleIntersection({\n          x: p1.x,\n          y: p1.y,\n          radius: d1\n        }, {\n          x: p2.x,\n          y: p2.y,\n          radius: d2\n        });\n\n        for (var l = 0; l < extraPoints.length; ++l) {\n          points.push(extraPoints[l]);\n        }\n      }\n    } // we have some candidate positions for the set, examine loss\n    // at each position to figure out where to put it at\n\n\n    var bestLoss = 1e50,\n        bestPoint = points[0];\n\n    for (var j = 0; j < points.length; ++j) {\n      circles[setIndex].x = points[j].x;\n      circles[setIndex].y = points[j].y;\n      var localLoss = loss(circles, areas);\n\n      if (localLoss < bestLoss) {\n        bestLoss = localLoss;\n        bestPoint = points[j];\n      }\n    }\n\n    positionSet(bestPoint, setIndex);\n  }\n\n  return circles;\n}\n/** Given a bunch of sets, and the desired overlaps between these sets - computes\nthe distance from the actual overlaps to the desired overlaps. Note that\nthis method ignores overlaps of more than 2 circles */\n\nexport function lossFunction(sets, overlaps) {\n  var output = 0;\n\n  function getCircles(indices) {\n    return indices.map(function (i) {\n      return sets[i];\n    });\n  }\n\n  for (var i = 0; i < overlaps.length; ++i) {\n    var area = overlaps[i];\n    var overlap = void 0;\n\n    if (area.sets.length == 1) {\n      continue;\n    } else if (area.sets.length == 2) {\n      var left = sets[area.sets[0]],\n          right = sets[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(getCircles(area.sets));\n    } // eslint-disable-next-line\n\n\n    var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n    output += weight * (overlap - area.size) * (overlap - area.size);\n  }\n\n  return output;\n} // orientates a bunch of circles to point in orientation\n\nfunction orientateCircles(circles, orientation, orientationOrder) {\n  if (orientationOrder === null) {\n    circles.sort(function (a, b) {\n      return b.radius - a.radius;\n    });\n  } else {\n    circles.sort(orientationOrder);\n  }\n\n  var i; // shift circles so largest circle is at (0, 0)\n\n  if (circles.length > 0) {\n    var largestX = circles[0].x,\n        largestY = circles[0].y;\n\n    for (i = 0; i < circles.length; ++i) {\n      circles[i].x -= largestX;\n      circles[i].y -= largestY;\n    }\n  }\n\n  if (circles.length == 2) {\n    // if the second circle is a subset of the first, arrange so that\n    // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n    var dist = distance(circles[0], circles[1]);\n\n    if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n      circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n      circles[1].y = circles[0].y;\n    }\n  } // rotate circles so that second largest is at an angle of 'orientation'\n  // from largest\n\n\n  if (circles.length > 1) {\n    var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;\n    var x = void 0,\n        y = void 0;\n    var c = Math.cos(rotation),\n        s = Math.sin(rotation);\n\n    for (i = 0; i < circles.length; ++i) {\n      x = circles[i].x;\n      y = circles[i].y;\n      circles[i].x = c * x - s * y;\n      circles[i].y = s * x + c * y;\n    }\n  } // mirror solution if third solution is above plane specified by\n  // first two circles\n\n\n  if (circles.length > 2) {\n    var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n\n    while (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n\n    while (angle > 2 * Math.PI) {\n      angle -= 2 * Math.PI;\n    }\n\n    if (angle > Math.PI) {\n      var slope = circles[1].y / (1e-10 + circles[1].x);\n\n      for (i = 0; i < circles.length; ++i) {\n        var d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);\n        circles[i].x = 2 * d - circles[i].x;\n        circles[i].y = 2 * d * slope - circles[i].y;\n      }\n    }\n  }\n}\n\nexport function disjointCluster(circles) {\n  // union-find clustering to get disjoint sets\n  circles.map(function (circle) {\n    circle.parent = circle;\n  }); // path compression step in union find\n\n  function find(circle) {\n    if (circle.parent !== circle) {\n      circle.parent = find(circle.parent);\n    }\n\n    return circle.parent;\n  }\n\n  function union(x, y) {\n    var xRoot = find(x),\n        yRoot = find(y);\n    xRoot.parent = yRoot;\n  } // get the union of all overlapping sets\n\n\n  for (var i = 0; i < circles.length; ++i) {\n    for (var j = i + 1; j < circles.length; ++j) {\n      var maxDistance = circles[i].radius + circles[j].radius;\n\n      if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n        union(circles[j], circles[i]);\n      }\n    }\n  } // find all the disjoint clusters and group them together\n\n\n  var disjointClusters = {};\n  var setid;\n\n  for (var i = 0; i < circles.length; ++i) {\n    setid = find(circles[i]).parent.setid;\n\n    if (!(setid in disjointClusters)) {\n      disjointClusters[setid] = [];\n    }\n\n    disjointClusters[setid].push(circles[i]);\n  } // cleanup bookkeeping\n\n\n  circles.map(function (circle) {\n    delete circle.parent;\n  }); // return in more usable form\n\n  var ret = [];\n\n  for (setid in disjointClusters) {\n    // eslint-disable-next-line\n    if (disjointClusters.hasOwnProperty(setid)) {\n      ret.push(disjointClusters[setid]);\n    }\n  }\n\n  return ret;\n}\n\nfunction getBoundingBox(circles) {\n  var minMax = function (d) {\n    var hi = Math.max.apply(null, circles.map(function (c) {\n      return c[d] + c.radius;\n    })),\n        lo = Math.min.apply(null, circles.map(function (c) {\n      return c[d] - c.radius;\n    }));\n    return {\n      max: hi,\n      min: lo\n    };\n  };\n\n  return {\n    xRange: minMax('x'),\n    yRange: minMax('y')\n  };\n}\n\nexport function normalizeSolution(solution, orientation, orientationOrder) {\n  if (orientation === null) {\n    orientation = Math.PI / 2;\n  } // work with a list instead of a dictionary, and take a copy so we\n  // don't mutate input\n\n\n  var circles = [],\n      i,\n      setid;\n\n  for (setid in solution) {\n    // eslint-disable-next-line\n    if (solution.hasOwnProperty(setid)) {\n      var previous = solution[setid];\n      circles.push({\n        x: previous.x,\n        y: previous.y,\n        radius: previous.radius,\n        setid: setid\n      });\n    }\n  } // get all the disjoint clusters\n\n\n  var clusters = disjointCluster(circles); // orientate all disjoint sets, get sizes\n\n  for (i = 0; i < clusters.length; ++i) {\n    orientateCircles(clusters[i], orientation, orientationOrder);\n    var bounds = getBoundingBox(clusters[i]);\n    clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n    clusters[i].bounds = bounds;\n  }\n\n  clusters.sort(function (a, b) {\n    return b.size - a.size;\n  }); // orientate the largest at 0,0, and get the bounds\n\n  circles = clusters[0]; // @ts-ignore fixme 从逻辑上看似乎是不对的，后续看看\n\n  var returnBounds = circles.bounds;\n  var spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\n\n  function addCluster(cluster, right, bottom) {\n    if (!cluster) return;\n    var bounds = cluster.bounds;\n    var xOffset, yOffset, centreing;\n\n    if (right) {\n      xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\n    } else {\n      xOffset = returnBounds.xRange.max - bounds.xRange.max;\n      centreing = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n      if (centreing < 0) xOffset += centreing;\n    }\n\n    if (bottom) {\n      yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\n    } else {\n      yOffset = returnBounds.yRange.max - bounds.yRange.max;\n      centreing = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n      if (centreing < 0) yOffset += centreing;\n    }\n\n    for (var j = 0; j < cluster.length; ++j) {\n      cluster[j].x += xOffset;\n      cluster[j].y += yOffset;\n      circles.push(cluster[j]);\n    }\n  }\n\n  var index = 1;\n\n  while (index < clusters.length) {\n    addCluster(clusters[index], true, false);\n    addCluster(clusters[index + 1], false, true);\n    addCluster(clusters[index + 2], true, true);\n    index += 3; // have one cluster (in top left). lay out next three relative\n    // to it in a grid\n\n    returnBounds = getBoundingBox(circles);\n  } // convert back to solution form\n\n\n  var ret = {};\n\n  for (i = 0; i < circles.length; ++i) {\n    ret[circles[i].setid] = circles[i];\n  }\n\n  return ret;\n}\n/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\na rectangle of width/height - with padding around the borders. also\ncenters the diagram in the available space at the same time */\n\nexport function scaleSolution(solution, width, height, padding) {\n  var circles = [],\n      setids = [];\n\n  for (var setid in solution) {\n    // eslint-disable-next-line\n    if (solution.hasOwnProperty(setid)) {\n      setids.push(setid);\n      circles.push(solution[setid]);\n    }\n  }\n\n  width -= 2 * padding;\n  height -= 2 * padding;\n  var bounds = getBoundingBox(circles),\n      xRange = bounds.xRange,\n      yRange = bounds.yRange;\n\n  if (xRange.max == xRange.min || yRange.max == yRange.min) {\n    console.log('not scaling solution: zero size detected');\n    return solution;\n  }\n\n  var xScaling = width / (xRange.max - xRange.min),\n      yScaling = height / (yRange.max - yRange.min),\n      scaling = Math.min(yScaling, xScaling),\n      // while we're at it, center the diagram too\n  xOffset = (width - (xRange.max - xRange.min) * scaling) / 2,\n      yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n  var scaled = {};\n\n  for (var i = 0; i < circles.length; ++i) {\n    var circle = circles[i];\n    scaled[setids[i]] = {\n      radius: scaling * circle.radius,\n      x: padding + xOffset + (circle.x - xRange.min) * scaling,\n      y: padding + yOffset + (circle.y - yRange.min) * scaling\n    };\n  }\n\n  return scaled;\n}","map":{"version":3,"mappings":"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","names":["nelderMead","bisect","conjugateGradient","zeros","zerosM","norm2","scale","intersectionArea","circleOverlap","circleCircleIntersection","distance","venn","areas","parameters","maxIterations","initialLayout","bestInitialLayout","loss","lossFunction","addMissingAreas","circles","initial","setids","setid","hasOwnProperty","push","x","y","solution","values","current","i","length","setid_1","radius","positions","SMALL","distanceFromIntersectArea","r1","r2","overlap","Math","min","PI","abs","slice","ids","pairs","j","a","b","area","sets","sort","size","getDistanceMatrices","distances","constraints","filter","map","left","right","sqrt","c","constrainedMDSGradient","fxprime","xi","yi","xj","yj","dij","constraint","squaredDistance","distance_1","delta","params","greedyLayout","constrained","constrainedMDSLayout","constrainedLoss","greedyLoss","restarts","matrices","norm","row","value","obj","best","random","fx","set","history","setOverlaps","rowid","Object","keys","weight","mostOverlapped","sortOrder","positioned","isPositioned","element","positionSet","point","index","setIndex","points","p1","d1","k","p2","d2","extraPoints","l","bestLoss","bestPoint","localLoss","overlaps","output","getCircles","indices","orientateCircles","orientation","orientationOrder","largestX","largestY","dist","rotation","atan2","cos","s","sin","angle","slope","d","disjointCluster","circle","parent","find","union","xRoot","yRoot","maxDistance","disjointClusters","ret","getBoundingBox","minMax","hi","max","apply","lo","xRange","yRange","normalizeSolution","previous","clusters","bounds","returnBounds","spacing","addCluster","cluster","bottom","xOffset","yOffset","centreing","scaleSolution","width","height","padding","console","log","xScaling","yScaling","scaling","scaled"],"sourceRoot":"","sources":["../../../../src/plots/venn/layout/layout.ts"],"sourcesContent":["import { nelderMead, bisect, conjugateGradient, zeros, zerosM, norm2, scale } from 'fmin';\nimport { intersectionArea, circleOverlap, circleCircleIntersection, distance } from './circleintersection';\n\n/** given a list of set objects, and their corresponding overlaps.\nupdates the (x, y, radius) attribute on each set such that their positions\nroughly correspond to the desired overlaps */\nexport function venn(areas, parameters?: any) {\n  parameters = parameters || {};\n  parameters.maxIterations = parameters.maxIterations || 500;\n  const initialLayout = parameters.initialLayout || bestInitialLayout;\n  const loss = parameters.lossFunction || lossFunction;\n\n  // add in missing pairwise areas as having 0 size\n  areas = addMissingAreas(areas);\n\n  // initial layout is done greedily\n  const circles = initialLayout(areas, parameters);\n\n  // transform x/y coordinates to a vector to optimize\n  const initial = [],\n    setids = [];\n  let setid;\n  for (setid in circles) {\n    // eslint-disable-next-line\n    if (circles.hasOwnProperty(setid)) {\n      initial.push(circles[setid].x);\n      initial.push(circles[setid].y);\n      setids.push(setid);\n    }\n  }\n\n  // optimize initial layout from our loss function\n  const solution = nelderMead(\n    function (values) {\n      const current = {};\n      for (let i = 0; i < setids.length; ++i) {\n        const setid = setids[i];\n        current[setid] = {\n          x: values[2 * i],\n          y: values[2 * i + 1],\n          radius: circles[setid].radius,\n          // size : circles[setid].size\n        };\n      }\n      return loss(current, areas);\n    },\n    initial,\n    parameters\n  );\n\n  // transform solution vector back to x/y points\n  const positions = solution.x;\n  for (let i = 0; i < setids.length; ++i) {\n    setid = setids[i];\n    circles[setid].x = positions[2 * i];\n    circles[setid].y = positions[2 * i + 1];\n  }\n\n  return circles;\n}\n\nconst SMALL = 1e-10;\n\n/** Returns the distance necessary for two circles of radius r1 + r2 to\nhave the overlap area 'overlap' */\nexport function distanceFromIntersectArea(r1, r2, overlap) {\n  // handle complete overlapped circles\n  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL) {\n    return Math.abs(r1 - r2);\n  }\n\n  return bisect(\n    function (distance) {\n      return circleOverlap(r1, r2, distance) - overlap;\n    },\n    0,\n    r1 + r2\n  );\n}\n\n/** Missing pair-wise intersection area data can cause problems:\n treating as an unknown means that sets will be laid out overlapping,\n which isn't what people expect. To reflect that we want disjoint sets\n here, set the overlap to 0 for all missing pairwise set intersections */\nfunction addMissingAreas(areas) {\n  areas = areas.slice();\n\n  // two circle intersections that aren't defined\n  const ids: number[] = [],\n    pairs: any = {};\n  let i, j, a, b;\n  for (i = 0; i < areas.length; ++i) {\n    const area = areas[i];\n    if (area.sets.length == 1) {\n      ids.push(area.sets[0]);\n    } else if (area.sets.length == 2) {\n      a = area.sets[0];\n      b = area.sets[1];\n      // @ts-ignore\n      pairs[[a, b]] = true;\n      // @ts-ignore\n      pairs[[b, a]] = true;\n    }\n  }\n  ids.sort((a, b) => {\n    return a > b ? 1 : -1;\n  });\n\n  for (i = 0; i < ids.length; ++i) {\n    a = ids[i];\n    for (j = i + 1; j < ids.length; ++j) {\n      b = ids[j];\n      // @ts-ignore\n      if (!([a, b] in pairs)) {\n        areas.push({ sets: [a, b], size: 0 });\n      }\n    }\n  }\n  return areas;\n}\n\n/// Returns two matrices, one of the euclidean distances between the sets\n/// and the other indicating if there are subset or disjoint set relationships\nexport function getDistanceMatrices(areas, sets, setids) {\n  // initialize an empty distance matrix between all the points\n  const distances = zerosM(sets.length, sets.length),\n    constraints = zerosM(sets.length, sets.length);\n\n  // compute required distances between all the sets such that\n  // the areas match\n  areas\n    .filter(function (x) {\n      return x.sets.length == 2;\n    })\n    .map(function (current) {\n      const left = setids[current.sets[0]],\n        right = setids[current.sets[1]],\n        r1 = Math.sqrt(sets[left].size / Math.PI),\n        r2 = Math.sqrt(sets[right].size / Math.PI),\n        distance = distanceFromIntersectArea(r1, r2, current.size);\n\n      distances[left][right] = distances[right][left] = distance;\n\n      // also update constraints to indicate if its a subset or disjoint\n      // relationship\n      let c = 0;\n      if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n        c = 1;\n      } else if (current.size <= 1e-10) {\n        c = -1;\n      }\n      constraints[left][right] = constraints[right][left] = c;\n    });\n\n  return { distances: distances, constraints: constraints };\n}\n\n/// computes the gradient and loss simulatenously for our constrained MDS optimizer\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n  let loss = 0,\n    i;\n  for (i = 0; i < fxprime.length; ++i) {\n    fxprime[i] = 0;\n  }\n\n  for (i = 0; i < distances.length; ++i) {\n    const xi = x[2 * i],\n      yi = x[2 * i + 1];\n    for (let j = i + 1; j < distances.length; ++j) {\n      const xj = x[2 * j],\n        yj = x[2 * j + 1],\n        dij = distances[i][j],\n        constraint = constraints[i][j];\n\n      const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n        distance = Math.sqrt(squaredDistance),\n        delta = squaredDistance - dij * dij;\n\n      if ((constraint > 0 && distance <= dij) || (constraint < 0 && distance >= dij)) {\n        continue;\n      }\n\n      loss += 2 * delta * delta;\n\n      fxprime[2 * i] += 4 * delta * (xi - xj);\n      fxprime[2 * i + 1] += 4 * delta * (yi - yj);\n\n      fxprime[2 * j] += 4 * delta * (xj - xi);\n      fxprime[2 * j + 1] += 4 * delta * (yj - yi);\n    }\n  }\n  return loss;\n}\n\n/// takes the best working variant of either constrained MDS or greedy\nexport function bestInitialLayout(areas, params) {\n  let initial = greedyLayout(areas, params);\n  const loss = params.lossFunction || lossFunction;\n\n  // greedylayout is sufficient for all 2/3 circle cases. try out\n  // constrained MDS for higher order problems, take its output\n  // if it outperforms. (greedy is aesthetically better on 2/3 circles\n  // since it axis aligns)\n  if (areas.length >= 8) {\n    const constrained = constrainedMDSLayout(areas, params),\n      constrainedLoss = loss(constrained, areas),\n      greedyLoss = loss(initial, areas);\n\n    if (constrainedLoss + 1e-8 < greedyLoss) {\n      initial = constrained;\n    }\n  }\n  return initial;\n}\n\n/// use the constrained MDS variant to generate an initial layout\nexport function constrainedMDSLayout(areas, params) {\n  params = params || {};\n  const restarts = params.restarts || 10;\n\n  // bidirectionally map sets to a rowid  (so we can create a matrix)\n  const sets = [],\n    setids = {};\n  let i;\n  for (i = 0; i < areas.length; ++i) {\n    const area = areas[i];\n    if (area.sets.length == 1) {\n      setids[area.sets[0]] = sets.length;\n      sets.push(area);\n    }\n  }\n\n  const matrices = getDistanceMatrices(areas, sets, setids);\n  let distances = matrices.distances;\n  const constraints = matrices.constraints;\n\n  // keep distances bounded, things get messed up otherwise.\n  // TODO: proper preconditioner?\n  const norm = norm2(distances.map(norm2)) / distances.length;\n  distances = distances.map(function (row) {\n    return row.map(function (value) {\n      return value / norm;\n    });\n  });\n\n  const obj = function (x, fxprime) {\n    return constrainedMDSGradient(x, fxprime, distances, constraints);\n  };\n\n  let best, current;\n  for (i = 0; i < restarts; ++i) {\n    const initial = zeros(distances.length * 2).map(Math.random);\n\n    current = conjugateGradient(obj, initial, params);\n    if (!best || current.fx < best.fx) {\n      best = current;\n    }\n  }\n  const positions = best.x;\n\n  // translate rows back to (x,y,radius) coordinates\n  const circles = {};\n  for (i = 0; i < sets.length; ++i) {\n    const set = sets[i];\n    circles[set.sets[0]] = {\n      x: positions[2 * i] * norm,\n      y: positions[2 * i + 1] * norm,\n      radius: Math.sqrt(set.size / Math.PI),\n    };\n  }\n\n  if (params.history) {\n    for (i = 0; i < params.history.length; ++i) {\n      scale(params.history[i].x, norm);\n    }\n  }\n  return circles;\n}\n\n/** Lays out a Venn diagram greedily, going from most overlapped sets to\nleast overlapped, attempting to position each new set such that the\noverlapping areas to already positioned sets are basically right */\nexport function greedyLayout(areas, params) {\n  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n  // define a circle for each set\n  const circles = {},\n    setOverlaps = {};\n  let set;\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i];\n    if (area.sets.length == 1) {\n      set = area.sets[0];\n      circles[set] = {\n        x: 1e10,\n        y: 1e10,\n        // rowid: circles.length, // fix to ->\n        rowid: Object.keys(circles).length,\n        size: area.size,\n        radius: Math.sqrt(area.size / Math.PI),\n      };\n      setOverlaps[set] = [];\n    }\n  }\n  areas = areas.filter(function (a) {\n    return a.sets.length == 2;\n  });\n\n  // map each set to a list of all the other sets that overlap it\n  for (let i = 0; i < areas.length; ++i) {\n    const current = areas[i];\n    // eslint-disable-next-line\n    let weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n    const left = current.sets[0],\n      right = current.sets[1];\n\n    // completely overlapped circles shouldn't be positioned early here\n    if (current.size + SMALL >= Math.min(circles[left].size, circles[right].size)) {\n      weight = 0;\n    }\n\n    setOverlaps[left].push({ set: right, size: current.size, weight: weight });\n    setOverlaps[right].push({ set: left, size: current.size, weight: weight });\n  }\n\n  // get list of most overlapped sets\n  const mostOverlapped = [];\n  for (set in setOverlaps) {\n    // eslint-disable-next-line\n    if (setOverlaps.hasOwnProperty(set)) {\n      let size = 0;\n      for (let i = 0; i < setOverlaps[set].length; ++i) {\n        size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n      }\n\n      mostOverlapped.push({ set: set, size: size });\n    }\n  }\n\n  // sort by size desc\n  function sortOrder(a, b) {\n    return b.size - a.size;\n  }\n  mostOverlapped.sort(sortOrder);\n\n  // keep track of what sets have been laid out\n  const positioned = {};\n  function isPositioned(element) {\n    return element.set in positioned;\n  }\n\n  // adds a point to the output\n  function positionSet(point, index) {\n    circles[index].x = point.x;\n    circles[index].y = point.y;\n    positioned[index] = true;\n  }\n\n  // add most overlapped set at (0,0)\n  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);\n\n  // get distances between all points. TODO, necessary?\n  // answer: probably not\n  // var distances = venn.getDistanceMatrices(circles, areas).distances;\n  for (let i = 1; i < mostOverlapped.length; ++i) {\n    const setIndex = mostOverlapped[i].set,\n      overlap = setOverlaps[setIndex].filter(isPositioned);\n    set = circles[setIndex];\n    overlap.sort(sortOrder);\n\n    if (overlap.length === 0) {\n      // this shouldn't happen anymore with addMissingAreas\n      throw 'ERROR: missing pairwise overlap information';\n    }\n\n    const points = [];\n    for (let j = 0; j < overlap.length; ++j) {\n      // get appropriate distance from most overlapped already added set\n      const p1 = circles[overlap[j].set],\n        d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);\n\n      // sample positions at 90 degrees for maximum aesthetics\n      points.push({ x: p1.x + d1, y: p1.y });\n      points.push({ x: p1.x - d1, y: p1.y });\n      points.push({ y: p1.y + d1, x: p1.x });\n      points.push({ y: p1.y - d1, x: p1.x });\n\n      // if we have at least 2 overlaps, then figure out where the\n      // set should be positioned analytically and try those too\n      for (let k = j + 1; k < overlap.length; ++k) {\n        const p2 = circles[overlap[k].set],\n          d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n\n        const extraPoints = circleCircleIntersection(\n          { x: p1.x, y: p1.y, radius: d1 },\n          { x: p2.x, y: p2.y, radius: d2 }\n        );\n\n        for (let l = 0; l < extraPoints.length; ++l) {\n          points.push(extraPoints[l]);\n        }\n      }\n    }\n\n    // we have some candidate positions for the set, examine loss\n    // at each position to figure out where to put it at\n    let bestLoss = 1e50,\n      bestPoint = points[0];\n    for (let j = 0; j < points.length; ++j) {\n      circles[setIndex].x = points[j].x;\n      circles[setIndex].y = points[j].y;\n      const localLoss = loss(circles, areas);\n      if (localLoss < bestLoss) {\n        bestLoss = localLoss;\n        bestPoint = points[j];\n      }\n    }\n\n    positionSet(bestPoint, setIndex);\n  }\n\n  return circles;\n}\n\n/** Given a bunch of sets, and the desired overlaps between these sets - computes\nthe distance from the actual overlaps to the desired overlaps. Note that\nthis method ignores overlaps of more than 2 circles */\nexport function lossFunction(sets, overlaps) {\n  let output = 0;\n\n  function getCircles(indices) {\n    return indices.map(function (i) {\n      return sets[i];\n    });\n  }\n\n  for (let i = 0; i < overlaps.length; ++i) {\n    const area = overlaps[i];\n    let overlap;\n    if (area.sets.length == 1) {\n      continue;\n    } else if (area.sets.length == 2) {\n      const left = sets[area.sets[0]],\n        right = sets[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(getCircles(area.sets));\n    }\n\n    // eslint-disable-next-line\n    const weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n    output += weight * (overlap - area.size) * (overlap - area.size);\n  }\n\n  return output;\n}\n\n// orientates a bunch of circles to point in orientation\nfunction orientateCircles(circles, orientation, orientationOrder) {\n  if (orientationOrder === null) {\n    circles.sort(function (a, b) {\n      return b.radius - a.radius;\n    });\n  } else {\n    circles.sort(orientationOrder);\n  }\n\n  let i;\n  // shift circles so largest circle is at (0, 0)\n  if (circles.length > 0) {\n    const largestX = circles[0].x,\n      largestY = circles[0].y;\n\n    for (i = 0; i < circles.length; ++i) {\n      circles[i].x -= largestX;\n      circles[i].y -= largestY;\n    }\n  }\n\n  if (circles.length == 2) {\n    // if the second circle is a subset of the first, arrange so that\n    // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n    const dist = distance(circles[0], circles[1]);\n    if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n      circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n      circles[1].y = circles[0].y;\n    }\n  }\n\n  // rotate circles so that second largest is at an angle of 'orientation'\n  // from largest\n  if (circles.length > 1) {\n    const rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;\n    let x, y;\n    const c = Math.cos(rotation),\n      s = Math.sin(rotation);\n    for (i = 0; i < circles.length; ++i) {\n      x = circles[i].x;\n      y = circles[i].y;\n      circles[i].x = c * x - s * y;\n      circles[i].y = s * x + c * y;\n    }\n  }\n\n  // mirror solution if third solution is above plane specified by\n  // first two circles\n  if (circles.length > 2) {\n    let angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n    while (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n    while (angle > 2 * Math.PI) {\n      angle -= 2 * Math.PI;\n    }\n    if (angle > Math.PI) {\n      const slope = circles[1].y / (1e-10 + circles[1].x);\n      for (i = 0; i < circles.length; ++i) {\n        const d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);\n        circles[i].x = 2 * d - circles[i].x;\n        circles[i].y = 2 * d * slope - circles[i].y;\n      }\n    }\n  }\n}\n\nexport function disjointCluster(circles) {\n  // union-find clustering to get disjoint sets\n  circles.map(function (circle) {\n    circle.parent = circle;\n  });\n\n  // path compression step in union find\n  function find(circle) {\n    if (circle.parent !== circle) {\n      circle.parent = find(circle.parent);\n    }\n    return circle.parent;\n  }\n\n  function union(x, y) {\n    const xRoot = find(x),\n      yRoot = find(y);\n    xRoot.parent = yRoot;\n  }\n\n  // get the union of all overlapping sets\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const maxDistance = circles[i].radius + circles[j].radius;\n      if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n        union(circles[j], circles[i]);\n      }\n    }\n  }\n\n  // find all the disjoint clusters and group them together\n  const disjointClusters = {};\n  let setid;\n  for (let i = 0; i < circles.length; ++i) {\n    setid = find(circles[i]).parent.setid;\n    if (!(setid in disjointClusters)) {\n      disjointClusters[setid] = [];\n    }\n    disjointClusters[setid].push(circles[i]);\n  }\n\n  // cleanup bookkeeping\n  circles.map(function (circle) {\n    delete circle.parent;\n  });\n\n  // return in more usable form\n  const ret = [];\n  for (setid in disjointClusters) {\n    // eslint-disable-next-line\n    if (disjointClusters.hasOwnProperty(setid)) {\n      ret.push(disjointClusters[setid]);\n    }\n  }\n  return ret;\n}\n\nfunction getBoundingBox(circles) {\n  const minMax = function (d) {\n    const hi = Math.max.apply(\n        null,\n        circles.map(function (c) {\n          return c[d] + c.radius;\n        })\n      ),\n      lo = Math.min.apply(\n        null,\n        circles.map(function (c) {\n          return c[d] - c.radius;\n        })\n      );\n    return { max: hi, min: lo };\n  };\n\n  return { xRange: minMax('x'), yRange: minMax('y') };\n}\n\nexport function normalizeSolution(solution, orientation, orientationOrder) {\n  if (orientation === null) {\n    orientation = Math.PI / 2;\n  }\n\n  // work with a list instead of a dictionary, and take a copy so we\n  // don't mutate input\n  let circles = [],\n    i,\n    setid;\n  for (setid in solution) {\n    // eslint-disable-next-line\n    if (solution.hasOwnProperty(setid)) {\n      const previous = solution[setid];\n      circles.push({ x: previous.x, y: previous.y, radius: previous.radius, setid: setid });\n    }\n  }\n\n  // get all the disjoint clusters\n  const clusters = disjointCluster(circles);\n\n  // orientate all disjoint sets, get sizes\n  for (i = 0; i < clusters.length; ++i) {\n    orientateCircles(clusters[i], orientation, orientationOrder);\n    const bounds = getBoundingBox(clusters[i]);\n    clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n    clusters[i].bounds = bounds;\n  }\n  clusters.sort(function (a, b) {\n    return b.size - a.size;\n  });\n\n  // orientate the largest at 0,0, and get the bounds\n  circles = clusters[0];\n  // @ts-ignore fixme 从逻辑上看似乎是不对的，后续看看\n  let returnBounds = circles.bounds;\n\n  const spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\n\n  function addCluster(cluster, right, bottom) {\n    if (!cluster) return;\n\n    const bounds = cluster.bounds;\n    let xOffset, yOffset, centreing;\n\n    if (right) {\n      xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\n    } else {\n      xOffset = returnBounds.xRange.max - bounds.xRange.max;\n      centreing = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n      if (centreing < 0) xOffset += centreing;\n    }\n\n    if (bottom) {\n      yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\n    } else {\n      yOffset = returnBounds.yRange.max - bounds.yRange.max;\n      centreing = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n      if (centreing < 0) yOffset += centreing;\n    }\n\n    for (let j = 0; j < cluster.length; ++j) {\n      cluster[j].x += xOffset;\n      cluster[j].y += yOffset;\n      circles.push(cluster[j]);\n    }\n  }\n\n  let index = 1;\n  while (index < clusters.length) {\n    addCluster(clusters[index], true, false);\n    addCluster(clusters[index + 1], false, true);\n    addCluster(clusters[index + 2], true, true);\n    index += 3;\n\n    // have one cluster (in top left). lay out next three relative\n    // to it in a grid\n    returnBounds = getBoundingBox(circles);\n  }\n\n  // convert back to solution form\n  const ret = {};\n  for (i = 0; i < circles.length; ++i) {\n    ret[circles[i].setid] = circles[i];\n  }\n  return ret;\n}\n\n/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\na rectangle of width/height - with padding around the borders. also\ncenters the diagram in the available space at the same time */\nexport function scaleSolution(solution, width, height, padding) {\n  const circles = [],\n    setids = [];\n  for (const setid in solution) {\n    // eslint-disable-next-line\n    if (solution.hasOwnProperty(setid)) {\n      setids.push(setid);\n      circles.push(solution[setid]);\n    }\n  }\n\n  width -= 2 * padding;\n  height -= 2 * padding;\n\n  const bounds = getBoundingBox(circles),\n    xRange = bounds.xRange,\n    yRange = bounds.yRange;\n\n  if (xRange.max == xRange.min || yRange.max == yRange.min) {\n    console.log('not scaling solution: zero size detected');\n    return solution;\n  }\n\n  const xScaling = width / (xRange.max - xRange.min),\n    yScaling = height / (yRange.max - yRange.min),\n    scaling = Math.min(yScaling, xScaling),\n    // while we're at it, center the diagram too\n    xOffset = (width - (xRange.max - xRange.min) * scaling) / 2,\n    yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\n  const scaled = {};\n  for (let i = 0; i < circles.length; ++i) {\n    const circle = circles[i];\n    scaled[setids[i]] = {\n      radius: scaling * circle.radius,\n      x: padding + xOffset + (circle.x - xRange.min) * scaling,\n      y: padding + yOffset + (circle.y - yRange.min) * scaling,\n    };\n  }\n\n  return scaled;\n}\n"]},"metadata":{},"sourceType":"module"}