{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { __read, __spreadArray } from \"tslib\";\nimport { each } from '@antv/util';\nimport { COMPONENT_TYPE } from '../../constant';\nimport { BBox } from '../../util/bbox';\nimport { isAutoPadding, parsePadding } from '../../util/padding';\nimport { PaddingCal } from './padding-cal';\n/**\n * @ignore\n * 根据 view 中的组件，计算实际的 padding 数值\n * @param view\n */\n\nexport function calculatePadding(view) {\n  var padding = view.padding; // 如果不是 auto padding，那么直接解析之后返回\n\n  if (!isAutoPadding(padding)) {\n    return new (PaddingCal.bind.apply(PaddingCal, __spreadArray([void 0], __read(parsePadding(padding)), false)))();\n  } // 是 auto padding，根据组件的情况，来计算 padding\n\n\n  var viewBBox = view.viewBBox;\n  var paddingCal = new PaddingCal();\n  var axisComponents = [];\n  var paddingComponents = [];\n  var otherComponents = [];\n  each(view.getComponents(), function (co) {\n    var type = co.type;\n\n    if (type === COMPONENT_TYPE.AXIS) {\n      axisComponents.push(co);\n    } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {\n      paddingComponents.push(co);\n    } else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {\n      otherComponents.push(co);\n    }\n  }); // 进行坐标轴布局，应该是取 padding 的并集，而不是进行相加\n\n  each(axisComponents, function (co) {\n    var component = co.component;\n    var bboxObject = component.getLayoutBBox();\n    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n    var exceed = componentBBox.exceed(viewBBox); // 在对组件分组之后，先对 axis 进行处理，然后取最大的超出即可。\n\n    paddingCal.max(exceed);\n  }); // 有 padding 的组件布局\n\n  each(paddingComponents, function (co) {\n    var component = co.component,\n        direction = co.direction;\n    var bboxObject = component.getLayoutBBox();\n    var componentPadding = component.get('padding');\n    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding); // 按照方向计算 padding\n\n    paddingCal.inc(componentBBox, direction);\n  }); // 其他组件布局\n\n  each(otherComponents, function (co) {\n    var component = co.component,\n        direction = co.direction;\n    var bboxObject = component.getLayoutBBox();\n    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height); // 按照方向计算 padding\n\n    paddingCal.inc(componentBBox, direction);\n  });\n  return paddingCal;\n}","map":{"version":3,"mappings":"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","names":["each","COMPONENT_TYPE","BBox","isAutoPadding","parsePadding","PaddingCal","calculatePadding","view","padding","apply","__spreadArray","paddingCal","axisComponents","paddingComponents","otherComponents","getComponents","co","type","AXIS","push","LEGEND","SLIDER","SCROLLBAR","includes","GRID","TOOLTIP","bboxObject","component","getLayoutBBox","componentBBox","x","y","width","height","exceed","viewBBox","max","direction","componentPadding","get","expand","inc"],"sourceRoot":"","sources":["../../../src/chart/layout/auto.ts"],"sourcesContent":["import { each } from '@antv/util';\nimport { COMPONENT_TYPE } from '../../constant';\nimport { ComponentOption, Padding } from '../../interface';\nimport { BBox } from '../../util/bbox';\nimport { isAutoPadding, parsePadding } from '../../util/padding';\nimport View from '../view';\nimport { PaddingCal } from './padding-cal';\n\n/**\n * @ignore\n * 根据 view 中的组件，计算实际的 padding 数值\n * @param view\n */\nexport function calculatePadding(view: View): PaddingCal {\n  const padding = view.padding;\n\n  // 如果不是 auto padding，那么直接解析之后返回\n  if (!isAutoPadding(padding)) {\n    return new PaddingCal(...parsePadding(padding));\n  }\n\n  // 是 auto padding，根据组件的情况，来计算 padding\n  const { viewBBox } = view;\n\n  const paddingCal = new PaddingCal();\n\n  const axisComponents = [];\n  const paddingComponents = [];\n  const otherComponents = [];\n\n  each(view.getComponents(), (co: ComponentOption) => {\n    const { type } = co;\n    if (type === COMPONENT_TYPE.AXIS) {\n      axisComponents.push(co);\n    } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {\n      paddingComponents.push(co);\n    } else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {\n      otherComponents.push(co);\n    }\n  });\n\n  // 进行坐标轴布局，应该是取 padding 的并集，而不是进行相加\n  each(axisComponents, (co: ComponentOption) => {\n    const { component } = co;\n    const bboxObject = component.getLayoutBBox();\n    const componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n\n    const exceed = componentBBox.exceed(viewBBox);\n\n    // 在对组件分组之后，先对 axis 进行处理，然后取最大的超出即可。\n    paddingCal.max(exceed);\n  });\n\n  // 有 padding 的组件布局\n  each(paddingComponents, (co: ComponentOption) => {\n    const { component, direction } = co;\n    const bboxObject = component.getLayoutBBox();\n    const componentPadding: Padding = component.get('padding');\n    const componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(\n      componentPadding\n    );\n    // 按照方向计算 padding\n    paddingCal.inc(componentBBox, direction);\n  });\n\n  // 其他组件布局\n  each(otherComponents, (co: ComponentOption) => {\n    const { component, direction } = co;\n    const bboxObject = component.getLayoutBBox();\n    const componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n    // 按照方向计算 padding\n    paddingCal.inc(componentBBox, direction);\n  });\n\n  return paddingCal;\n}\n"]},"metadata":{},"sourceType":"module"}