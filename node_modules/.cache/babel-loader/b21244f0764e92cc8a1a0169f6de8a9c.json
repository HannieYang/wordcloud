{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { isArray, isNil, get } from '@antv/util';\nimport { getAngle, getSectorPath } from '../../../util/graphics';\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @param [isPyramid] 是否为尖底漏斗图\n * @returns rect points 返回矩形四个顶点信息\n */\n\nexport function getRectPoints(pointInfo) {\n  var _a, _b;\n\n  var x = pointInfo.x,\n      y = pointInfo.y,\n      y0 = pointInfo.y0,\n      size = pointInfo.size; // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n\n  var yMin;\n  var yMax;\n\n  if (isArray(y)) {\n    _a = __read(y, 2), yMin = _a[0], yMax = _a[1];\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  var xMin;\n  var xMax;\n\n  if (isArray(x)) {\n    _b = __read(x, 2), xMin = _b[0], xMax = _b[1];\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n\n  var points = [{\n    x: xMin,\n    y: yMin\n  }, {\n    x: xMin,\n    y: yMax\n  }]; // 矩形的四个关键点，结构如下（左下角顺时针连接）\n  // 1 ---- 2\n  // |      |\n  // 0 ---- 3\n\n  points.push({\n    x: xMax,\n    y: yMax\n  }, {\n    x: xMax,\n    y: yMin\n  });\n  return points;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\n\nexport function getRectPath(points, isClosed) {\n  if (isClosed === void 0) {\n    isClosed = true;\n  }\n\n  var path = [];\n  var firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  } // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n\n\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n\n    path.push(['z']);\n  }\n\n  return path;\n}\n/**\n * 处理 rect path 的 radius\n * @returns 返回矩形 path 的四个角的 arc 半径\n */\n\nexport function parseRadius(radius, minLength) {\n  var r1 = 0;\n  var r2 = 0;\n  var r3 = 0;\n  var r4 = 0;\n\n  if (isArray(radius)) {\n    if (radius.length === 1) {\n      r1 = r2 = r3 = r4 = radius[0];\n    } else if (radius.length === 2) {\n      r1 = r3 = radius[0];\n      r2 = r4 = radius[1];\n    } else if (radius.length === 3) {\n      r1 = radius[0];\n      r2 = r4 = radius[1];\n      r3 = radius[2];\n    } else {\n      r1 = radius[0];\n      r2 = radius[1];\n      r3 = radius[2];\n      r4 = radius[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = radius;\n  } // 处理 边界值\n\n\n  if (r1 + r2 > minLength) {\n    r1 = r1 ? minLength / (1 + r2 / r1) : 0;\n    r2 = minLength - r1;\n  }\n\n  if (r3 + r4 > minLength) {\n    r3 = r3 ? minLength / (1 + r4 / r3) : 0;\n    r4 = minLength - r3;\n  }\n\n  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];\n}\n/**\n * 获取 interval 矩形背景的 path\n * @param cfg 关键点的信息\n * @param points 已转化为画布坐标的 4 个关键点\n * @param coordinate 坐标系\n * @returns 返回矩形背景的 path\n */\n\nexport function getBackgroundRectPath(cfg, points, coordinate) {\n  var path = [];\n\n  if (coordinate.isRect) {\n    var p0 = coordinate.isTransposed ? {\n      x: coordinate.start.x,\n      y: points[0].y\n    } : {\n      x: points[0].x,\n      y: coordinate.start.y\n    };\n    var p1 = coordinate.isTransposed ? {\n      x: coordinate.end.x,\n      y: points[2].y\n    } : {\n      x: points[3].x,\n      y: coordinate.end.y\n    }; // corner radius of background shape works only in 笛卡尔坐标系\n\n    var radius = get(cfg, ['background', 'style', 'radius']);\n\n    if (radius) {\n      var width = coordinate.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;\n      var height = coordinate.isTransposed ? coordinate.getWidth() : coordinate.getHeight();\n\n      var _a = __read(parseRadius(radius, Math.min(width, height)), 4),\n          r1 = _a[0],\n          r2 = _a[1],\n          r3 = _a[2],\n          r4 = _a[3]; // 同时存在 坐标系是否发生转置 和 y 镜像的时候\n\n\n      var isReflectYTransposed_1 = coordinate.isTransposed && coordinate.isReflect('y');\n      var bump = isReflectYTransposed_1 ? 0 : 1;\n\n      var opposite = function (r) {\n        return isReflectYTransposed_1 ? -r : r;\n      };\n\n      path.push(['M', p0.x, p1.y + opposite(r1)]);\n      r1 !== 0 && path.push(['A', r1, r1, 0, 0, bump, p0.x + r1, p1.y]);\n      path.push(['L', p1.x - r2, p1.y]);\n      r2 !== 0 && path.push(['A', r2, r2, 0, 0, bump, p1.x, p1.y + opposite(r2)]);\n      path.push(['L', p1.x, p0.y - opposite(r3)]);\n      r3 !== 0 && path.push(['A', r3, r3, 0, 0, bump, p1.x - r3, p0.y]);\n      path.push(['L', p0.x + r4, p0.y]);\n      r4 !== 0 && path.push(['A', r4, r4, 0, 0, bump, p0.x, p0.y - opposite(r4)]);\n    } else {\n      path.push(['M', p0.x, p0.y]);\n      path.push(['L', p1.x, p0.y]);\n      path.push(['L', p1.x, p1.y]);\n      path.push(['L', p0.x, p1.y]);\n      path.push(['L', p0.x, p0.y]);\n    }\n\n    path.push(['z']);\n  }\n\n  if (coordinate.isPolar) {\n    var center = coordinate.getCenter();\n\n    var _b = getAngle(cfg, coordinate),\n        startAngle = _b.startAngle,\n        endAngle = _b.endAngle;\n\n    if (coordinate.type !== 'theta' && !coordinate.isTransposed) {\n      // 获取扇形 path\n      path = getSectorPath(center.x, center.y, coordinate.getRadius(), startAngle, endAngle);\n    } else {\n      var pow = function (v) {\n        return Math.pow(v, 2);\n      };\n\n      var r1 = Math.sqrt(pow(center.x - points[0].x) + pow(center.y - points[0].y));\n      var r2 = Math.sqrt(pow(center.x - points[2].x) + pow(center.y - points[2].y)); // 获取扇形 path（其实是一个圆环，从 coordinate 的起始角度到结束角度）\n\n      path = getSectorPath(center.x, center.y, r1, coordinate.startAngle, coordinate.endAngle, r2);\n    }\n  }\n\n  return path;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param lineCap 'round'圆角样式\n * @param coor 坐标\n * @returns 返回矩形的 path\n */\n\nexport function getIntervalRectPath(points, lineCap, coor) {\n  var width = coor.getWidth();\n  var height = coor.getHeight();\n  var isRect = coor.type === 'rect';\n  var path = [];\n  var r = (points[2].x - points[1].x) / 2;\n  var ry = coor.isTransposed ? r * height / width : r * width / height;\n\n  if (lineCap === 'round') {\n    if (isRect) {\n      path.push(['M', points[0].x, points[0].y + ry]);\n      path.push(['L', points[1].x, points[1].y - ry]);\n      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y - ry]);\n      path.push(['L', points[3].x, points[3].y + ry]);\n      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y + ry]);\n    } else {\n      path.push(['M', points[0].x, points[0].y]);\n      path.push(['L', points[1].x, points[1].y]);\n      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y]);\n      path.push(['L', points[3].x, points[3].y]);\n      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y]);\n    }\n\n    path.push(['z']);\n  } else {\n    path = getRectPath(points);\n  }\n\n  return path;\n}\n/**\n * @ignore\n * 根据 funnel 关键点绘制漏斗图的 path\n * @param points 图形关键点信息\n * @param nextPoints 下一个数据的图形关键点信息\n * @param isPyramid 是否为尖底漏斗图\n * @returns 返回漏斗图的图形 path\n */\n\nexport function getFunnelPath(points, nextPoints, isPyramid) {\n  var path = [];\n\n  if (!isNil(nextPoints)) {\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', nextPoints[1].x, nextPoints[1].y], ['L', nextPoints[0].x, nextPoints[0].y], ['Z']);\n  } else if (isPyramid) {\n    // 金字塔最底部\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', (points[2].x + points[3].x) / 2, (points[2].y + points[3].y) / 2], ['Z']);\n  } else {\n    // 漏斗图最底部\n    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']);\n  }\n\n  return path;\n}\n/**\n * 交换两个对象\n */\n\nfunction swap(p0, p1) {\n  return [p1, p0];\n}\n/**\n * 获取 倒角 矩形\n * - 目前只适用于笛卡尔坐标系下\n */\n\n\nexport function getRectWithCornerRadius(points, coordinate, radius) {\n  var _a, _b, _c, _d, _e, _f, _g; // 获取 四个关键点\n\n\n  var _h = __read(__spreadArray([], __read(points), false), 4),\n      p0 = _h[0],\n      p1 = _h[1],\n      p2 = _h[2],\n      p3 = _h[3];\n\n  var _j = __read(typeof radius === 'number' ? Array(4).fill(radius) : radius, 4),\n      r1 = _j[0],\n      r2 = _j[1],\n      r3 = _j[2],\n      r4 = _j[3];\n\n  if (coordinate.isTransposed) {\n    _a = __read(swap(p1, p3), 2), p1 = _a[0], p3 = _a[1];\n  }\n  /**\n   * 存在镜像\n   */\n\n\n  if (coordinate.isReflect('y')) {\n    _b = __read(swap(p0, p1), 2), p0 = _b[0], p1 = _b[1];\n    _c = __read(swap(p2, p3), 2), p2 = _c[0], p3 = _c[1];\n  }\n\n  if (coordinate.isReflect('x')) {\n    _d = __read(swap(p0, p3), 2), p0 = _d[0], p3 = _d[1];\n    _e = __read(swap(p1, p2), 2), p1 = _e[0], p2 = _e[1];\n  }\n\n  var path = [];\n  /**\n   *  p1 → p2\n   *  ↑    ↓\n   *  p0 ← p3\n   *\n   *  负数的情况，关键点会变成下面的形式\n   *\n   *  p0 ← p3               p2 ← p1\n   *  ↓    ↑                ↓     ↑\n   *  p1 → p2  --> (转置下)  p3 → p0\n   */\n\n  var abs = function (v) {\n    return Math.abs(v);\n  };\n\n  _f = __read(parseRadius([r1, r2, r3, r4], Math.min(abs(p3.x - p0.x), abs(p1.y - p0.y))).map(function (d) {\n    return abs(d);\n  }), 4), r1 = _f[0], r2 = _f[1], r3 = _f[2], r4 = _f[3];\n\n  if (coordinate.isTransposed) {\n    _g = __read([r4, r1, r2, r3], 4), r1 = _g[0], r2 = _g[1], r3 = _g[2], r4 = _g[3];\n  }\n\n  if (p0.y < p1.y\n  /** 负数情况 */\n  ) {\n    path.push(['M', p3.x, p3.y + r3]);\n    r3 !== 0 && path.push(['A', r3, r3, 0, 0, 0, p3.x - r3, p3.y]);\n    path.push(['L', p0.x + r4, p0.y]);\n    r4 !== 0 && path.push(['A', r4, r4, 0, 0, 0, p0.x, p0.y + r4]);\n    path.push(['L', p1.x, p1.y - r1]);\n    r1 !== 0 && path.push(['A', r1, r1, 0, 0, 0\n    /** 逆时针 */\n    , p1.x + r1, p1.y]);\n    path.push(['L', p2.x - r2, p2.y]);\n    r2 !== 0 && path.push(['A', r2, r2, 0, 0, 0, p2.x, p2.y - r2]);\n    path.push(['L', p3.x, p3.y + r3]);\n    path.push(['z']);\n  } else if (p3.x < p0.x) {\n    path.push(['M', p2.x + r2, p2.y]);\n    r2 !== 0 && path.push(['A', r2, r2, 0, 0, 0, p2.x, p2.y + r2]);\n    path.push(['L', p3.x, p3.y - r3]);\n    r3 !== 0 && path.push(['A', r3, r3, 0, 0, 0, p3.x + r3, p3.y]);\n    path.push(['L', p0.x - r4, p0.y]);\n    r4 !== 0 && path.push(['A', r4, r4, 0, 0, 0, p0.x, p0.y - r4]);\n    path.push(['L', p1.x, p1.y + r1]);\n    r1 !== 0 && path.push(['A', r1, r1, 0, 0, 0, p1.x - r1, p1.y]);\n    path.push(['L', p2.x + r2, p2.y]);\n    path.push(['z']);\n  } else {\n    path.push(['M', p1.x, p1.y + r1]);\n    r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p1.x + r1, p1.y]);\n    path.push(['L', p2.x - r2, p2.y]);\n    r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p2.x, p2.y + r2]);\n    path.push(['L', p3.x, p3.y - r3]);\n    r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p3.x - r3, p3.y]);\n    path.push(['L', p0.x + r4, p0.y]);\n    r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);\n    path.push(['L', p1.x, p1.y + r1]);\n    path.push(['z']);\n  }\n\n  return path;\n}","map":{"version":3,"mappings":"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","names":["isArray","isNil","get","getAngle","getSectorPath","getRectPoints","pointInfo","y","y0","size","yMin","yMax","_a","xMin","xMax","x","_b","points","push","getRectPath","isClosed","path","firstPoint","i","len","length","parseRadius","radius","minLength","r1","r2","r3","r4","getBackgroundRectPath","cfg","coordinate","isRect","p0","isTransposed","start","p1","end","width","Math","abs","height","getWidth","getHeight","min","isReflectYTransposed_1","isReflect","bump","opposite","r","isPolar","center","getCenter","startAngle","endAngle","type","getRadius","pow","v","sqrt","getIntervalRectPath","lineCap","coor","ry","getFunnelPath","nextPoints","isPyramid","swap","getRectWithCornerRadius","p2","p3","Array","fill","_c","_d","_e","_f","map","d","_g"],"sourceRoot":"","sources":["../../../../src/geometry/shape/interval/util.ts"],"sourcesContent":["import { Coordinate } from '@antv/coord';\nimport { isArray, isNil, get } from '@antv/util';\nimport { getAngle, getSectorPath } from '../../../util/graphics';\nimport { PathCommand } from '../../../dependents';\nimport { Point, ShapeInfo, ShapePoint } from '../../../interface';\n\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @param [isPyramid] 是否为尖底漏斗图\n * @returns rect points 返回矩形四个顶点信息\n */\nexport function getRectPoints(pointInfo: ShapePoint): Point[] {\n  const { x, y, y0, size } = pointInfo;\n  // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n  let yMin;\n  let yMax;\n  if (isArray(y)) {\n    [yMin, yMax] = y;\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  let xMin;\n  let xMax;\n  if (isArray(x)) {\n    [xMin, xMax] = x;\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n\n  const points = [\n    { x: xMin, y: yMin },\n    { x: xMin, y: yMax },\n  ];\n\n  // 矩形的四个关键点，结构如下（左下角顺时针连接）\n  // 1 ---- 2\n  // |      |\n  // 0 ---- 3\n  points.push({ x: xMax, y: yMax }, { x: xMax, y: yMin });\n\n  return points;\n}\n\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\nexport function getRectPath(points: Point[], isClosed: boolean = true): PathCommand[] {\n  const path = [];\n  const firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n  for (let i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  }\n  // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n    path.push(['z']);\n  }\n  return path;\n}\n\n/**\n * 处理 rect path 的 radius\n * @returns 返回矩形 path 的四个角的 arc 半径\n */\nexport function parseRadius(radius: number | number[], minLength: number): number[] {\n  let r1 = 0;\n  let r2 = 0;\n  let r3 = 0;\n  let r4 = 0;\n  if (isArray(radius)) {\n    if (radius.length === 1) {\n      r1 = r2 = r3 = r4 = radius[0];\n    } else if (radius.length === 2) {\n      r1 = r3 = radius[0];\n      r2 = r4 = radius[1];\n    } else if (radius.length === 3) {\n      r1 = radius[0];\n      r2 = r4 = radius[1];\n      r3 = radius[2];\n    } else {\n      r1 = radius[0];\n      r2 = radius[1];\n      r3 = radius[2];\n      r4 = radius[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = radius;\n  }\n\n  // 处理 边界值\n  if (r1 + r2 > minLength) {\n    r1 = r1 ? minLength / (1 + r2 / r1) : 0;\n    r2 = minLength - r1;\n  }\n\n  if (r3 + r4 > minLength) {\n    r3 = r3 ? minLength / (1 + r4 / r3) : 0;\n    r4 = minLength - r3;\n  }\n\n  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];\n}\n\n/**\n * 获取 interval 矩形背景的 path\n * @param cfg 关键点的信息\n * @param points 已转化为画布坐标的 4 个关键点\n * @param coordinate 坐标系\n * @returns 返回矩形背景的 path\n */\nexport function getBackgroundRectPath(cfg: ShapeInfo, points: Point[], coordinate: Coordinate): PathCommand[] {\n  let path = [];\n  if (coordinate.isRect) {\n    const p0 = coordinate.isTransposed\n      ? { x: coordinate.start.x, y: points[0].y }\n      : { x: points[0].x, y: coordinate.start.y };\n    const p1 = coordinate.isTransposed\n      ? { x: coordinate.end.x, y: points[2].y }\n      : { x: points[3].x, y: coordinate.end.y };\n\n    // corner radius of background shape works only in 笛卡尔坐标系\n    const radius = get(cfg, ['background', 'style', 'radius']);\n    if (radius) {\n      const width = coordinate.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;\n      const height = coordinate.isTransposed ? coordinate.getWidth() : coordinate.getHeight();\n      const [r1, r2, r3, r4] = parseRadius(radius, Math.min(width, height));\n\n      // 同时存在 坐标系是否发生转置 和 y 镜像的时候\n      const isReflectYTransposed = (coordinate.isTransposed && coordinate.isReflect('y'));\n      const bump = isReflectYTransposed ? 0 : 1;\n      const opposite = (r: number) => isReflectYTransposed ? -r : r;\n\n      path.push(['M', p0.x, p1.y + opposite(r1)]);\n      r1 !== 0 && path.push(['A', r1, r1, 0, 0, bump, p0.x + r1, p1.y]);\n      path.push(['L', p1.x - r2, p1.y]);\n      r2 !== 0 && path.push(['A', r2, r2, 0, 0, bump, p1.x, p1.y + opposite(r2)]);\n      path.push(['L', p1.x, p0.y - opposite(r3)]);\n      r3 !== 0 && path.push(['A', r3, r3, 0, 0, bump, p1.x - r3, p0.y]);\n      path.push(['L', p0.x + r4, p0.y]);\n      r4 !== 0 && path.push(['A', r4, r4, 0, 0, bump, p0.x, p0.y - opposite(r4)]);\n    } else {\n      path.push(['M', p0.x, p0.y]);\n      path.push(['L', p1.x, p0.y]);\n      path.push(['L', p1.x, p1.y]);\n      path.push(['L', p0.x, p1.y]);\n      path.push(['L', p0.x, p0.y]);\n    }\n\n    path.push(['z']);\n  }\n\n  if (coordinate.isPolar) {\n    const center = coordinate.getCenter();\n    const { startAngle, endAngle } = getAngle(cfg, coordinate);\n    if (coordinate.type !== 'theta' && !coordinate.isTransposed) {\n      // 获取扇形 path\n      path = getSectorPath(center.x, center.y, coordinate.getRadius(), startAngle, endAngle);\n    } else {\n      const pow = (v) => Math.pow(v, 2);\n      const r1 = Math.sqrt(pow(center.x - points[0].x) + pow(center.y - points[0].y));\n      const r2 = Math.sqrt(pow(center.x - points[2].x) + pow(center.y - points[2].y));\n      // 获取扇形 path（其实是一个圆环，从 coordinate 的起始角度到结束角度）\n      path = getSectorPath(center.x, center.y, r1, coordinate.startAngle, coordinate.endAngle, r2);\n    }\n  }\n  return path;\n}\n\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param lineCap 'round'圆角样式\n * @param coor 坐标\n * @returns 返回矩形的 path\n */\nexport function getIntervalRectPath(points: Point[], lineCap: CanvasLineCap, coor: Coordinate): PathCommand[] {\n  const width = coor.getWidth();\n  const height = coor.getHeight();\n  const isRect = coor.type === 'rect';\n  let path = [];\n  const r = (points[2].x - points[1].x) / 2;\n  const ry = coor.isTransposed ? (r * height) / width : (r * width) / height;\n  if (lineCap === 'round') {\n    if (isRect) {\n      path.push(['M', points[0].x, points[0].y + ry]);\n      path.push(['L', points[1].x, points[1].y - ry]);\n      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y - ry]);\n      path.push(['L', points[3].x, points[3].y + ry]);\n      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y + ry]);\n    } else {\n      path.push(['M', points[0].x, points[0].y]);\n      path.push(['L', points[1].x, points[1].y]);\n      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y]);\n      path.push(['L', points[3].x, points[3].y]);\n      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y]);\n    }\n    path.push(['z']);\n  } else {\n    path = getRectPath(points);\n  }\n  return path;\n}\n\n/**\n * @ignore\n * 根据 funnel 关键点绘制漏斗图的 path\n * @param points 图形关键点信息\n * @param nextPoints 下一个数据的图形关键点信息\n * @param isPyramid 是否为尖底漏斗图\n * @returns 返回漏斗图的图形 path\n */\nexport function getFunnelPath(points: Point[], nextPoints: Point[], isPyramid: boolean) {\n  const path = [];\n  if (!isNil(nextPoints)) {\n    path.push(\n      ['M', points[0].x, points[0].y],\n      ['L', points[1].x, points[1].y],\n      ['L', nextPoints[1].x, nextPoints[1].y],\n      ['L', nextPoints[0].x, nextPoints[0].y],\n      ['Z']\n    );\n  } else if (isPyramid) {\n    // 金字塔最底部\n    path.push(\n      ['M', points[0].x, points[0].y],\n      ['L', points[1].x, points[1].y],\n      ['L', (points[2].x + points[3].x) / 2, (points[2].y + points[3].y) / 2],\n      ['Z']\n    );\n  } else {\n    // 漏斗图最底部\n    path.push(\n      ['M', points[0].x, points[0].y],\n      ['L', points[1].x, points[1].y],\n      ['L', points[2].x, points[2].y],\n      ['L', points[3].x, points[3].y],\n      ['Z']\n    );\n  }\n\n  return path;\n}\n\n/**\n * 交换两个对象\n */\nfunction swap<T>(p0: T, p1: T) {\n  return [p1, p0];\n}\n\n/**\n * 获取 倒角 矩形\n * - 目前只适用于笛卡尔坐标系下\n */\nexport function getRectWithCornerRadius(points: Point[], coordinate: Coordinate, radius?: number | number[]) {\n  // 获取 四个关键点\n  let [p0, p1, p2, p3] = [...points];\n  let [r1, r2, r3, r4] = typeof radius === 'number' ? Array(4).fill(radius) : radius;\n\n  if (coordinate.isTransposed) {\n    [p1, p3] = swap(p1, p3);\n  }\n\n  /**\n   * 存在镜像\n   */\n  if (coordinate.isReflect('y')) {\n    [p0, p1] = swap(p0, p1);\n    [p2, p3] = swap(p2, p3);\n  }\n  if (coordinate.isReflect('x')) {\n    [p0, p3] = swap(p0, p3);\n    [p1, p2] = swap(p1, p2);\n  }\n\n  const path = [];\n\n\n  /**\n   *  p1 → p2\n   *  ↑    ↓\n   *  p0 ← p3\n   *\n   *  负数的情况，关键点会变成下面的形式\n   *\n   *  p0 ← p3               p2 ← p1\n   *  ↓    ↑                ↓     ↑\n   *  p1 → p2  --> (转置下)  p3 → p0\n   */\n  const abs = v => Math.abs(v);\n  [r1, r2, r3, r4] = parseRadius([r1, r2, r3, r4], Math.min(abs(p3.x - p0.x), abs(p1.y - p0.y))).map(d => abs(d));\n\n  if (coordinate.isTransposed) {\n    [r1, r2, r3, r4] = [r4, r1, r2, r3]\n  }\n\n  if (p0.y < p1.y /** 负数情况 */) {\n    path.push(['M', p3.x, p3.y + r3]);\n    r3 !== 0 && path.push(['A', r3, r3, 0, 0, 0, p3.x - r3, p3.y]);\n    path.push(['L', p0.x + r4, p0.y]);\n    r4 !== 0 && path.push(['A', r4, r4, 0, 0, 0, p0.x, p0.y + r4]);\n    path.push(['L', p1.x, p1.y - r1]);\n    r1 !== 0 && path.push(['A', r1, r1, 0, 0, 0/** 逆时针 */, p1.x + r1, p1.y]);\n    path.push(['L', p2.x - r2, p2.y]);\n    r2 !== 0 && path.push(['A', r2, r2, 0, 0, 0, p2.x, p2.y - r2]);\n    path.push(['L', p3.x, p3.y + r3]);\n    path.push(['z']);\n  } else if (p3.x < p0.x) {\n    path.push(['M', p2.x + r2, p2.y]);\n    r2 !== 0 && path.push(['A', r2, r2, 0, 0, 0, p2.x, p2.y + r2]);\n    path.push(['L', p3.x, p3.y - r3]);\n    r3 !== 0 && path.push(['A', r3, r3, 0, 0, 0, p3.x + r3, p3.y]);\n    path.push(['L', p0.x - r4, p0.y]);\n    r4 !== 0 && path.push(['A', r4, r4, 0, 0, 0, p0.x, p0.y - r4]);\n    path.push(['L', p1.x, p1.y + r1]);\n    r1 !== 0 && path.push(['A', r1, r1, 0, 0, 0, p1.x - r1, p1.y]);\n    path.push(['L', p2.x + r2, p2.y]);\n    path.push(['z']);\n  } else {\n    path.push(['M', p1.x, p1.y + r1]);\n    r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p1.x + r1, p1.y]);\n    path.push(['L', p2.x - r2, p2.y]);\n    r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p2.x, p2.y + r2]);\n    path.push(['L', p3.x, p3.y - r3]);\n    r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p3.x - r3, p3.y]);\n    path.push(['L', p0.x + r4, p0.y]);\n    r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);\n    path.push(['L', p1.x, p1.y + r1]);\n    path.push(['z']);\n  }\n\n  return path;\n}\n"]},"metadata":{},"sourceType":"module"}