{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { get, deepMix, isArray } from '@antv/util';\nimport GeometryLabel from './base';\n/**\n * 柱状图 label\n */\n\nvar IntervalLabel =\n/** @class */\nfunction (_super) {\n  __extends(IntervalLabel, _super);\n\n  function IntervalLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * 获取 interval label 的方向，取决于 value 的值是正还是负\n   * @param labelCfg\n   */\n\n\n  IntervalLabel.prototype.getLabelValueDir = function (mappingData) {\n    // points 中的 x/y 和 transpose 无关\n    var dim = 'y';\n    var points = mappingData.points;\n    return points[0][dim] <= points[2][dim] ? 1 : -1;\n  };\n  /**\n   * 重载：根据 interval 值的正负来调整 label 偏移量\n   * @param labelCfg\n   * @param index\n   * @param total\n   */\n\n\n  IntervalLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total, position) {\n    var _a;\n\n    var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);\n\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var dim = transposed ? 'x' : 'y';\n    var dir = this.getLabelValueDir(labelCfg.mappingData);\n    point = __assign(__assign({}, point), (_a = {}, _a[dim] = point[dim] * dir, _a));\n\n    if (coordinate.isReflect('x')) {\n      point = __assign(__assign({}, point), {\n        x: point.x * -1\n      });\n    }\n\n    if (coordinate.isReflect('y')) {\n      point = __assign(__assign({}, point), {\n        y: point.y * -1\n      });\n    }\n\n    return point;\n  };\n  /**\n   * 重载：定制 interval label 的默认主题配置\n   * @param labelCfg\n   */\n\n\n  IntervalLabel.prototype.getThemedLabelCfg = function (labelCfg) {\n    var geometry = this.geometry;\n    var defaultLabelCfg = this.getDefaultLabelCfg();\n    var theme = geometry.theme; // 如果 interval label position 设置为 middle，则将主题中的 offset 覆盖为 0\n\n    return deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? {\n      offset: 0\n    } : {}, labelCfg);\n  };\n\n  IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var shapePoints = mappingData.points;\n    var point0 = coordinate.convert(shapePoints[0]);\n    var point2 = coordinate.convert(shapePoints[2]);\n    var dir = this.getLabelValueDir(mappingData);\n    var top;\n    var right;\n    var bottom;\n    var left;\n    var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n\n    if (shape === 'funnel' || shape === 'pyramid') {\n      // 处理漏斗图\n      var nextPoints = get(mappingData, 'nextPoints');\n      var points = get(mappingData, 'points');\n\n      if (nextPoints) {\n        // 非漏斗图底部\n        var p0 = coordinate.convert(points[0]);\n        var p1 = coordinate.convert(points[1]);\n        var nextP0 = coordinate.convert(nextPoints[0]);\n        var nextP1 = coordinate.convert(nextPoints[1]); // TODO: 使用包围盒的计算方法\n\n        if (transposed) {\n          top = Math.min(nextP0.y, p0.y);\n          bottom = Math.max(nextP0.y, p0.y);\n          right = (p1.x + nextP1.x) / 2;\n          left = (p0.x + nextP0.x) / 2;\n        } else {\n          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          right = nextP1.x;\n          left = p0.x;\n        }\n      } else {\n        top = Math.min(point2.y, point0.y);\n        bottom = Math.max(point2.y, point0.y);\n        right = point2.x;\n        left = point0.x;\n      }\n    } else {\n      top = Math.min(point2.y, point0.y);\n      bottom = Math.max(point2.y, point0.y);\n      right = point2.x;\n      left = point0.x;\n    }\n\n    switch (position) {\n      case 'right':\n        labelPointCfg.x = right;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n\n      case 'left':\n        labelPointCfg.x = left;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n\n      case 'bottom':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n\n        labelPointCfg.y = bottom;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n\n      case 'middle':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'middle');\n        break;\n\n      case 'top':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n\n        labelPointCfg.y = top;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  return IntervalLabel;\n}(GeometryLabel);\n\nexport default IntervalLabel;","map":{"version":3,"mappings":"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","names":["get","deepMix","isArray","GeometryLabel","__extends","IntervalLabel","mappingData","dim","points","labelCfg","index","total","position","point","_super","getLabelOffsetPoint","call","coordinate","getCoordinate","transposed","isTransposed","dir","getLabelValueDir","_a","isReflect","x","y","geometry","defaultLabelCfg","getDefaultLabelCfg","theme","labels","offset","labelPointCfg","shapePoints","point0","convert","point2","top","right","bottom","left","shape","nextPoints","p0","p1","nextP0","nextP1","Math","min","max","textAlign","textBaseline"],"sourceRoot":"","sources":["../../../src/geometry/label/interval.ts"],"sourcesContent":["import { get, deepMix, isArray } from '@antv/util';\nimport { Writeable } from '../../util/types';\nimport { MappingDatum, Point } from '../../interface';\nimport GeometryLabel from './base';\nimport { LabelCfg, LabelItem, LabelPointCfg, TextAlign } from './interface';\n\n/**\n * 柱状图 label\n */\nexport default class IntervalLabel extends GeometryLabel {\n  /**\n   * 获取 interval label 的方向，取决于 value 的值是正还是负\n   * @param labelCfg\n   */\n  private getLabelValueDir(mappingData: MappingDatum) {\n    // points 中的 x/y 和 transpose 无关\n    const dim = 'y';\n    const { points } = mappingData;\n\n    return points[0][dim] <= points[2][dim] ? 1 : -1;\n  }\n\n  /**\n   * 重载：根据 interval 值的正负来调整 label 偏移量\n   * @param labelCfg\n   * @param index\n   * @param total\n   */\n  protected getLabelOffsetPoint(labelCfg: LabelCfg, index: number, total: number, position?: string) {\n    let point = super.getLabelOffsetPoint(labelCfg, index, total);\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const dim = transposed ? 'x' : 'y';\n    const dir = this.getLabelValueDir(labelCfg.mappingData);\n    point = { ...point, [dim]: point[dim] * dir };\n\n    if (coordinate.isReflect('x')) {\n      point = {\n        ...point,\n        x: point.x * -1,\n      };\n    }\n    if (coordinate.isReflect('y')) {\n      point = {\n        ...point,\n        y: point.y * -1,\n      };\n    }\n\n    return point;\n  }\n\n  /**\n   * 重载：定制 interval label 的默认主题配置\n   * @param labelCfg\n   */\n  protected getThemedLabelCfg(labelCfg: LabelCfg) {\n    const geometry = this.geometry;\n    const defaultLabelCfg = this.getDefaultLabelCfg();\n    const { theme } = geometry;\n\n    // 如果 interval label position 设置为 middle，则将主题中的 offset 覆盖为 0\n    return deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? { offset: 0 } : {}, labelCfg);\n  }\n\n  protected setLabelPosition(\n    labelPointCfg: Writeable<LabelPointCfg>,\n    mappingData: MappingDatum,\n    index: number,\n    position: string\n  ) {\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const shapePoints = mappingData.points as Point[];\n    const point0 = coordinate.convert(shapePoints[0]);\n    const point2 = coordinate.convert(shapePoints[2]);\n    const dir = this.getLabelValueDir(mappingData);\n\n    let top;\n    let right;\n    let bottom;\n    let left;\n\n    const shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    if (shape === 'funnel' || shape === 'pyramid') {\n      // 处理漏斗图\n      const nextPoints = get(mappingData, 'nextPoints');\n      const points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        const p0 = coordinate.convert(points[0] as Point);\n        const p1 = coordinate.convert(points[1] as Point);\n        const nextP0 = coordinate.convert(nextPoints[0] as Point);\n        const nextP1 = coordinate.convert(nextPoints[1] as Point);\n\n        // TODO: 使用包围盒的计算方法\n        if (transposed) {\n          top = Math.min(nextP0.y, p0.y);\n          bottom = Math.max(nextP0.y, p0.y);\n          right = (p1.x + nextP1.x) / 2;\n          left = (p0.x + nextP0.x) / 2;\n        } else {\n          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          right = nextP1.x;\n          left = p0.x;\n        }\n      } else {\n        top = Math.min(point2.y, point0.y);\n        bottom = Math.max(point2.y, point0.y);\n        right = point2.x;\n        left = point0.x;\n      }\n    } else {\n      top = Math.min(point2.y, point0.y);\n      bottom = Math.max(point2.y, point0.y);\n      right = point2.x;\n      left = point0.x;\n    }\n\n    switch (position) {\n      case 'right':\n        labelPointCfg.x = right;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'left':\n        labelPointCfg.x = left;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'bottom':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = bottom;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      case 'middle':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'middle');\n        break;\n      case 'top':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = top;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      default:\n        break;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}