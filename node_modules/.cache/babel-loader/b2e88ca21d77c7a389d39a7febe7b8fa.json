{"ast":null,"code":"import { __assign, __awaiter, __generator, __rest, __values } from \"tslib\";\nimport { deepMix, each, get, isArray, isNull } from '@antv/util';\nimport { doAnimate } from '../animate';\nimport { getGeometryLabelLayout } from '../geometry/label';\nimport { getLabelBackgroundInfo } from '../geometry/label/util';\nimport { polarToCartesian } from '../util/graphics';\nimport { rotate, translate } from '../util/transform';\nimport { FIELD_ORIGIN } from '../constant';\nimport { updateLabel } from './update-label';\n/**\n * Geometry labels 渲染组件\n */\n\nvar Labels =\n/** @class */\nfunction () {\n  function Labels(cfg) {\n    /** 存储当前 shape 的映射表，键值为 shape id */\n    this.shapesMap = {};\n    var layout = cfg.layout,\n        container = cfg.container;\n    this.layout = layout;\n    this.container = container;\n  }\n  /**\n   * 渲染文本\n   */\n\n\n  Labels.prototype.render = function (items, shapes, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var shapesMap, offscreenGroup, items_1, items_1_1, item, lastShapesMap;\n\n      var e_1, _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            shapesMap = {};\n            offscreenGroup = this.createOffscreenGroup();\n            if (!items.length) return [3\n            /*break*/\n            , 2];\n\n            try {\n              // 如果 items 空的话就不进行绘制调整操作\n              // step 1: 在虚拟 group 中创建 shapes\n              for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n                item = items_1_1.value;\n\n                if (item) {\n                  shapesMap[item.id] = this.renderLabel(item, offscreenGroup);\n                }\n              }\n            } catch (e_1_1) {\n              e_1 = {\n                error: e_1_1\n              };\n            } finally {\n              try {\n                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n              } finally {\n                if (e_1) throw e_1.error;\n              }\n            } // [todo] Move layout into Worker.\n            // step 2: 根据布局，调整 labels\n\n\n            return [4\n            /*yield*/\n            , this.doLayout(items, shapes, shapesMap)];\n\n          case 1:\n            // [todo] Move layout into Worker.\n            // step 2: 根据布局，调整 labels\n            _b.sent(); // step 3.1: 绘制 labelLine\n\n\n            this.renderLabelLine(items, shapesMap); // step 3.2: 绘制 labelBackground\n\n            this.renderLabelBackground(items, shapesMap); // step 4: 根据用户设置的偏移量调整 label\n\n            this.adjustLabel(items, shapesMap);\n            _b.label = 2;\n\n          case 2:\n            lastShapesMap = this.shapesMap;\n            each(shapesMap, function (shape, id) {\n              if (shape.destroyed) {\n                // label 在布局调整环节被删除了（doLayout）\n                delete shapesMap[id];\n              } else {\n                if (lastShapesMap[id]) {\n                  // 图形发生更新\n                  var data = shape.get('data');\n                  var origin_1 = shape.get('origin');\n                  var coordinate = shape.get('coordinate');\n                  var currentAnimateCfg = shape.get('animateCfg');\n                  var currentShape = lastShapesMap[id]; // 已经在渲染树上的 shape\n\n                  updateLabel(currentShape, shapesMap[id], {\n                    data: data,\n                    origin: origin_1,\n                    animateCfg: currentAnimateCfg,\n                    coordinate: coordinate\n                  });\n                  shapesMap[id] = currentShape; // 保存引用\n                } else {\n                  // 新生成的 shape\n                  // If container has been destroyed, no need to render labels.\n                  if (_this.container.destroyed) return;\n\n                  _this.container.add(shape);\n\n                  var animateCfg = get(shape.get('animateCfg'), isUpdate ? 'enter' : 'appear');\n\n                  if (animateCfg) {\n                    doAnimate(shape, animateCfg, {\n                      toAttrs: __assign({}, shape.attr()),\n                      coordinate: shape.get('coordinate')\n                    });\n                  }\n                }\n\n                delete lastShapesMap[id];\n              }\n            }); // 移除\n\n            each(lastShapesMap, function (deleteShape) {\n              var animateCfg = get(deleteShape.get('animateCfg'), 'leave');\n\n              if (animateCfg) {\n                doAnimate(deleteShape, animateCfg, {\n                  toAttrs: null,\n                  coordinate: deleteShape.get('coordinate')\n                });\n              } else {\n                deleteShape.remove(true); // 移除\n              }\n            });\n            this.shapesMap = shapesMap;\n            offscreenGroup.destroy();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /** 清除当前 labels */\n\n\n  Labels.prototype.clear = function () {\n    this.container.clear();\n    this.shapesMap = {};\n  };\n  /** 销毁 */\n\n\n  Labels.prototype.destroy = function () {\n    this.container.destroy();\n    this.shapesMap = null;\n  };\n\n  Labels.prototype.renderLabel = function (cfg, container) {\n    var id = cfg.id,\n        elementId = cfg.elementId,\n        data = cfg.data,\n        mappingData = cfg.mappingData,\n        coordinate = cfg.coordinate,\n        animate = cfg.animate,\n        content = cfg.content;\n    var shapeAppendCfg = {\n      id: id,\n      elementId: elementId,\n      data: data,\n      origin: __assign(__assign({}, mappingData), {\n        data: mappingData[FIELD_ORIGIN]\n      }),\n      coordinate: coordinate\n    };\n    var labelGroup = container.addGroup(__assign({\n      name: 'label',\n      // 如果 this.animate === false 或者 cfg.animate === false/null 则不进行动画，否则进行动画配置的合并\n      animateCfg: this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate)\n    }, shapeAppendCfg));\n    var labelShape;\n\n    if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {\n      // 如果 content 是 Group 或者 Shape，根据 textAlign 调整位置后，直接将其加入 labelGroup\n      var _a = content.getCanvasBBox(),\n          width = _a.width,\n          height = _a.height;\n\n      var textAlign = get(cfg, 'textAlign', 'left');\n      var x = cfg.x;\n      var y = cfg.y - height / 2;\n\n      if (textAlign === 'center') {\n        x = x - width / 2;\n      } else if (textAlign === 'right' || textAlign === 'end') {\n        x = x - width;\n      }\n\n      translate(content, x, y); // 将 label 平移至 x, y 指定的位置\n\n      labelShape = content;\n      labelGroup.add(content);\n    } else {\n      var fill = get(cfg, ['style', 'fill']);\n      labelShape = labelGroup.addShape('text', __assign({\n        attrs: __assign(__assign({\n          x: cfg.x,\n          y: cfg.y,\n          textAlign: cfg.textAlign,\n          textBaseline: get(cfg, 'textBaseline', 'middle'),\n          text: cfg.content\n        }, cfg.style), {\n          fill: isNull(fill) ? cfg.color : fill\n        })\n      }, shapeAppendCfg));\n    }\n\n    if (cfg.rotate) {\n      rotate(labelShape, cfg.rotate);\n    }\n\n    return labelGroup;\n  }; // 根据type对label布局\n\n\n  Labels.prototype.doLayout = function (items, shapes, shapesMap) {\n    return __awaiter(this, void 0, void 0, function () {\n      var layouts;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.layout) return [3\n            /*break*/\n            , 2];\n            layouts = isArray(this.layout) ? this.layout : [this.layout];\n            return [4\n            /*yield*/\n            , Promise.all(layouts.map(function (layout) {\n              var layoutFn = getGeometryLabelLayout(get(layout, 'type', ''));\n              if (!layoutFn) return;\n              var labelShapes = [];\n              var geometryShapes = [];\n              each(shapesMap, function (labelShape, id) {\n                labelShapes.push(labelShape);\n                geometryShapes.push(shapes[labelShape.get('elementId')]);\n              }); // [todo] Refactor more layout into Worker.\n\n              return layoutFn(items, labelShapes, geometryShapes, _this.region, layout.cfg);\n            }))];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Labels.prototype.renderLabelLine = function (labelItems, shapesMap) {\n    each(labelItems, function (labelItem) {\n      var coordinate = get(labelItem, 'coordinate');\n\n      if (!labelItem || !coordinate) {\n        return;\n      }\n\n      var center = coordinate.getCenter();\n      var radius = coordinate.getRadius();\n\n      if (!labelItem.labelLine) {\n        // labelLine: null | false，关闭 label 对应的 labelLine\n        return;\n      }\n\n      var labelLineCfg = get(labelItem, 'labelLine', {});\n      var id = labelItem.id;\n      var path = labelLineCfg.path;\n\n      if (!path) {\n        var start = polarToCartesian(center.x, center.y, radius, labelItem.angle);\n        path = [['M', start.x, start.y], ['L', labelItem.x, labelItem.y]];\n      }\n\n      var labelGroup = shapesMap[id];\n\n      if (!labelGroup.destroyed) {\n        labelGroup.addShape('path', {\n          capture: false,\n          attrs: __assign({\n            path: path,\n            stroke: labelItem.color ? labelItem.color : get(labelItem, ['style', 'fill'], '#000'),\n            fill: null\n          }, labelLineCfg.style),\n          id: id,\n          origin: labelItem.mappingData,\n          data: labelItem.data,\n          coordinate: labelItem.coordinate\n        });\n      }\n    });\n  };\n  /**\n   * 绘制标签背景\n   * @param labelItems\n   */\n\n\n  Labels.prototype.renderLabelBackground = function (labelItems, shapesMap) {\n    each(labelItems, function (labelItem) {\n      var coordinate = get(labelItem, 'coordinate');\n      var background = get(labelItem, 'background');\n\n      if (!background || !coordinate) {\n        return;\n      }\n\n      var id = labelItem.id;\n      var labelGroup = shapesMap[id];\n\n      if (!labelGroup.destroyed) {\n        var labelContentShape = labelGroup.getChildren()[0];\n\n        if (labelContentShape) {\n          var _a = getLabelBackgroundInfo(labelGroup, labelItem, background.padding),\n              rotation = _a.rotation,\n              box = __rest(_a, [\"rotation\"]);\n\n          var backgroundShape = labelGroup.addShape('rect', {\n            attrs: __assign(__assign({}, box), background.style || {}),\n            id: id,\n            origin: labelItem.mappingData,\n            data: labelItem.data,\n            coordinate: labelItem.coordinate\n          });\n          backgroundShape.setZIndex(-1);\n\n          if (rotation) {\n            var matrix = labelContentShape.getMatrix();\n            backgroundShape.setMatrix(matrix);\n          }\n        }\n      }\n    });\n  };\n\n  Labels.prototype.createOffscreenGroup = function () {\n    var container = this.container;\n    var GroupClass = container.getGroupBase(); // 获取分组的构造函数\n\n    var newGroup = new GroupClass({});\n    return newGroup;\n  };\n\n  Labels.prototype.adjustLabel = function (items, shapesMap) {\n    each(items, function (item) {\n      if (item) {\n        var id = item.id;\n        var labelGroup = shapesMap[id];\n\n        if (!labelGroup.destroyed) {\n          // fix: 如果说开发者的 label content 是一个 group，此处的偏移无法对 整个 content group 生效；场景类似 饼图 spider label 是一个含 2 个 textShape 的 gorup\n          var labelShapes = labelGroup.findAll(function (ele) {\n            return ele.get('type') !== 'path';\n          });\n          each(labelShapes, function (labelShape) {\n            if (labelShape) {\n              if (item.offsetX) {\n                labelShape.attr('x', labelShape.attr('x') + item.offsetX);\n              }\n\n              if (item.offsetY) {\n                labelShape.attr('y', labelShape.attr('y') + item.offsetY);\n              }\n            }\n          });\n        }\n      }\n    });\n  };\n\n  return Labels;\n}();\n\nexport default Labels;","map":{"version":3,"mappings":";AAAA,SAASA,OAAT,EAAkBC,IAAlB,EAAwBC,GAAxB,EAA6BC,OAA7B,EAAsCC,MAAtC,QAAoD,YAApD;AAIA,SAASC,SAAT,QAA0B,YAA1B;AACA,SAASC,sBAAT,QAAuC,mBAAvC;AACA,SAASC,sBAAT,QAAuC,wBAAvC;AACA,SAASC,gBAAT,QAAiC,kBAAjC;AACA,SAASC,MAAT,EAAiBC,SAAjB,QAAkC,mBAAlC;AACA,SAASC,YAAT,QAA6B,aAA7B;AACA,SAASC,WAAT,QAA4B,gBAA5B;AAYA;;;;AAGA;AAAA;AAAA;EAaE,gBAAYC,GAAZ,EAA+B;IAH/B;IACO,iBAAoC,EAApC;IAGG,UAAM,GAAgBA,GAAG,OAAzB;IAAA,IAAQC,SAAS,GAAKD,GAAG,UAAzB;IAER,KAAKE,MAAL,GAAcA,MAAd;IACA,KAAKD,SAAL,GAAiBA,SAAjB;EACD;EACD;;;;;EAGaE,0BAAb,UAAoBC,KAApB,EAAwCC,MAAxC,EAAiFC,QAAjF,EAA0G;IAAzB;MAAAA;IAAyB;;;;;;;;;;;;YAClGC,SAAS,GAAG,EAAZ;YACAC,cAAc,GAAG,KAAKC,oBAAL,EAAjB;iBACFL,KAAK,CAACM,QAAN;YAAA;YAAA;;;cACF;cACA;cACA,KAAmBC,2BAAKC,0BAAxB,EAAwB,eAAxB,EAAwBA,0BAAxB,EAA0B;gBAAfC,IAAI,kBAAJ;;gBACT,IAAIA,IAAJ,EAAU;kBACRN,SAAS,CAACM,IAAI,CAACC,EAAN,CAAT,GAAqB,KAAKC,WAAL,CAAiBF,IAAjB,EAAuBL,cAAvB,CAArB;gBACD;cACF;;;;;;;;;;;cACD;YACA;;;YACA;YAAA;YAAA,EAAM,KAAKQ,QAAL,CAAcZ,KAAd,EAAqBC,MAArB,EAA6BE,SAA7B,CAAN;;;YAFA;YACA;YACAU,WAEA;;;YACA,KAAKC,eAAL,CAAqBd,KAArB,EAA4BG,SAA5B,GACA;;YACA,KAAKY,qBAAL,CAA2Bf,KAA3B,EAAkCG,SAAlC,GACA;;YACA,KAAKa,WAAL,CAAiBhB,KAAjB,EAAwBG,SAAxB;;;;YAIIc,aAAa,GAAG,KAAKd,SAArB;YACNnB,IAAI,CAACmB,SAAD,EAAY,UAACe,KAAD,EAAQR,EAAR,EAAU;cACxB,IAAIQ,KAAK,CAACC,SAAV,EAAqB;gBACnB;gBACA,OAAOhB,SAAS,CAACO,EAAD,CAAhB;cACD,CAHD,MAGO;gBACL,IAAIO,aAAa,CAACP,EAAD,CAAjB,EAAuB;kBACrB;kBACA,IAAMU,IAAI,GAAGF,KAAK,CAACjC,GAAN,CAAU,MAAV,CAAb;kBACA,IAAMoC,QAAM,GAAGH,KAAK,CAACjC,GAAN,CAAU,QAAV,CAAf;kBACA,IAAMqC,UAAU,GAAGJ,KAAK,CAACjC,GAAN,CAAU,YAAV,CAAnB;kBACA,IAAMsC,iBAAiB,GAAGL,KAAK,CAACjC,GAAN,CAAU,YAAV,CAA1B;kBAEA,IAAMuC,YAAY,GAAGP,aAAa,CAACP,EAAD,CAAlC,CAPqB,CAOmB;;kBACxCf,WAAW,CAAC6B,YAAD,EAAerB,SAAS,CAACO,EAAD,CAAxB,EAA8B;oBACvCU,IAAI,MADmC;oBAEvCK,MAAM,UAFiC;oBAGvCC,UAAU,EAAEH,iBAH2B;oBAIvCD,UAAU;kBAJ6B,CAA9B,CAAX;kBAOAnB,SAAS,CAACO,EAAD,CAAT,GAAgBc,YAAhB,CAfqB,CAeS;gBAC/B,CAhBD,MAgBO;kBACL;kBACA;kBACA,IAAIG,KAAI,CAAC9B,SAAL,CAAesB,SAAnB,EAA8B;;kBAC9BQ,KAAI,CAAC9B,SAAL,CAAe+B,GAAf,CAAmBV,KAAnB;;kBACA,IAAMQ,UAAU,GAAGzC,GAAG,CAACiC,KAAK,CAACjC,GAAN,CAAU,YAAV,CAAD,EAA0BiB,QAAQ,GAAG,OAAH,GAAa,QAA/C,CAAtB;;kBACA,IAAIwB,UAAJ,EAAgB;oBACdtC,SAAS,CAAC8B,KAAD,EAAQQ,UAAR,EAAoB;sBAC3BG,OAAO,eACFX,KAAK,CAACY,IAAN,EADE,CADoB;sBAI3BR,UAAU,EAAEJ,KAAK,CAACjC,GAAN,CAAU,YAAV;oBAJe,CAApB,CAAT;kBAMD;gBACF;;gBACD,OAAOgC,aAAa,CAACP,EAAD,CAApB;cACD;YACF,CAtCG,CAAJ,EAwCA;;YACA1B,IAAI,CAACiC,aAAD,EAAgB,UAACc,WAAD,EAAY;cAC9B,IAAML,UAAU,GAAGzC,GAAG,CAAC8C,WAAW,CAAC9C,GAAZ,CAAgB,YAAhB,CAAD,EAAgC,OAAhC,CAAtB;;cACA,IAAIyC,UAAJ,EAAgB;gBACdtC,SAAS,CAAC2C,WAAD,EAAcL,UAAd,EAA0B;kBACjCG,OAAO,EAAE,IADwB;kBAEjCP,UAAU,EAAES,WAAW,CAAC9C,GAAZ,CAAgB,YAAhB;gBAFqB,CAA1B,CAAT;cAID,CALD,MAKO;gBACL8C,WAAW,CAACC,MAAZ,CAAmB,IAAnB,EADK,CACqB;cAC3B;YACF,CAVG,CAAJ;YAYA,KAAK7B,SAAL,GAAiBA,SAAjB;YACAC,cAAc,CAAC6B,OAAf;;;;;;;EACD,CAhFY;EAkFb;;;EACOlC,yBAAP;IACE,KAAKF,SAAL,CAAeqC,KAAf;IACA,KAAK/B,SAAL,GAAiB,EAAjB;EACD,CAHM;EAKP;;;EACOJ,2BAAP;IACE,KAAKF,SAAL,CAAeoC,OAAf;IACA,KAAK9B,SAAL,GAAiB,IAAjB;EACD,CAHM;;EAKCJ,+BAAR,UAAoBH,GAApB,EAAoCC,SAApC,EAAqD;IAC3C,MAAE,GAAiED,GAAG,GAAtE;IAAA,IAAIuC,SAAS,GAAsDvC,GAAG,UAAtE;IAAA,IAAewB,IAAI,GAAgDxB,GAAG,KAAtE;IAAA,IAAqBwC,WAAW,GAAmCxC,GAAG,YAAtE;IAAA,IAAkC0B,UAAU,GAAuB1B,GAAG,WAAtE;IAAA,IAA8CyC,OAAO,GAAczC,GAAG,QAAtE;IAAA,IAAuD0C,OAAO,GAAK1C,GAAG,QAAtE;IACR,IAAM2C,cAAc,GAAG;MACrB7B,EAAE,IADmB;MAErByB,SAAS,WAFY;MAGrBf,IAAI,MAHiB;MAIrBK,MAAM,wBACDW,WADC,GACU;QACdhB,IAAI,EAAEgB,WAAW,CAAC1C,YAAD;MADH,CADV,CAJe;MAQrB4B,UAAU;IARW,CAAvB;IAUA,IAAMkB,UAAU,GAAG3C,SAAS,CAAC4C,QAAV,CAAkBC;MACnCC,IAAI,EAAE,OAD6B;MAEnC;MACAjB,UAAU,EACR,KAAKW,OAAL,KAAiB,KAAjB,IAA0BA,OAAO,KAAK,IAAtC,IAA8CA,OAAO,KAAK,KAA1D,GAAkE,KAAlE,GAA0EtD,OAAO,CAAC,EAAD,EAAK,KAAKsD,OAAV,EAAmBA,OAAnB;IAJhD,GAKhCE,cALgC,CAAlB,CAAnB;IAOA,IAAIK,UAAJ;;IACA,IAAKN,OAAO,CAACO,OAAR,IAAmBP,OAAO,CAACO,OAAR,EAApB,IAA2CP,OAAO,CAACQ,OAAR,IAAmBR,OAAO,CAACQ,OAAR,EAAlE,EAAsF;MACpF;MACM,SAAoBR,OAAO,CAACS,aAAR,EAApB;MAAA,IAAEC,KAAK,WAAP;MAAA,IAASC,MAAM,YAAf;;MACN,IAAMC,SAAS,GAAGjE,GAAG,CAACW,GAAD,EAAM,WAAN,EAAmB,MAAnB,CAArB;MAEA,IAAIuD,CAAC,GAAGvD,GAAG,CAACuD,CAAZ;MACA,IAAMC,CAAC,GAAGxD,GAAG,CAACwD,CAAJ,GAAQH,MAAM,GAAG,CAA3B;;MAEA,IAAIC,SAAS,KAAK,QAAlB,EAA4B;QAC1BC,CAAC,GAAGA,CAAC,GAAGH,KAAK,GAAG,CAAhB;MACD,CAFD,MAEO,IAAIE,SAAS,KAAK,OAAd,IAAyBA,SAAS,KAAK,KAA3C,EAAkD;QACvDC,CAAC,GAAGA,CAAC,GAAGH,KAAR;MACD;;MAEDvD,SAAS,CAAC6C,OAAD,EAAUa,CAAV,EAAaC,CAAb,CAAT,CAdoF,CAc1D;;MAC1BR,UAAU,GAAGN,OAAb;MACAE,UAAU,CAACZ,GAAX,CAAeU,OAAf;IACD,CAjBD,MAiBO;MACL,IAAMe,IAAI,GAAGpE,GAAG,CAACW,GAAD,EAAM,CAAC,OAAD,EAAU,MAAV,CAAN,CAAhB;MACAgD,UAAU,GAAGJ,UAAU,CAACc,QAAX,CAAoB,MAApB,EAA0BZ;QACrCa,KAAK;UACHJ,CAAC,EAAEvD,GAAG,CAACuD,CADJ;UAEHC,CAAC,EAAExD,GAAG,CAACwD,CAFJ;UAGHF,SAAS,EAAEtD,GAAG,CAACsD,SAHZ;UAIHM,YAAY,EAAEvE,GAAG,CAACW,GAAD,EAAM,cAAN,EAAsB,QAAtB,CAJd;UAKH6D,IAAI,EAAE7D,GAAG,CAAC0C;QALP,GAMA1C,GAAG,CAAC8D,KANJ,GAMS;UACZL,IAAI,EAAElE,MAAM,CAACkE,IAAD,CAAN,GAAezD,GAAG,CAAC+D,KAAnB,GAA2BN;QADrB,CANT;MADgC,GAUlCd,cAVkC,CAA1B,CAAb;IAYD;;IAED,IAAI3C,GAAG,CAACJ,MAAR,EAAgB;MACdA,MAAM,CAACoD,UAAD,EAAahD,GAAG,CAACJ,MAAjB,CAAN;IACD;;IACD,OAAOgD,UAAP;EACD,CAzDO,CApHV,CA+KE;;;EACczC,4BAAd,UAAuBC,KAAvB,EAA2CC,MAA3C,EAAoFE,SAApF,EAAqH;;;;;;;;;iBAC/G,KAAKL,QAAL;YAAA;YAAA;YACI8D,OAAO,GAAG1E,OAAO,CAAC,KAAKY,MAAN,CAAP,GAAuB,KAAKA,MAA5B,GAAqC,CAAC,KAAKA,MAAN,CAA/C;YACN;YAAA;YAAA,EAAM+D,OAAO,CAACC,GAAR,CAAYF,OAAO,CAACG,GAAR,CAAY,UAACjE,MAAD,EAA+B;cAC3D,IAAMkE,QAAQ,GAAG3E,sBAAsB,CAACJ,GAAG,CAACa,MAAD,EAAS,MAAT,EAAiB,EAAjB,CAAJ,CAAvC;cACA,IAAI,CAACkE,QAAL,EAAe;cAEf,IAAMC,WAAW,GAAG,EAApB;cACA,IAAMC,cAAc,GAAG,EAAvB;cACAlF,IAAI,CAACmB,SAAD,EAAY,UAACyC,UAAD,EAAalC,EAAb,EAAe;gBAC7BuD,WAAW,CAACE,IAAZ,CAAiBvB,UAAjB;gBACAsB,cAAc,CAACC,IAAf,CAAoBlE,MAAM,CAAC2C,UAAU,CAAC3D,GAAX,CAAe,WAAf,CAAD,CAA1B;cACD,CAHG,CAAJ,CAN2D,CAU3D;;cACA,OAAO+E,QAAQ,CAAChE,KAAD,EAAQiE,WAAR,EAAqBC,cAArB,EAAqCvC,KAAI,CAACyC,MAA1C,EAAkDtE,MAAM,CAACF,GAAzD,CAAf;YACD,CAZiB,CAAZ,CAAN;;;YAAAyE;;;;;;;;;;;EAcH,CAjBa;;EAmBNtE,mCAAR,UAAwBuE,UAAxB,EAAiDnE,SAAjD,EAA0D;IACxDnB,IAAI,CAACsF,UAAD,EAAa,UAACC,SAAD,EAAU;MACzB,IAAMjD,UAAU,GAAerC,GAAG,CAACsF,SAAD,EAAY,YAAZ,CAAlC;;MACA,IAAI,CAACA,SAAD,IAAc,CAACjD,UAAnB,EAA+B;QAC7B;MACD;;MACD,IAAMkD,MAAM,GAAGlD,UAAU,CAACmD,SAAX,EAAf;MACA,IAAMC,MAAM,GAAGpD,UAAU,CAACqD,SAAX,EAAf;;MACA,IAAI,CAACJ,SAAS,CAACK,SAAf,EAA0B;QACxB;QACA;MACD;;MACD,IAAMC,YAAY,GAAG5F,GAAG,CAACsF,SAAD,EAAY,WAAZ,EAAyB,EAAzB,CAAxB;MACA,IAAM7D,EAAE,GAAG6D,SAAS,CAAC7D,EAArB;MACA,IAAIoE,IAAI,GAAGD,YAAY,CAACC,IAAxB;;MACA,IAAI,CAACA,IAAL,EAAW;QACT,IAAMC,KAAK,GAAGxF,gBAAgB,CAACiF,MAAM,CAACrB,CAAR,EAAWqB,MAAM,CAACpB,CAAlB,EAAqBsB,MAArB,EAA6BH,SAAS,CAACS,KAAvC,CAA9B;QACAF,IAAI,GAAG,CACL,CAAC,GAAD,EAAMC,KAAK,CAAC5B,CAAZ,EAAe4B,KAAK,CAAC3B,CAArB,CADK,EAEL,CAAC,GAAD,EAAMmB,SAAS,CAACpB,CAAhB,EAAmBoB,SAAS,CAACnB,CAA7B,CAFK,CAAP;MAID;;MACD,IAAMZ,UAAU,GAAGrC,SAAS,CAACO,EAAD,CAA5B;;MACA,IAAI,CAAC8B,UAAU,CAACrB,SAAhB,EAA2B;QACzBqB,UAAU,CAACc,QAAX,CAAoB,MAApB,EAA4B;UAC1B2B,OAAO,EAAE,KADiB;UAE1B1B,KAAK;YACHuB,IAAI,MADD;YAEHI,MAAM,EAAEX,SAAS,CAACZ,KAAV,GAAkBY,SAAS,CAACZ,KAA5B,GAAoC1E,GAAG,CAACsF,SAAD,EAAY,CAAC,OAAD,EAAU,MAAV,CAAZ,EAA+B,MAA/B,CAF5C;YAGHlB,IAAI,EAAE;UAHH,GAIAwB,YAAY,CAACnB,KAJb,CAFqB;UAQ1BhD,EAAE,IARwB;UAS1Be,MAAM,EAAE8C,SAAS,CAACnC,WATQ;UAU1BhB,IAAI,EAAEmD,SAAS,CAACnD,IAVU;UAW1BE,UAAU,EAAEiD,SAAS,CAACjD;QAXI,CAA5B;MAaD;IACF,CArCG,CAAJ;EAsCD,CAvCO;EAyCR;;;;;;EAIQvB,yCAAR,UAA8BuE,UAA9B,EAAuDnE,SAAvD,EAAgE;IAC9DnB,IAAI,CAACsF,UAAD,EAAa,UAACC,SAAD,EAAU;MACzB,IAAMjD,UAAU,GAAerC,GAAG,CAACsF,SAAD,EAAY,YAAZ,CAAlC;MACA,IAAMY,UAAU,GAA4BlG,GAAG,CAACsF,SAAD,EAAY,YAAZ,CAA/C;;MACA,IAAI,CAACY,UAAD,IAAe,CAAC7D,UAApB,EAAgC;QAC9B;MACD;;MAED,IAAMZ,EAAE,GAAG6D,SAAS,CAAC7D,EAArB;MACA,IAAM8B,UAAU,GAAGrC,SAAS,CAACO,EAAD,CAA5B;;MACA,IAAI,CAAC8B,UAAU,CAACrB,SAAhB,EAA2B;QACzB,IAAMiE,iBAAiB,GAAG5C,UAAU,CAAC6C,WAAX,GAAyB,CAAzB,CAA1B;;QACA,IAAID,iBAAJ,EAAuB;UACrB,IAAMf,KAAuB/E,sBAAsB,CAACkD,UAAD,EAAa+B,SAAb,EAAwBY,UAAU,CAACG,OAAnC,CAAnD;UAAA,IAAQC,QAAQ,cAAhB;UAAA,IAAqBC,GAAG,cAAlB,YAAkB,CAAxB;;UACA,IAAMC,eAAe,GAAGjD,UAAU,CAACc,QAAX,CAAoB,MAApB,EAA4B;YAClDC,KAAK,wBACAiC,GADA,GAECL,UAAU,CAACzB,KAAX,IAAoB,EAFrB,CAD6C;YAKlDhD,EAAE,IALgD;YAMlDe,MAAM,EAAE8C,SAAS,CAACnC,WANgC;YAOlDhB,IAAI,EAAEmD,SAAS,CAACnD,IAPkC;YAQlDE,UAAU,EAAEiD,SAAS,CAACjD;UAR4B,CAA5B,CAAxB;UAUAmE,eAAe,CAACC,SAAhB,CAA0B,CAAC,CAA3B;;UAEA,IAAIH,QAAJ,EAAc;YACZ,IAAMI,MAAM,GAAGP,iBAAiB,CAACQ,SAAlB,EAAf;YACAH,eAAe,CAACI,SAAhB,CAA0BF,MAA1B;UACD;QACF;MACF;IACF,CA/BG,CAAJ;EAgCD,CAjCO;;EAmCA5F,wCAAR;IACE,IAAMF,SAAS,GAAG,KAAKA,SAAvB;IACA,IAAMiG,UAAU,GAAGjG,SAAS,CAACkG,YAAV,EAAnB,CAFF,CAE+C;;IAC7C,IAAMC,QAAQ,GAAG,IAAIF,UAAJ,CAAe,EAAf,CAAjB;IACA,OAAOE,QAAP;EACD,CALO;;EAOAjG,+BAAR,UAAoBC,KAApB,EAAwCG,SAAxC,EAAiD;IAC/CnB,IAAI,CAACgB,KAAD,EAAQ,UAACS,IAAD,EAAK;MACf,IAAIA,IAAJ,EAAU;QACR,IAAMC,EAAE,GAAGD,IAAI,CAACC,EAAhB;QACA,IAAM8B,UAAU,GAAGrC,SAAS,CAACO,EAAD,CAA5B;;QACA,IAAI,CAAC8B,UAAU,CAACrB,SAAhB,EAA2B;UACzB;UACA,IAAM8C,WAAW,GAAGzB,UAAU,CAACyD,OAAX,CAAmB,UAACC,GAAD,EAAI;YAAK,UAAG,CAACjH,GAAJ,CAAQ,MAAR,MAAoB,MAApB;UAA0B,CAAtD,CAApB;UACAD,IAAI,CAACiF,WAAD,EAAc,UAACrB,UAAD,EAAW;YAC3B,IAAIA,UAAJ,EAAgB;cACd,IAAInC,IAAI,CAAC0F,OAAT,EAAkB;gBAChBvD,UAAU,CAACd,IAAX,CAAgB,GAAhB,EAAqBc,UAAU,CAACd,IAAX,CAAgB,GAAhB,IAAuBrB,IAAI,CAAC0F,OAAjD;cACD;;cACD,IAAI1F,IAAI,CAAC2F,OAAT,EAAkB;gBAChBxD,UAAU,CAACd,IAAX,CAAgB,GAAhB,EAAqBc,UAAU,CAACd,IAAX,CAAgB,GAAhB,IAAuBrB,IAAI,CAAC2F,OAAjD;cACD;YACF;UACF,CATG,CAAJ;QAUD;MACF;IACF,CAnBG,CAAJ;EAoBD,CArBO;;EAsBV;AAAC,CAhTD","names":["deepMix","each","get","isArray","isNull","doAnimate","getGeometryLabelLayout","getLabelBackgroundInfo","polarToCartesian","rotate","translate","FIELD_ORIGIN","updateLabel","cfg","container","layout","Labels","items","shapes","isUpdate","shapesMap","offscreenGroup","createOffscreenGroup","length","items_1","items_1_1","item","id","renderLabel","doLayout","_b","renderLabelLine","renderLabelBackground","adjustLabel","lastShapesMap","shape","destroyed","data","origin_1","coordinate","currentAnimateCfg","currentShape","origin","animateCfg","_this","add","toAttrs","attr","deleteShape","remove","destroy","clear","elementId","mappingData","animate","content","shapeAppendCfg","labelGroup","addGroup","__assign","name","labelShape","isGroup","isShape","getCanvasBBox","width","height","textAlign","x","y","fill","addShape","attrs","textBaseline","text","style","color","layouts","Promise","all","map","layoutFn","labelShapes","geometryShapes","push","region","_a","labelItems","labelItem","center","getCenter","radius","getRadius","labelLine","labelLineCfg","path","start","angle","capture","stroke","background","labelContentShape","getChildren","padding","rotation","box","backgroundShape","setZIndex","matrix","getMatrix","setMatrix","GroupClass","getGroupBase","newGroup","findAll","ele","offsetX","offsetY"],"sourceRoot":"","sources":["../../src/component/labels.ts"],"sourcesContent":["import { deepMix, each, get, isArray, isNull } from '@antv/util';\nimport { BBox, Coordinate, IGroup, IShape } from '../dependents';\nimport { LabelItem } from '../geometry/label/interface';\nimport { AnimateOption, GeometryLabelLayoutCfg } from '../interface';\nimport { doAnimate } from '../animate';\nimport { getGeometryLabelLayout } from '../geometry/label';\nimport { getLabelBackgroundInfo } from '../geometry/label/util';\nimport { polarToCartesian } from '../util/graphics';\nimport { rotate, translate } from '../util/transform';\nimport { FIELD_ORIGIN } from '../constant';\nimport { updateLabel } from './update-label';\n\n/**\n * Labels 实例创建时，传入构造函数的参数定义\n */\nexport interface LabelsGroupCfg {\n  /** label 容器 */\n  container: IGroup;\n  /** label 布局配置 */\n  layout?: GeometryLabelLayoutCfg | GeometryLabelLayoutCfg[];\n}\n\n/**\n * Geometry labels 渲染组件\n */\nexport default class Labels {\n  /** 用于指定 labels 布局的类型 */\n  public layout: GeometryLabelLayoutCfg | GeometryLabelLayoutCfg[];\n  /** 图形容器 */\n  public container: IGroup;\n  /** 动画配置 */\n  public animate: AnimateOption | false;\n  /** label 绘制的区域 */\n  public region: BBox;\n\n  /** 存储当前 shape 的映射表，键值为 shape id */\n  public shapesMap: Record<string, IGroup> = {};\n\n  constructor(cfg: LabelsGroupCfg) {\n    const { layout, container } = cfg;\n\n    this.layout = layout;\n    this.container = container;\n  }\n  /**\n   * 渲染文本\n   */\n  public async render(items: LabelItem[], shapes: Record<string, IShape | IGroup>, isUpdate: boolean = false) {\n    const shapesMap = {};\n    const offscreenGroup = this.createOffscreenGroup(); // 创建虚拟分组\n    if (items.length) {\n      // 如果 items 空的话就不进行绘制调整操作\n      // step 1: 在虚拟 group 中创建 shapes\n      for (const item of items) {\n        if (item) {\n          shapesMap[item.id] = this.renderLabel(item, offscreenGroup);\n        }\n      }\n      // [todo] Move layout into Worker.\n      // step 2: 根据布局，调整 labels\n      await this.doLayout(items, shapes, shapesMap);\n\n      // step 3.1: 绘制 labelLine\n      this.renderLabelLine(items, shapesMap);\n      // step 3.2: 绘制 labelBackground\n      this.renderLabelBackground(items, shapesMap);\n      // step 4: 根据用户设置的偏移量调整 label\n      this.adjustLabel(items, shapesMap);\n    }\n\n    // 进行添加、更新、销毁操作\n    const lastShapesMap = this.shapesMap;\n    each(shapesMap, (shape, id) => {\n      if (shape.destroyed) {\n        // label 在布局调整环节被删除了（doLayout）\n        delete shapesMap[id];\n      } else {\n        if (lastShapesMap[id]) {\n          // 图形发生更新\n          const data = shape.get('data');\n          const origin = shape.get('origin');\n          const coordinate = shape.get('coordinate');\n          const currentAnimateCfg = shape.get('animateCfg');\n\n          const currentShape = lastShapesMap[id]; // 已经在渲染树上的 shape\n          updateLabel(currentShape, shapesMap[id], {\n            data,\n            origin,\n            animateCfg: currentAnimateCfg,\n            coordinate,\n          });\n\n          shapesMap[id] = currentShape; // 保存引用\n        } else {\n          // 新生成的 shape\n          // If container has been destroyed, no need to render labels.\n          if (this.container.destroyed) return;\n          this.container.add(shape);\n          const animateCfg = get(shape.get('animateCfg'), isUpdate ? 'enter' : 'appear');\n          if (animateCfg) {\n            doAnimate(shape, animateCfg, {\n              toAttrs: {\n                ...shape.attr(),\n              },\n              coordinate: shape.get('coordinate'),\n            });\n          }\n        }\n        delete lastShapesMap[id];\n      }\n    });\n\n    // 移除\n    each(lastShapesMap, (deleteShape) => {\n      const animateCfg = get(deleteShape.get('animateCfg'), 'leave');\n      if (animateCfg) {\n        doAnimate(deleteShape, animateCfg, {\n          toAttrs: null,\n          coordinate: deleteShape.get('coordinate'),\n        });\n      } else {\n        deleteShape.remove(true); // 移除\n      }\n    });\n\n    this.shapesMap = shapesMap;\n    offscreenGroup.destroy();\n  }\n\n  /** 清除当前 labels */\n  public clear() {\n    this.container.clear();\n    this.shapesMap = {};\n  }\n\n  /** 销毁 */\n  public destroy() {\n    this.container.destroy();\n    this.shapesMap = null;\n  }\n\n  private renderLabel(cfg: LabelItem, container: IGroup): IGroup {\n    const { id, elementId, data, mappingData, coordinate, animate, content } = cfg;\n    const shapeAppendCfg = {\n      id,\n      elementId,\n      data,\n      origin: {\n        ...mappingData,\n        data: mappingData[FIELD_ORIGIN],\n      },\n      coordinate,\n    };\n    const labelGroup = container.addGroup({\n      name: 'label',\n      // 如果 this.animate === false 或者 cfg.animate === false/null 则不进行动画，否则进行动画配置的合并\n      animateCfg:\n        this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate),\n      ...shapeAppendCfg,\n    });\n    let labelShape;\n    if ((content.isGroup && content.isGroup()) || (content.isShape && content.isShape())) {\n      // 如果 content 是 Group 或者 Shape，根据 textAlign 调整位置后，直接将其加入 labelGroup\n      const { width, height } = content.getCanvasBBox();\n      const textAlign = get(cfg, 'textAlign', 'left');\n\n      let x = cfg.x;\n      const y = cfg.y - height / 2;\n\n      if (textAlign === 'center') {\n        x = x - width / 2;\n      } else if (textAlign === 'right' || textAlign === 'end') {\n        x = x - width;\n      }\n\n      translate(content, x, y); // 将 label 平移至 x, y 指定的位置\n      labelShape = content;\n      labelGroup.add(content);\n    } else {\n      const fill = get(cfg, ['style', 'fill']);\n      labelShape = labelGroup.addShape('text', {\n        attrs: {\n          x: cfg.x,\n          y: cfg.y,\n          textAlign: cfg.textAlign,\n          textBaseline: get(cfg, 'textBaseline', 'middle'),\n          text: cfg.content,\n          ...cfg.style,\n          fill: isNull(fill) ? cfg.color : fill,\n        },\n        ...shapeAppendCfg,\n      });\n    }\n\n    if (cfg.rotate) {\n      rotate(labelShape, cfg.rotate);\n    }\n    return labelGroup;\n  }\n\n  // 根据type对label布局\n  private async doLayout(items: LabelItem[], shapes: Record<string, IShape | IGroup>, shapesMap: Record<string, IGroup>) {\n    if (this.layout) {\n      const layouts = isArray(this.layout) ? this.layout : [this.layout];\n      await Promise.all(layouts.map((layout: GeometryLabelLayoutCfg) => {\n        const layoutFn = getGeometryLabelLayout(get(layout, 'type', ''));\n        if (!layoutFn) return;\n\n        const labelShapes = [];\n        const geometryShapes = [];\n        each(shapesMap, (labelShape, id) => {\n          labelShapes.push(labelShape);\n          geometryShapes.push(shapes[labelShape.get('elementId')]);\n        });\n        // [todo] Refactor more layout into Worker.\n        return layoutFn(items, labelShapes, geometryShapes, this.region, layout.cfg);\n      }));\n    }\n  }\n\n  private renderLabelLine(labelItems: LabelItem[], shapesMap) {\n    each(labelItems, (labelItem) => {\n      const coordinate: Coordinate = get(labelItem, 'coordinate');\n      if (!labelItem || !coordinate) {\n        return;\n      }\n      const center = coordinate.getCenter();\n      const radius = coordinate.getRadius();\n      if (!labelItem.labelLine) {\n        // labelLine: null | false，关闭 label 对应的 labelLine\n        return;\n      }\n      const labelLineCfg = get(labelItem, 'labelLine', {});\n      const id = labelItem.id;\n      let path = labelLineCfg.path;\n      if (!path) {\n        const start = polarToCartesian(center.x, center.y, radius, labelItem.angle);\n        path = [\n          ['M', start.x, start.y],\n          ['L', labelItem.x, labelItem.y],\n        ];\n      }\n      const labelGroup = shapesMap[id];\n      if (!labelGroup.destroyed) {\n        labelGroup.addShape('path', {\n          capture: false, // labelLine 默认不参与事件捕获\n          attrs: {\n            path,\n            stroke: labelItem.color ? labelItem.color : get(labelItem, ['style', 'fill'], '#000'),\n            fill: null,\n            ...labelLineCfg.style,\n          },\n          id,\n          origin: labelItem.mappingData,\n          data: labelItem.data,\n          coordinate: labelItem.coordinate,\n        });\n      }\n    });\n  }\n\n  /**\n   * 绘制标签背景\n   * @param labelItems\n   */\n  private renderLabelBackground(labelItems: LabelItem[], shapesMap) {\n    each(labelItems, (labelItem) => {\n      const coordinate: Coordinate = get(labelItem, 'coordinate');\n      const background: LabelItem['background'] = get(labelItem, 'background');\n      if (!background || !coordinate) {\n        return;\n      }\n\n      const id = labelItem.id;\n      const labelGroup = shapesMap[id];\n      if (!labelGroup.destroyed) {\n        const labelContentShape = labelGroup.getChildren()[0];\n        if (labelContentShape) {\n          const { rotation, ...box } = getLabelBackgroundInfo(labelGroup, labelItem, background.padding);\n          const backgroundShape = labelGroup.addShape('rect', {\n            attrs: {\n              ...box,\n              ...(background.style || {}),\n            },\n            id,\n            origin: labelItem.mappingData,\n            data: labelItem.data,\n            coordinate: labelItem.coordinate,\n          });\n          backgroundShape.setZIndex(-1);\n\n          if (rotation) {\n            const matrix = labelContentShape.getMatrix();\n            backgroundShape.setMatrix(matrix);\n          }\n        }\n      }\n    });\n  }\n\n  private createOffscreenGroup() {\n    const container = this.container;\n    const GroupClass = container.getGroupBase(); // 获取分组的构造函数\n    const newGroup = new GroupClass({});\n    return newGroup;\n  }\n\n  private adjustLabel(items: LabelItem[], shapesMap) {\n    each(items, (item) => {\n      if (item) {\n        const id = item.id;\n        const labelGroup = shapesMap[id];\n        if (!labelGroup.destroyed) {\n          // fix: 如果说开发者的 label content 是一个 group，此处的偏移无法对 整个 content group 生效；场景类似 饼图 spider label 是一个含 2 个 textShape 的 gorup\n          const labelShapes = labelGroup.findAll((ele) => ele.get('type') !== 'path');\n          each(labelShapes, (labelShape) => {\n            if (labelShape) {\n              if (item.offsetX) {\n                labelShape.attr('x', labelShape.attr('x') + item.offsetX);\n              }\n              if (item.offsetY) {\n                labelShape.attr('y', labelShape.attr('y') + item.offsetY);\n              }\n            }\n          });\n        }\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}