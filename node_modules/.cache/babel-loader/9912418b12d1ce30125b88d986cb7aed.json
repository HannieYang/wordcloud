{"ast":null,"code":"import { __values } from \"tslib\";\nimport { isArray, isString } from '@antv/util';\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\n\nexport function isBetween(value, start, end) {\n  var min = Math.min(start, end);\n  var max = Math.max(start, end);\n  return value >= min && value <= max;\n}\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\n\nexport function padEnd(source, targetLength, padValue) {\n  if (isString(source)) {\n    return source.padEnd(targetLength, padValue);\n  } else if (isArray(source)) {\n    var sourceLength = source.length;\n\n    if (sourceLength < targetLength) {\n      var diff = targetLength - sourceLength;\n\n      for (var i = 0; i < diff; i++) {\n        source.push(padValue);\n      }\n    }\n  }\n\n  return source;\n}\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\n\nexport function omit(obj, keys) {\n  if (typeof obj === 'object') {\n    keys.forEach(function (key) {\n      delete obj[key];\n    });\n  }\n\n  return obj;\n}\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\n\nexport function uniq(sourceArray, targetArray, map) {\n  var e_1, _a;\n\n  if (targetArray === void 0) {\n    targetArray = [];\n  }\n\n  if (map === void 0) {\n    map = new Map();\n  }\n\n  try {\n    for (var sourceArray_1 = __values(sourceArray), sourceArray_1_1 = sourceArray_1.next(); !sourceArray_1_1.done; sourceArray_1_1 = sourceArray_1.next()) {\n      var source = sourceArray_1_1.value;\n\n      if (!map.has(source)) {\n        targetArray.push(source);\n        map.set(source, true);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (sourceArray_1_1 && !sourceArray_1_1.done && (_a = sourceArray_1.return)) _a.call(sourceArray_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return targetArray;\n}","map":{"version":3,"mappings":";AAAA,SAASA,OAAT,EAAkBC,QAAlB,QAAkC,YAAlC;AAEA;;;;;;;;;AAQA,OAAM,SAAUC,SAAV,CAAoBC,KAApB,EAAmCC,KAAnC,EAAkDC,GAAlD,EAA6D;EACjE,IAAMC,GAAG,GAAGC,IAAI,CAACD,GAAL,CAASF,KAAT,EAAgBC,GAAhB,CAAZ;EACA,IAAMG,GAAG,GAAGD,IAAI,CAACC,GAAL,CAASJ,KAAT,EAAgBC,GAAhB,CAAZ;EAEA,OAAOF,KAAK,IAAIG,GAAT,IAAgBH,KAAK,IAAIK,GAAhC;AACD;AAED;;;;;;;;;;;AAUA,OAAM,SAAUC,MAAV,CAAiBC,MAAjB,EAAyCC,YAAzC,EAA+DC,QAA/D,EAA4E;EAChF,IAAIX,QAAQ,CAACS,MAAD,CAAZ,EAAsB;IACpB,OAAOA,MAAM,CAACD,MAAP,CAAcE,YAAd,EAA4BC,QAA5B,CAAP;EACD,CAFD,MAEO,IAAIZ,OAAO,CAACU,MAAD,CAAX,EAAqB;IAC1B,IAAMG,YAAY,GAAGH,MAAM,CAACI,MAA5B;;IACA,IAAID,YAAY,GAAGF,YAAnB,EAAiC;MAC/B,IAAMI,IAAI,GAAGJ,YAAY,GAAGE,YAA5B;;MACA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,IAApB,EAA0BC,CAAC,EAA3B,EAA+B;QAC7BN,MAAM,CAACO,IAAP,CAAYL,QAAZ;MACD;IACF;EACF;;EAED,OAAOF,MAAP;AACD;AAED;;;;;;;AAMA,OAAM,SAAUQ,IAAV,CAAwBC,GAAxB,EAAgCC,IAAhC,EAA8C;EAClD,IAAI,OAAOD,GAAP,KAAe,QAAnB,EAA6B;IAC3BC,IAAI,CAACC,OAAL,CAAa,UAACC,GAAD,EAAY;MACvB,OAAOH,GAAG,CAACG,GAAD,CAAV;IACD,CAFD;EAGD;;EAED,OAAOH,GAAP;AACD;AAED;;;;;;;AAMA,OAAM,SAAUI,IAAV,CAAeC,WAAf,EAAmCC,WAAnC,EAA4DC,GAA5D,EAA8F;;;EAA3D;IAAAD;EAAuB;;EAAE;IAAAC,UAA6BC,GAA7B;EAAkC;;;IAClG,KAAqB,2CAAWC,sCAAhC,EAAgC,qBAAhC,EAAgCA,sCAAhC,EAAkC;MAA7B,IAAMlB,MAAM,wBAAZ;;MACH,IAAI,CAACgB,GAAG,CAACG,GAAJ,CAAQnB,MAAR,CAAL,EAAsB;QACpBe,WAAW,CAACR,IAAZ,CAAiBP,MAAjB;QACAgB,GAAG,CAACI,GAAJ,CAAQpB,MAAR,EAAgB,IAAhB;MACD;IACF;;;;;;;;;;;;;EACD,OAAOe,WAAP;AACD","names":["isArray","isString","isBetween","value","start","end","min","Math","max","padEnd","source","targetLength","padValue","sourceLength","length","diff","i","push","omit","obj","keys","forEach","key","uniq","sourceArray","targetArray","map","Map","sourceArray_1_1","has","set"],"sourceRoot":"","sources":["../../src/util/helper.ts"],"sourcesContent":["import { isArray, isString } from '@antv/util';\n\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\nexport function isBetween(value: number, start: number, end: number): boolean {\n  const min = Math.min(start, end);\n  const max = Math.max(start, end);\n\n  return value >= min && value <= max;\n}\n\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\nexport function padEnd(source: string | any[], targetLength: number, padValue: any) {\n  if (isString(source)) {\n    return source.padEnd(targetLength, padValue);\n  } else if (isArray(source)) {\n    const sourceLength = source.length;\n    if (sourceLength < targetLength) {\n      const diff = targetLength - sourceLength;\n      for (let i = 0; i < diff; i++) {\n        source.push(padValue);\n      }\n    }\n  }\n\n  return source;\n}\n\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\nexport function omit<T = any>(obj: T, keys: string[]): T {\n  if (typeof obj === 'object') {\n    keys.forEach((key: string) => {\n      delete obj[key];\n    });\n  }\n\n  return obj;\n}\n\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\nexport function uniq(sourceArray: any[], targetArray: any[] = [], map: Map<any, boolean> = new Map()) {\n  for (const source of sourceArray) {\n    if (!map.has(source)) {\n      targetArray.push(source);\n      map.set(source, true);\n    }\n  }\n  return targetArray;\n}\n"]},"metadata":{},"sourceType":"module"}