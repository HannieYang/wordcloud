{"ast":null,"code":"import { __read } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport { each } from '@antv/util';\nimport { getDistanceToCenter } from '../../../util/coordinate';\n\nfunction _points2path(points, isInCircle) {\n  var path = [];\n\n  if (points.length) {\n    path.push(['M', points[0].x, points[0].y]);\n\n    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {\n      var item = points[i];\n      path.push(['L', item.x, item.y]);\n    }\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n\n  return path;\n}\n\nfunction _convertArr(arr, coord) {\n  var tmp = [arr[0]];\n\n  for (var i = 1, len = arr.length; i < len; i = i + 2) {\n    var point = coord.convert({\n      x: arr[i],\n      y: arr[i + 1]\n    });\n    tmp.push(point.x, point.y);\n  }\n\n  return tmp;\n}\n\nfunction _convertArcPath(path, coord) {\n  var isTransposed = coord.isTransposed;\n  var r = path[1];\n  var x = path[6];\n  var y = path[7];\n  var point = coord.convert({\n    x: x,\n    y: y\n  });\n  var direction = isTransposed ? 0 : 1;\n  return ['A', r, r, 0, 0, direction, point.x, point.y];\n}\n\nfunction _convertPolarPath(pre, cur, coord) {\n  var isTransposed = coord.isTransposed,\n      startAngle = coord.startAngle,\n      endAngle = coord.endAngle;\n  var prePoint = pre[0].toLowerCase() === 'a' ? {\n    x: pre[6],\n    y: pre[7]\n  } : {\n    x: pre[1],\n    y: pre[2]\n  };\n  var curPoint = {\n    x: cur[1],\n    y: cur[2]\n  };\n  var rst = [];\n  var xDim = isTransposed ? 'y' : 'x';\n  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n\n  var flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n\n  var convertPoint = coord.convert(curPoint);\n  var r = getDistanceToCenter(coord, convertPoint);\n\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      var middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2\n      };\n      var middleConvertPoint = coord.convert(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n\n  return rst;\n} // 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\n\n\nfunction _filterFullCirleLine(path) {\n  each(path, function (subPath, index) {\n    var cur = subPath;\n\n    if (cur[0].toLowerCase() === 'a') {\n      var pre = path[index - 1];\n      var next = path[index + 1];\n\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\n\n\nexport var smoothBezier = function (points, smooth, isLoop, constraint) {\n  var _a;\n\n  var cps = [];\n  var hasConstraint = !!constraint;\n  var prevPoint;\n  var nextPoint;\n  var min;\n  var max;\n  var nextCp0;\n  var cp1;\n  var cp0;\n\n  if (hasConstraint) {\n    _a = __read(constraint, 2), min = _a[0], max = _a[1];\n\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      min = vec2.min([0, 0], min, point);\n      max = vec2.max([0, 0], max, point);\n    }\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (i === 0 && !isLoop) {\n      cp0 = point;\n    } else if (i === len - 1 && !isLoop) {\n      cp1 = point;\n      cps.push(cp0);\n      cps.push(cp1);\n    } else {\n      prevPoint = points[isLoop ? i ? i - 1 : len - 1 : i - 1];\n      nextPoint = points[isLoop ? (i + 1) % len : i + 1];\n      var v = [0, 0];\n      v = vec2.sub(v, nextPoint, prevPoint);\n      v = vec2.scale(v, v, smooth);\n      var d0 = vec2.distance(point, prevPoint);\n      var d1 = vec2.distance(point, nextPoint);\n      var sum = d0 + d1;\n\n      if (sum !== 0) {\n        d0 /= sum;\n        d1 /= sum;\n      }\n\n      var v1 = vec2.scale([0, 0], v, -d0);\n      var v2 = vec2.scale([0, 0], v, d1);\n      cp1 = vec2.add([0, 0], point, v1);\n      nextCp0 = vec2.add([0, 0], point, v2); // 下一个控制点必须在这个点和下一个点之间\n\n      nextCp0 = vec2.min([0, 0], nextCp0, vec2.max([0, 0], nextPoint, point));\n      nextCp0 = vec2.max([0, 0], nextCp0, vec2.min([0, 0], nextPoint, point)); // 重新计算 cp1 的值\n\n      v1 = vec2.sub([0, 0], nextCp0, point);\n      v1 = vec2.scale([0, 0], v1, -d0 / d1);\n      cp1 = vec2.add([0, 0], point, v1); // 上一个控制点必须要在上一个点和这一个点之间\n\n      cp1 = vec2.min([0, 0], cp1, vec2.max([0, 0], prevPoint, point));\n      cp1 = vec2.max([0, 0], cp1, vec2.min([0, 0], prevPoint, point)); // 重新计算 nextCp0 的值\n\n      v2 = vec2.sub([0, 0], point, cp1);\n      v2 = vec2.scale([0, 0], v2, d1 / d0);\n      nextCp0 = vec2.add([0, 0], point, v2);\n\n      if (hasConstraint) {\n        cp1 = vec2.max([0, 0], cp1, min);\n        cp1 = vec2.min([0, 0], cp1, max);\n        nextCp0 = vec2.max([0, 0], nextCp0, min);\n        nextCp0 = vec2.min([0, 0], nextCp0, max);\n      }\n\n      cps.push(cp0);\n      cps.push(cp1);\n      cp0 = nextCp0;\n    }\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n};\n/**\n * @ignore\n * 贝塞尔曲线\n */\n\nexport function catmullRom2bezier(crp, z, constraint) {\n  var isLoop = !!z;\n  var pointList = [];\n\n  for (var i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  var len = pointList.length;\n  var d1 = [];\n  var cp1;\n  var cp2;\n  var p;\n\n  for (var i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  return d1;\n}\n/**\n * @ignore\n * 将点连接成路径 path\n */\n\nexport function getLinePath(points, isInCircle) {\n  return _points2path(points, isInCircle);\n}\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\n\nexport function getSplinePath(points, isInCircle, constaint) {\n  var data = [];\n  var first = points[0];\n  var prePoint = null;\n\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points, isInCircle);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  }\n\n  var constraint = constaint || [// 范围\n  [0, 0], [1, 1]];\n  var splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}\n/**\n * @ignore\n * 将归一化后的路径数据转换成坐标\n */\n\nexport function convertNormalPath(coord, path) {\n  var tmp = [];\n  each(path, function (subPath) {\n    var action = subPath[0];\n\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'l':\n      case 'c':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  return tmp;\n}\n/**\n * @ignore\n * 将路径转换为极坐标下的真实路径\n */\n\nexport function convertPolarPath(coord, path) {\n  var tmp = [];\n  var pre;\n  var cur;\n  var transposed;\n  var equals;\n  each(path, function (subPath, index) {\n    var action = subPath[0];\n\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'c':\n      case 'q':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n\n      case 'l':\n        pre = path[index - 1];\n        cur = subPath;\n        transposed = coord.isTransposed; // 是否半径相同，转换成圆弧\n\n        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n\n        if (equals) {\n          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n        } else {\n          // y 不相等，所以直接转换\n          tmp.push(_convertArr(subPath, coord));\n        }\n\n        break;\n\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n\n  _filterFullCirleLine(tmp); // 过滤多余的直线\n\n\n  return tmp;\n}","map":{"version":3,"mappings":"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","names":["vec2","each","getDistanceToCenter","_points2path","points","isInCircle","path","length","push","x","y","i","length_1","item","_convertArr","arr","coord","tmp","len","point","convert","_convertArcPath","r","direction","isTransposed","_convertPolarPath","pre","cur","startAngle","endAngle","prePoint","toLowerCase","curPoint","rst","xDim","angleRange","Math","abs","flag","PI","convertPoint","middlePoint","middleConvertPoint","_filterFullCirleLine","subPath","index","next","smoothBezier","smooth","isLoop","constraint","cps","hasConstraint","prevPoint","nextPoint","min","max","nextCp0","cp1","cp0","_a","l","v","sub","scale","d0","distance","d1","sum","v1","v2","add","shift","catmullRom2bezier","crp","z","pointList","controlPointList","cp2","p","getLinePath","getSplinePath","constaint","data","first","splinePath","unshift","convertNormalPath","action","convertPolarPath","transposed","equals","concat"],"sourceRoot":"","sources":["../../../../src/geometry/shape/util/path.ts"],"sourcesContent":["import { vec2 } from '@antv/matrix-util';\nimport { each } from '@antv/util';\nimport { Coordinate, PathCommand } from '../../../dependents';\nimport { Point, Position } from '../../../interface';\nimport { getDistanceToCenter } from '../../../util/coordinate';\n\nfunction _points2path(points: Point[], isInCircle: boolean): PathCommand[] {\n  const path = [];\n  if (points.length) {\n    path.push(['M', points[0].x, points[0].y]);\n    for (let i = 1, length = points.length; i < length; i += 1) {\n      const item = points[i];\n      path.push(['L', item.x, item.y]);\n    }\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n\n  return path;\n}\n\nfunction _convertArr(arr: number[], coord: Coordinate): any[] {\n  const tmp = [arr[0]];\n  for (let i = 1, len = arr.length; i < len; i = i + 2) {\n    const point = coord.convert({\n      x: arr[i],\n      y: arr[i + 1],\n    });\n    tmp.push(point.x, point.y);\n  }\n  return tmp;\n}\nfunction _convertArcPath(path: PathCommand, coord: Coordinate): any[] {\n  const { isTransposed } = coord;\n  const r = path[1];\n  const x = path[6];\n  const y = path[7];\n  const point = coord.convert({ x, y });\n  const direction = isTransposed ? 0 : 1;\n  return ['A', r, r, 0, 0, direction, point.x, point.y];\n}\n\nfunction _convertPolarPath(pre: PathCommand, cur: PathCommand, coord: Coordinate): PathCommand[] {\n  const { isTransposed, startAngle, endAngle } = coord;\n  const prePoint =\n    pre[0].toLowerCase() === 'a'\n      ? {\n          x: pre[6],\n          y: pre[7],\n        }\n      : {\n          x: pre[1],\n          y: pre[2],\n        };\n  const curPoint = {\n    x: cur[1],\n    y: cur[2],\n  };\n  const rst = [];\n  const xDim = isTransposed ? 'y' : 'x';\n  const angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  const direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n  const flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n  const convertPoint = coord.convert(curPoint);\n  const r = getDistanceToCenter(coord, convertPoint);\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      const middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2,\n      };\n      const middleConvertPoint = coord.convert(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n  return rst;\n}\n\n// 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\nfunction _filterFullCirleLine(path: PathCommand[]) {\n  each(path, (subPath, index) => {\n    const cur = subPath;\n    if (cur[0].toLowerCase() === 'a') {\n      const pre = path[index - 1];\n      const next = path[index + 1];\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\nexport const smoothBezier = (\n  points: Position[],\n  smooth: number,\n  isLoop: boolean,\n  constraint: Position[]\n): Position[] => {\n  const cps = [];\n  const hasConstraint = !!constraint;\n\n  let prevPoint: Position;\n  let nextPoint: Position;\n  let min: Position;\n  let max: Position;\n  let nextCp0: Position;\n  let cp1: Position;\n  let cp0: Position;\n\n  if (hasConstraint) {\n    [min, max] = constraint;\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      min = vec2.min([0, 0], min, point) as [number, number];\n      max = vec2.max([0, 0], max, point) as [number, number];\n    }\n  }\n\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (i === 0 && !isLoop) {\n      cp0 = point;\n    } else if (i === len - 1 && !isLoop) {\n      cp1 = point;\n      cps.push(cp0);\n      cps.push(cp1);\n    } else {\n      prevPoint = points[isLoop ? (i ? i - 1 : len - 1) : i - 1];\n      nextPoint = points[isLoop ? (i + 1) % len : i + 1];\n\n      let v: [number, number] = [0, 0];\n      v = vec2.sub(v, nextPoint, prevPoint) as [number, number];\n      v = vec2.scale(v, v, smooth) as [number, number];\n\n      let d0 = vec2.distance(point, prevPoint);\n      let d1 = vec2.distance(point, nextPoint);\n\n      const sum = d0 + d1;\n      if (sum !== 0) {\n        d0 /= sum;\n        d1 /= sum;\n      }\n\n      let v1 = vec2.scale([0, 0], v, -d0);\n      let v2 = vec2.scale([0, 0], v, d1);\n\n      cp1 = vec2.add([0, 0], point, v1) as Position;\n      nextCp0 = vec2.add([0, 0], point, v2) as Position;\n\n      // 下一个控制点必须在这个点和下一个点之间\n      nextCp0 = vec2.min([0, 0], nextCp0, vec2.max([0, 0], nextPoint, point)) as Position;\n      nextCp0 = vec2.max([0, 0], nextCp0, vec2.min([0, 0], nextPoint, point)) as Position;\n\n      // 重新计算 cp1 的值\n      v1 = vec2.sub([0, 0], nextCp0, point);\n      v1 = vec2.scale([0, 0], v1, -d0 / d1);\n      cp1 = vec2.add([0, 0], point, v1) as Position;\n\n      // 上一个控制点必须要在上一个点和这一个点之间\n      cp1 = vec2.min([0, 0], cp1, vec2.max([0, 0], prevPoint, point)) as Position;\n      cp1 = vec2.max([0, 0], cp1, vec2.min([0, 0], prevPoint, point)) as Position;\n\n      // 重新计算 nextCp0 的值\n      v2 = vec2.sub([0, 0], point, cp1);\n      v2 = vec2.scale([0, 0], v2, d1 / d0);\n      nextCp0 = vec2.add([0, 0], point, v2) as Position;\n\n      if (hasConstraint) {\n        cp1 = vec2.max([0, 0], cp1, min) as Position;\n        cp1 = vec2.min([0, 0], cp1, max) as Position;\n        nextCp0 = vec2.max([0, 0], nextCp0, min) as Position;\n        nextCp0 = vec2.min([0, 0], nextCp0, max) as Position;\n      }\n\n      cps.push(cp0);\n      cps.push(cp1);\n      cp0 = nextCp0;\n    }\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n};\n\n/**\n * @ignore\n * 贝塞尔曲线\n */\nexport function catmullRom2bezier(crp: number[], z: boolean, constraint: Position[]): PathCommand[] {\n  const isLoop = !!z;\n  const pointList = [];\n  for (let i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  const controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  const len = pointList.length;\n  const d1 = [];\n\n  let cp1: Position;\n  let cp2: Position;\n  let p: Position;\n\n  for (let i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  return d1;\n}\n\n/**\n * @ignore\n * 将点连接成路径 path\n */\nexport function getLinePath(points: Point[], isInCircle?: boolean): PathCommand[] {\n  return _points2path(points, isInCircle);\n}\n\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\nexport function getSplinePath(points: Point[], isInCircle?: boolean, constaint?: Position[]): PathCommand[] {\n  const data = [];\n  const first = points[0];\n  let prePoint = null;\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points, isInCircle);\n  }\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  }\n  const constraint = constaint || [\n    // 范围\n    [0, 0],\n    [1, 1],\n  ];\n  const splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}\n\n/**\n * @ignore\n * 将归一化后的路径数据转换成坐标\n */\nexport function convertNormalPath(coord, path: PathCommand[]): PathCommand[] {\n  const tmp = [];\n  each(path, (subPath) => {\n    const action = subPath[0];\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'l':\n      case 'c':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  return tmp;\n}\n\n/**\n * @ignore\n * 将路径转换为极坐标下的真实路径\n */\nexport function convertPolarPath(coord, path: PathCommand[]): PathCommand[] {\n  let tmp = [];\n  let pre: PathCommand;\n  let cur: PathCommand;\n  let transposed: boolean;\n  let equals: boolean;\n  each(path, (subPath, index) => {\n    const action = subPath[0];\n\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'c':\n      case 'q':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'l':\n        pre = path[index - 1];\n        cur = subPath;\n        transposed = coord.isTransposed;\n        // 是否半径相同，转换成圆弧\n        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n        if (equals) {\n          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n        } else {\n          // y 不相等，所以直接转换\n          tmp.push(_convertArr(subPath, coord));\n        }\n        break;\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  _filterFullCirleLine(tmp); // 过滤多余的直线\n  return tmp;\n}\n"]},"metadata":{},"sourceType":"module"}