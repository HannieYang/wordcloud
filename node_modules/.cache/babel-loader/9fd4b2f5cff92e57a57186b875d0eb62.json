{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray, reduce, size } from '@antv/util';\nimport { getField, getAllNodes } from './util';\nvar DEFAULT_OPTIONS = {\n  field: 'value',\n  size: [1, 1],\n  round: false,\n  padding: 0,\n  // 默认降序\n  sort: function (a, b) {\n    return b.value - a.value;\n  },\n  as: ['x', 'y'],\n  // 是否忽略 parentValue, 当设置为 true 时，父节点的权重由子元素决定\n  ignoreParentValue: true\n};\nexport function partition(data, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  var as = options.as;\n\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n\n  var field;\n\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  var partition = function (data) {\n    return d3Hierarchy.partition().size(options.size).round(options.round).padding(options.padding)(\n    /**\n     * d3Hierarchy 布局中需指定 sum 函数计算 node 值，规则是：从当前 node 开始以 post-order traversal 的次序为当前节点以及每个后代节点调用指定的 value 函数，并返回当前 node。\n     * for example:\n     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}\n     * parent 所得的计算值是 sum(node(parent)) + sum(node(child1)) + sum(node(child2))\n     * sum 函数中，d 为用户传入的 data, children 为保留字段\n     */\n    d3Hierarchy.hierarchy(data).sum(function (d) {\n      return size(d.children) ? options.ignoreParentValue ? 0 : d[field] - reduce(d.children, function (a, b) {\n        return a + b[field];\n      }, 0) : d[field];\n    }).sort(options.sort));\n  };\n\n  var root = partition(data);\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n\n  var x = as[0];\n  var y = as[1];\n  root.each(function (node) {\n    var _a, _b;\n\n    node[x] = [node.x0, node.x1, node.x1, node.x0];\n    node[y] = [node.y1, node.y1, node.y0, node.y0]; // 旭日图兼容下 旧版本\n\n    node.name = node.name || ((_a = node.data) === null || _a === void 0 ? void 0 : _a.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);\n    node.data.name = node.name;\n    ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n  return getAllNodes(root);\n}","map":{"version":3,"mappings":"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","names":["d3Hierarchy","assign","isArray","reduce","size","getField","getAllNodes","DEFAULT_OPTIONS","field","round","padding","sort","a","b","value","as","ignoreParentValue","partition","data","options","length","TypeError","e","console","warn","hierarchy","sum","d","children","root","x","y","each","node","x0","x1","y1","y0","name","_a","_b","label","forEach","prop","indexOf"],"sourceRoot":"","sources":["../../../src/utils/hierarchy/partition.ts"],"sourcesContent":["import * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray, reduce, size } from '@antv/util';\nimport { getField, getAllNodes } from './util';\n\nconst DEFAULT_OPTIONS: Options = {\n  field: 'value',\n  size: [1, 1], // width, height\n  round: false,\n  padding: 0,\n  // 默认降序\n  sort: (a, b) => b.value - a.value,\n  as: ['x', 'y'],\n  // 是否忽略 parentValue, 当设置为 true 时，父节点的权重由子元素决定\n  ignoreParentValue: true,\n};\n\nexport interface Options {\n  field: string;\n  size?: [number, number];\n  round?: boolean;\n  ratio?: number;\n  padding?: number;\n  sort?: Function;\n  as?: [string, string];\n\n  ignoreParentValue?: boolean;\n}\n\nexport function partition(data: any, options: Options): any[] {\n  options = assign({} as Options, DEFAULT_OPTIONS, options);\n  const as = options.as;\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n\n  let field;\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  const partition = (data) =>\n    d3Hierarchy.partition().size(options.size).round(options.round).padding(options.padding)(\n      /**\n       * d3Hierarchy 布局中需指定 sum 函数计算 node 值，规则是：从当前 node 开始以 post-order traversal 的次序为当前节点以及每个后代节点调用指定的 value 函数，并返回当前 node。\n       * for example:\n       * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}\n       * parent 所得的计算值是 sum(node(parent)) + sum(node(child1)) + sum(node(child2))\n       * sum 函数中，d 为用户传入的 data, children 为保留字段\n       */\n      d3Hierarchy\n        .hierarchy(data)\n        .sum((d) =>\n          size(d.children)\n            ? options.ignoreParentValue\n              ? 0\n              : d[field] - reduce(d.children, (a, b) => a + b[field], 0)\n            : d[field]\n        )\n        .sort(options.sort)\n    );\n  const root = partition(data);\n\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n  const x = as[0];\n  const y = as[1];\n\n  root.each((node) => {\n    node[x] = [node.x0, node.x1, node.x1, node.x0];\n    node[y] = [node.y1, node.y1, node.y0, node.y0];\n    // 旭日图兼容下 旧版本\n    node.name = node.name || node.data?.name || node.data?.label;\n    node.data.name = node.name;\n\n    ['x0', 'x1', 'y0', 'y1'].forEach((prop) => {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n\n  return getAllNodes(root);\n}\n"]},"metadata":{},"sourceType":"module"}