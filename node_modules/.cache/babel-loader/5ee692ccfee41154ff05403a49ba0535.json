{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray } from '@antv/util';\nimport { getField, getAllNodes } from './util';\nvar DEFAULT_OPTIONS = {\n  field: 'value',\n  as: ['x', 'y', 'r'],\n  // 默认降序\n  sort: function (a, b) {\n    return b.value - a.value;\n  }\n};\nexport function pack(data, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  var as = options.as;\n\n  if (!isArray(as) || as.length !== 3) {\n    throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ \"x\", \"y\", \"r\" ])!');\n  }\n\n  var field;\n\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  var packLayout = function (data) {\n    return d3Hierarchy.pack().size(options.size).padding(options.padding)(d3Hierarchy.hierarchy(data).sum(function (d) {\n      return d[field];\n    }).sort(options.sort));\n  };\n\n  var root = packLayout(data);\n  var x = as[0];\n  var y = as[1];\n  var r = as[2];\n  root.each(function (node) {\n    node[x] = node.x;\n    node[y] = node.y;\n    node[r] = node.r;\n  });\n  return getAllNodes(root);\n}","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,WAAZ,MAA6B,cAA7B;AACA,SAASC,MAAT,EAAiBC,OAAjB,QAAgC,YAAhC;AACA,SAASC,QAAT,EAAmBC,WAAnB,QAAsC,QAAtC;AAKA,IAAMC,eAAe,GAAY;EAC/BC,KAAK,EAAE,OADwB;EAE/BC,EAAE,EAAE,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAF2B;EAG/B;EACAC,IAAI,EAAE,UAACC,CAAD,EAAIC,CAAJ,EAAK;IAAK,QAAC,CAACC,KAAF,GAAUF,CAAC,CAACE,KAAZ;EAAiB;AAJF,CAAjC;AAOA,OAAM,SAAUC,IAAV,CAAeC,IAAf,EAA0BC,OAA1B,EAA0C;EAC9CA,OAAO,GAAGb,MAAM,CAAC,EAAD,EAAgBI,eAAhB,EAAiCS,OAAjC,CAAhB;EACA,IAAMP,EAAE,GAAGO,OAAO,CAACP,EAAnB;;EACA,IAAI,CAACL,OAAO,CAACK,EAAD,CAAR,IAAgBA,EAAE,CAACQ,MAAH,KAAc,CAAlC,EAAqC;IACnC,MAAM,IAAIC,SAAJ,CAAc,0EAAd,CAAN;EACD;;EAED,IAAIV,KAAJ;;EACA,IAAI;IACFA,KAAK,GAAGH,QAAQ,CAACW,OAAD,CAAhB;EACD,CAFD,CAEE,OAAOG,CAAP,EAAU;IACVC,OAAO,CAACC,IAAR,CAAaF,CAAb;EACD;;EAED,IAAMG,UAAU,GAAG,UAACP,IAAD,EAAK;IACtB,kBAAW,CAACD,IAAZ,GAAmBS,IAAnB,CAAwBP,OAAO,CAACO,IAAhC,EAAsCC,OAAtC,CAA8CR,OAAO,CAACQ,OAAtD,EACEtB,WAAW,CACRuB,SADH,CACaV,IADb,EAEGW,GAFH,CAEO,UAACC,CAAD,EAAE;MAAK,QAAC,CAACnB,KAAD,CAAD;IAAQ,CAFtB,EAGGE,IAHH,CAGQM,OAAO,CAACN,IAHhB,CADF;EAKC,CANH;;EAQA,IAAMkB,IAAI,GAAGN,UAAU,CAACP,IAAD,CAAvB;EAEA,IAAMc,CAAC,GAAGpB,EAAE,CAAC,CAAD,CAAZ;EACA,IAAMqB,CAAC,GAAGrB,EAAE,CAAC,CAAD,CAAZ;EACA,IAAMsB,CAAC,GAAGtB,EAAE,CAAC,CAAD,CAAZ;EACAmB,IAAI,CAACI,IAAL,CAAU,UAACC,IAAD,EAAK;IACbA,IAAI,CAACJ,CAAD,CAAJ,GAAUI,IAAI,CAACJ,CAAf;IACAI,IAAI,CAACH,CAAD,CAAJ,GAAUG,IAAI,CAACH,CAAf;IACAG,IAAI,CAACF,CAAD,CAAJ,GAAUE,IAAI,CAACF,CAAf;EACD,CAJD;EAMA,OAAOzB,WAAW,CAACsB,IAAD,CAAlB;AACD","names":["d3Hierarchy","assign","isArray","getField","getAllNodes","DEFAULT_OPTIONS","field","as","sort","a","b","value","pack","data","options","length","TypeError","e","console","warn","packLayout","size","padding","hierarchy","sum","d","root","x","y","r","each","node"],"sourceRoot":"","sources":["../../../src/utils/hierarchy/pack.ts"],"sourcesContent":["import * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray } from '@antv/util';\nimport { getField, getAllNodes } from './util';\nimport { HierarchyOption } from './types';\n\ntype Options = Omit<HierarchyOption, 'as'> & { as?: [string, string, string] };\n\nconst DEFAULT_OPTIONS: Options = {\n  field: 'value',\n  as: ['x', 'y', 'r'],\n  // 默认降序\n  sort: (a, b) => b.value - a.value,\n};\n\nexport function pack(data: any, options: Options): any[] {\n  options = assign({} as Options, DEFAULT_OPTIONS, options);\n  const as = options.as;\n  if (!isArray(as) || as.length !== 3) {\n    throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ \"x\", \"y\", \"r\" ])!');\n  }\n\n  let field;\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  const packLayout = (data) =>\n    d3Hierarchy.pack().size(options.size).padding(options.padding)(\n      d3Hierarchy\n        .hierarchy(data)\n        .sum((d) => d[field])\n        .sort(options.sort)\n    );\n\n  const root = packLayout(data);\n\n  const x = as[0];\n  const y = as[1];\n  const r = as[2];\n  root.each((node) => {\n    node[x] = node.x;\n    node[y] = node.y;\n    node[r] = node.r;\n  });\n\n  return getAllNodes(root);\n}\n"]},"metadata":{},"sourceType":"module"}