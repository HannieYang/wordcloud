{"ast":null,"code":"import { __read } from \"tslib\";\nimport { ext } from '@antv/matrix-util';\n/**\n * @ignore\n * 对图形元素进行矩阵变换，同时返回变换前的图形矩阵\n * @param shape 进行矩阵变换的图形\n * @param vector 矩阵变换的中心点\n * @param direct 矩阵变换的类型\n */\n\nexport function transformShape(shape, vector, direct) {\n  var scaledMatrix;\n\n  var _a = __read(vector, 2),\n      x = _a[0],\n      y = _a[1];\n\n  shape.applyToMatrix([x, y, 1]);\n\n  if (direct === 'x') {\n    shape.setMatrix(ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 0.01, 1], ['t', x, y]]));\n    scaledMatrix = ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 100, 1], ['t', x, y]]);\n  } else if (direct === 'y') {\n    shape.setMatrix(ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 1, 0.01], ['t', x, y]]));\n    scaledMatrix = ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 1, 100], ['t', x, y]]);\n  } else if (direct === 'xy') {\n    shape.setMatrix(ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]]));\n    scaledMatrix = ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 100, 100], ['t', x, y]]);\n  }\n\n  return scaledMatrix;\n}\n/**\n * 对图形元素进行剪切动画\n * @param element 进行动画的图形元素\n * @param animateCfg 动画配置\n * @param coordinate 当前坐标系\n * @param yMinPoint y 轴的最小值对应的图形坐标点\n * @param type 剪切动画的类型\n */\n\nexport function doScaleAnimate(element, animateCfg, coordinate, yMinPoint, type) {\n  var start = coordinate.start,\n      end = coordinate.end;\n  var width = coordinate.getWidth();\n  var height = coordinate.getHeight();\n  var x;\n  var y;\n\n  if (type === 'y') {\n    x = start.x + width / 2;\n    y = yMinPoint.y < start.y ? yMinPoint.y : start.y;\n  } else if (type === 'x') {\n    x = yMinPoint.x > start.x ? yMinPoint.x : start.x;\n    y = start.y + height / 2;\n  } else if (type === 'xy') {\n    if (coordinate.isPolar) {\n      x = coordinate.getCenter().x;\n      y = coordinate.getCenter().y;\n    } else {\n      x = (start.x + end.x) / 2;\n      y = (start.y + end.y) / 2;\n    }\n  }\n\n  var endMatrix = transformShape(element, [x, y], type);\n  element.animate({\n    matrix: endMatrix\n  }, animateCfg);\n}","map":{"version":3,"mappings":"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","names":["ext","transformShape","shape","vector","direct","scaledMatrix","x","y","applyToMatrix","setMatrix","transform","getMatrix","doScaleAnimate","element","animateCfg","coordinate","yMinPoint","type","end","width","getWidth","height","getHeight","start","isPolar","getCenter","endMatrix","animate","matrix"],"sourceRoot":"","sources":["../../../src/animate/animation/util.ts"],"sourcesContent":["import { ext } from '@antv/matrix-util';\nimport { Coordinate, IGroup, IShape } from '../../dependents';\nimport { GAnimateCfg, Point } from '../../interface';\n\n/**\n * @ignore\n * 对图形元素进行矩阵变换，同时返回变换前的图形矩阵\n * @param shape 进行矩阵变换的图形\n * @param vector 矩阵变换的中心点\n * @param direct 矩阵变换的类型\n */\nexport function transformShape(shape: IShape | IGroup, vector: [number, number], direct: string): number[] {\n  let scaledMatrix;\n\n  const [x, y] = vector;\n  shape.applyToMatrix([x, y, 1]);\n  if (direct === 'x') {\n    shape.setMatrix(\n      ext.transform(shape.getMatrix(), [\n        ['t', -x, -y],\n        ['s', 0.01, 1],\n        ['t', x, y],\n      ])\n    );\n    scaledMatrix = ext.transform(shape.getMatrix(), [\n      ['t', -x, -y],\n      ['s', 100, 1],\n      ['t', x, y],\n    ]);\n  } else if (direct === 'y') {\n    shape.setMatrix(\n      ext.transform(shape.getMatrix(), [\n        ['t', -x, -y],\n        ['s', 1, 0.01],\n        ['t', x, y],\n      ])\n    );\n    scaledMatrix = ext.transform(shape.getMatrix(), [\n      ['t', -x, -y],\n      ['s', 1, 100],\n      ['t', x, y],\n    ]);\n  } else if (direct === 'xy') {\n    shape.setMatrix(\n      ext.transform(shape.getMatrix(), [\n        ['t', -x, -y],\n        ['s', 0.01, 0.01],\n        ['t', x, y],\n      ])\n    );\n    scaledMatrix = ext.transform(shape.getMatrix(), [\n      ['t', -x, -y],\n      ['s', 100, 100],\n      ['t', x, y],\n    ]);\n  }\n  return scaledMatrix;\n}\n\n/**\n * 对图形元素进行剪切动画\n * @param element 进行动画的图形元素\n * @param animateCfg 动画配置\n * @param coordinate 当前坐标系\n * @param yMinPoint y 轴的最小值对应的图形坐标点\n * @param type 剪切动画的类型\n */\nexport function doScaleAnimate(\n  element: IGroup | IShape,\n  animateCfg: GAnimateCfg,\n  coordinate: Coordinate,\n  yMinPoint: Point,\n  type: string\n) {\n  const { start, end } = coordinate;\n  const width = coordinate.getWidth();\n  const height = coordinate.getHeight();\n  let x: number;\n  let y: number;\n\n  if (type === 'y') {\n    x = start.x + width / 2;\n    y = yMinPoint.y < start.y ? yMinPoint.y : start.y;\n  } else if (type === 'x') {\n    x = yMinPoint.x > start.x ? yMinPoint.x : start.x;\n    y = start.y + height / 2;\n  } else if (type === 'xy') {\n    if (coordinate.isPolar) {\n      x = coordinate.getCenter().x;\n      y = coordinate.getCenter().y;\n    } else {\n      x = (start.x + end.x) / 2;\n      y = (start.y + end.y) / 2;\n    }\n  }\n\n  const endMatrix = transformShape(element, [x, y], type);\n  element.animate(\n    {\n      matrix: endMatrix,\n    },\n    animateCfg\n  );\n}\n"]},"metadata":{},"sourceType":"module"}