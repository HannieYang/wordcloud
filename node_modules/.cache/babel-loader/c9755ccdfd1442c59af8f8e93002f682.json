{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { each, get, isArray, map, isNumber, isString } from '@antv/util';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nvar HALF_PI = Math.PI / 2;\n/**\n * 极坐标下的图形 label\n */\n\nvar PolarLabel =\n/** @class */\nfunction (_super) {\n  __extends(PolarLabel, _super);\n\n  function PolarLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @override\n   * @desc 获取 label offset\n   * polar & theta coordinate support「string」type, should transform to 「number」\n   */\n\n\n  PolarLabel.prototype.getLabelOffset = function (offset) {\n    var coordinate = this.getCoordinate();\n    var actualOffset = 0;\n\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } else if (isString(offset) && offset.indexOf('%') !== -1) {\n      var r = coordinate.getRadius();\n\n      if (coordinate.innerRadius > 0) {\n        r = r * (1 - coordinate.innerRadius);\n      }\n\n      actualOffset = parseFloat(offset) * 0.01 * r;\n    }\n\n    return actualOffset;\n  };\n  /**\n   * @override\n   * 获取 labelItems, 增加切片 percent\n   * @param mapppingArray\n   */\n\n\n  PolarLabel.prototype.getLabelItems = function (mapppingArray) {\n    var items = _super.prototype.getLabelItems.call(this, mapppingArray);\n\n    var yScale = this.geometry.getYScale();\n    return map(items, function (item) {\n      if (item && yScale) {\n        var percent = yScale.scale(get(item.data, yScale.field));\n        return __assign(__assign({}, item), {\n          percent: percent\n        });\n      }\n\n      return item;\n    });\n  };\n  /**\n   * @override\n   * 获取文本的对齐方式\n   * @param point\n   */\n\n\n  PolarLabel.prototype.getLabelAlign = function (point) {\n    var coordinate = this.getCoordinate();\n    var align;\n\n    if (point.labelEmit) {\n      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n    } else if (!coordinate.isTransposed) {\n      align = 'center';\n    } else {\n      var center = coordinate.getCenter();\n      var offset = point.offset;\n\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        align = offset > 0 ? 'left' : 'right';\n      } else {\n        align = offset > 0 ? 'right' : 'left';\n      }\n    }\n\n    return align;\n  };\n  /**\n   * @override\n   * 获取 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   */\n\n\n  PolarLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n    var factor = 1;\n    var arcPoint;\n    var content = labelCfg.content[index];\n\n    if (this.isToMiddle(mappingData)) {\n      arcPoint = this.getMiddlePoint(mappingData.points);\n    } else {\n      if (labelCfg.content.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n\n      arcPoint = this.getArcPoint(mappingData, index);\n    }\n\n    var offset = labelCfg.offset * factor;\n    var middleAngle = this.getPointAngle(arcPoint);\n    var isLabelEmit = labelCfg.labelEmit;\n    var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n\n    if (labelPositionCfg.r === 0) {\n      // 如果文本位置位于圆心，则不展示\n      labelPositionCfg.content = '';\n    } else {\n      labelPositionCfg.content = content;\n      labelPositionCfg.angle = middleAngle;\n      labelPositionCfg.color = mappingData.color;\n    }\n\n    labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;\n    labelPositionCfg.start = {\n      x: arcPoint.x,\n      y: arcPoint.y\n    };\n    return labelPositionCfg;\n  };\n  /**\n   * 获取圆弧的位置\n   */\n\n\n  PolarLabel.prototype.getArcPoint = function (mappingData, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n      return {\n        x: mappingData.x,\n        y: mappingData.y\n      };\n    }\n\n    return {\n      x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n      y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y\n    };\n  };\n  /**\n   * 计算坐标线点在极坐标系下角度\n   * @param point\n   */\n\n\n  PolarLabel.prototype.getPointAngle = function (point) {\n    return getAngleByPoint(this.getCoordinate(), point);\n  };\n  /**\n   * 获取坐标点与圆心形成的圆的位置信息\n   * @param angle\n   * @param offset\n   * @param point\n   * @param isLabelEmit\n   */\n\n\n  PolarLabel.prototype.getCirclePoint = function (angle, offset, point, isLabelEmit) {\n    var coordinate = this.getCoordinate();\n    var center = coordinate.getCenter();\n    var r = getDistanceToCenter(coordinate, point);\n\n    if (r === 0) {\n      return __assign(__assign({}, center), {\n        r: r\n      });\n    }\n\n    var labelAngle = angle;\n\n    if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n      var appendAngle = Math.asin(offset / (2 * r));\n      labelAngle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n\n    return {\n      x: center.x + r * Math.cos(labelAngle),\n      y: center.y + r * Math.sin(labelAngle),\n      r: r\n    };\n  };\n  /**\n   * 获取 label 的旋转角度\n   * @param angle\n   * @param offset\n   * @param isLabelEmit\n   */\n\n\n  PolarLabel.prototype.getLabelRotate = function (angle, offset, isLabelEmit) {\n    var rotate = angle + HALF_PI;\n\n    if (isLabelEmit) {\n      rotate -= HALF_PI;\n    }\n\n    if (rotate) {\n      if (rotate > HALF_PI) {\n        rotate = rotate - Math.PI;\n      } else if (rotate < -HALF_PI) {\n        rotate = rotate + Math.PI;\n      }\n    }\n\n    return rotate;\n  }; // 获取中心的位置\n\n\n  PolarLabel.prototype.getMiddlePoint = function (points) {\n    var coordinate = this.getCoordinate();\n    var count = points.length;\n    var middlePoint = {\n      x: 0,\n      y: 0\n    };\n    each(points, function (point) {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n    middlePoint = coordinate.convert(middlePoint);\n    return middlePoint;\n  }; // 是否居中\n\n\n  PolarLabel.prototype.isToMiddle = function (mappingData) {\n    return mappingData.x.length > 2;\n  };\n\n  return PolarLabel;\n}(GeometryLabel);\n\nexport default PolarLabel;","map":{"version":3,"mappings":"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","names":["each","get","isArray","map","isNumber","isString","getDistanceToCenter","getAngleByPoint","GeometryLabel","HALF_PI","Math","PI","__extends","PolarLabel","offset","coordinate","getCoordinate","actualOffset","indexOf","r","getRadius","innerRadius","parseFloat","mapppingArray","items","_super","getLabelItems","call","yScale","geometry","getYScale","item","percent","scale","data","field","point","align","labelEmit","angle","isTransposed","center","getCenter","abs","x","labelCfg","mappingData","index","factor","arcPoint","content","isToMiddle","getMiddlePoint","points","length","getArcPoint","middleAngle","getPointAngle","isLabelEmit","labelPositionCfg","getCirclePoint","color","rotate","autoRotate","getLabelRotate","start","y","labelAngle","appendAngle","asin","cos","sin","count","middlePoint","convert"],"sourceRoot":"","sources":["../../../src/geometry/label/polar.ts"],"sourcesContent":["import { each, get, isArray, map, isNumber, isString } from '@antv/util';\nimport { MappingDatum, Point } from '../../interface';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nimport { LabelCfg, LabelItem, PolarLabelItem, LabelPointCfg, Writeable } from './interface';\n\nconst HALF_PI = Math.PI / 2;\n\n/**\n * 极坐标下的图形 label\n */\nexport default class PolarLabel extends GeometryLabel {\n  /**\n   * @override\n   * @desc 获取 label offset\n   * polar & theta coordinate support「string」type, should transform to 「number」\n   */\n  protected getLabelOffset(offset: number | string): number {\n    const coordinate = this.getCoordinate();\n    let actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } else if (isString(offset) && offset.indexOf('%') !== -1) {\n      let r = coordinate.getRadius();\n      if (coordinate.innerRadius > 0) {\n        r = r * (1 - coordinate.innerRadius);\n      }\n      actualOffset = parseFloat(offset) * 0.01 * r;\n    }\n\n    return actualOffset;\n  }\n\n  /**\n   * @override\n   * 获取 labelItems, 增加切片 percent\n   * @param mapppingArray\n   */\n  public getLabelItems(mapppingArray: MappingDatum[]): PolarLabelItem[] {\n    const items = super.getLabelItems(mapppingArray);\n    const yScale = this.geometry.getYScale();\n\n    return map(items, (item) => {\n      if (item && yScale) {\n        const percent = yScale.scale(get(item.data, yScale.field));\n        return { ...item, percent };\n      }\n      return item;\n    });\n  }\n  /**\n   * @override\n   * 获取文本的对齐方式\n   * @param point\n   */\n  protected getLabelAlign(point: LabelItem) {\n    const coordinate = this.getCoordinate();\n    let align;\n    if (point.labelEmit) {\n      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n    } else if (!coordinate.isTransposed) {\n      align = 'center';\n    } else {\n      const center = coordinate.getCenter();\n      const offset = point.offset;\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        align = offset > 0 ? 'left' : 'right';\n      } else {\n        align = offset > 0 ? 'right' : 'left';\n      }\n    }\n    return align;\n  }\n\n  /**\n   * @override\n   * 获取 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    let factor = 1;\n    let arcPoint;\n    const content = labelCfg.content[index];\n    if (this.isToMiddle(mappingData)) {\n      arcPoint = this.getMiddlePoint(mappingData.points as Point[]);\n    } else {\n      if (labelCfg.content.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n      arcPoint = this.getArcPoint(mappingData, index);\n    }\n\n    const offset = labelCfg.offset * factor;\n    const middleAngle = this.getPointAngle(arcPoint);\n    const isLabelEmit = labelCfg.labelEmit;\n    const labelPositionCfg: Writeable<LabelPointCfg> = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n    if (labelPositionCfg.r === 0) {\n      // 如果文本位置位于圆心，则不展示\n      labelPositionCfg.content = '';\n    } else {\n      labelPositionCfg.content = content;\n      labelPositionCfg.angle = middleAngle;\n      labelPositionCfg.color = mappingData.color;\n    }\n\n    labelPositionCfg.rotate = labelCfg.autoRotate\n      ? this.getLabelRotate(middleAngle, offset, isLabelEmit)\n      : labelCfg.rotate;\n    labelPositionCfg.start = {\n      x: arcPoint.x,\n      y: arcPoint.y,\n    };\n    return labelPositionCfg;\n  }\n\n  /**\n   * 获取圆弧的位置\n   */\n  protected getArcPoint(mappingData: MappingDatum, index: number = 0): Point {\n    if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n      return {\n        x: mappingData.x,\n        y: mappingData.y,\n      };\n    }\n\n    return {\n      x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n      y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y,\n    };\n  }\n\n  /**\n   * 计算坐标线点在极坐标系下角度\n   * @param point\n   */\n  protected getPointAngle(point: Point): number {\n    return getAngleByPoint(this.getCoordinate(), point);\n  }\n\n  /**\n   * 获取坐标点与圆心形成的圆的位置信息\n   * @param angle\n   * @param offset\n   * @param point\n   * @param isLabelEmit\n   */\n  protected getCirclePoint(angle: number, offset: number, point: Point, isLabelEmit: boolean) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n    let r = getDistanceToCenter(coordinate, point);\n    if (r === 0) {\n      return {\n        ...center,\n        r,\n      };\n    }\n\n    let labelAngle = angle;\n    if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n      const appendAngle = Math.asin(offset / (2 * r));\n      labelAngle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n\n    return {\n      x: center.x + r * Math.cos(labelAngle),\n      y: center.y + r * Math.sin(labelAngle),\n      r,\n    };\n  }\n\n  /**\n   * 获取 label 的旋转角度\n   * @param angle\n   * @param offset\n   * @param isLabelEmit\n   */\n  protected getLabelRotate(angle: number, offset: number, isLabelEmit: boolean) {\n    let rotate = angle + HALF_PI;\n    if (isLabelEmit) {\n      rotate -= HALF_PI;\n    }\n    if (rotate) {\n      if (rotate > HALF_PI) {\n        rotate = rotate - Math.PI;\n      } else if (rotate < -HALF_PI) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  }\n\n  // 获取中心的位置\n  private getMiddlePoint(points: Point[]) {\n    const coordinate = this.getCoordinate();\n    const count = points.length;\n    let middlePoint = {\n      x: 0,\n      y: 0,\n    };\n    each(points, (point: Point) => {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n\n    middlePoint = coordinate.convert(middlePoint);\n    return middlePoint;\n  }\n\n  // 是否居中\n  private isToMiddle(mappingData: MappingDatum) {\n    return (mappingData.x as number[]).length > 2;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}