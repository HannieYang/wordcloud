{"ast":null,"code":"var onmessage = function (e) {\n  // Copy from src/util/collision-detect.ts\n  function generateUtils() {\n    function dot(a, b) {\n      return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n    }\n    /**\n     * 1. 获取投影轴\n     */\n\n\n    function getAxes(points\n    /** 多边形的关键点 */\n    ) {\n      // 目前先处理 平行矩形 的场景, 其他多边形不处理\n      if (points.length > 4) {\n        return [];\n      } // 获取向量\n\n\n      var vector = function (start, end) {\n        return [end.x - start.x, end.y - start.y];\n      }; // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n\n\n      var AB = vector(points[0], points[1]);\n      var BC = vector(points[1], points[2]);\n      return [AB, BC];\n    }\n    /**\n     * 绕指定点顺时针旋转后的点坐标\n     * 默认绕原点旋转\n     */\n\n\n    function rotateAtPoint(point, deg, origin) {\n      if (deg === void 0) {\n        deg = 0;\n      }\n\n      if (origin === void 0) {\n        origin = {\n          x: 0,\n          y: 0\n        };\n      }\n\n      var x = point.x,\n          y = point.y;\n      return {\n        x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n        y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y\n      };\n    }\n    /**\n     * @private\n     * 转化为顶点坐标数组\n     *\n     * @param {Object} box\n     */\n\n\n    function getRectPoints(box) {\n      var points = [{\n        x: box.x,\n        y: box.y\n      }, {\n        x: box.x + box.width,\n        y: box.y\n      }, {\n        x: box.x + box.width,\n        y: box.y + box.height\n      }, {\n        x: box.x,\n        y: box.y + box.height\n      }];\n      var rotation = box.rotation;\n\n      if (rotation) {\n        return [rotateAtPoint(points[0], rotation, points[0]), rotateAtPoint(points[1], rotation, points[0]), rotateAtPoint(points[2], rotation, points[0]), rotateAtPoint(points[3], rotation, points[0])];\n      }\n\n      return points;\n    }\n    /**\n     * 2. 获取多边形在投影轴上的投影\n     *\n     * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n     * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n     */\n\n\n    function getProjection(points\n    /** 多边形的关键点 */\n    , axis) {\n      // 目前先处理矩形的场景\n      if (points.length > 4) {\n        return {\n          min: 0,\n          max: 0\n        };\n      }\n\n      var scalars = [];\n      points.forEach(function (point) {\n        scalars.push(dot([point.x, point.y], axis));\n      });\n      return {\n        min: Math.min.apply(null, scalars),\n        max: Math.max.apply(null, scalars)\n      };\n    }\n\n    function isProjectionOverlap(projection1, projection2) {\n      return projection1.max > projection2.min && projection1.min < projection2.max;\n    }\n\n    function isValidNumber(d) {\n      return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n    }\n\n    function isValidBox(box) {\n      return ['x', 'y', 'width', 'height'].every(function (attr) {\n        return isValidNumber(box[attr]);\n      });\n    }\n\n    function isIntersectRect(box1, box2, margin) {\n      if (margin === void 0) {\n        margin = 0;\n      }\n\n      return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);\n    }\n\n    function intersect(box1, box2, margin) {\n      if (margin === void 0) {\n        margin = 0;\n      }\n\n      if (!isValidBox(box1) || !isValidBox(box2)) return false; // Quick detect, if rotation is null or zero.\n\n      if (!box1.rotation && !box2.rotation) {\n        return isIntersectRect(box1, box2, margin);\n      } // 分别获取 4 个关键点\n\n\n      var rect1Points = getRectPoints(box1);\n      var rect2Points = getRectPoints(box2); // 获取所有投影轴\n\n      var axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n\n      for (var i = 0; i < axes.length; i++) {\n        var axis = axes[i];\n        var projection1 = getProjection(rect1Points, axis);\n        var projection2 = getProjection(rect2Points, axis);\n        if (!isProjectionOverlap(projection1, projection2)) return false;\n      }\n\n      return true;\n    }\n\n    return {\n      intersect: intersect\n    };\n  }\n\n  var intersect = generateUtils().intersect; // Label layouts.\n\n  function hideOverlap(items) {\n    var boxes = items.slice();\n\n    for (var i = 0; i < boxes.length; i++) {\n      var box1 = boxes[i];\n\n      if (box1.visible) {\n        for (var j = i + 1; j < boxes.length; j++) {\n          var box2 = boxes[j];\n\n          if (box1 !== box2 && box2.visible) {\n            if (intersect(box1, box2)) {\n              box2.visible = false;\n            }\n          }\n        }\n      }\n    }\n\n    return boxes;\n  }\n\n  var methods = {\n    'hide-overlap': hideOverlap\n  }; // Main\n\n  try {\n    var eventData = JSON.parse(e.data);\n    if (!eventData || !eventData.type || !methods[eventData.type]) return;\n    var type = eventData.type,\n        items = eventData.items;\n    var result = methods[type](items);\n    self.postMessage(result);\n  } catch (e) {\n    throw e;\n  }\n};\n\nvar code = \"\\n   self.onmessage = \".concat(onmessage.toString(), \"\\n\");\nexport { code };","map":{"version":3,"mappings":"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","names":["onmessage","e","generateUtils","dot","a","b","getAxes","points","length","vector","start","end","x","y","AB","BC","rotateAtPoint","point","deg","origin","Math","cos","sin","getRectPoints","box","width","height","rotation","getProjection","axis","min","max","scalars","forEach","push","apply","isProjectionOverlap","projection1","projection2","isValidNumber","d","Number","isNaN","Infinity","isValidBox","every","attr","isIntersectRect","box1","box2","margin","intersect","rect1Points","rect2Points","axes","concat","i","hideOverlap","items","boxes","slice","visible","j","methods","eventData","JSON","parse","data","type","result","self","postMessage","code","toString"],"sourceRoot":"","sources":["../../../../../src/geometry/label/layout/worker/hide-overlap.ts"],"sourcesContent":["const onmessage = function (e) {\n  type Item = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    rotation?: number;\n    visible?: boolean;\n  };\n\n  // Copy from src/util/collision-detect.ts\n  function generateUtils() {\n    type Vec2 = [number, number];\n\n    type Point = { x: number; y: number };\n\n    /**\n     * 定义投影对象\n     */\n    type Projection = { min: number; max: number };\n\n    function dot(a, b) {\n      return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n    }\n    /**\n     * 1. 获取投影轴\n     */\n    function getAxes(points: Point[] /** 多边形的关键点 */): Vec2[] {\n      // 目前先处理 平行矩形 的场景, 其他多边形不处理\n      if (points.length > 4) {\n        return [];\n      }\n      // 获取向量\n      const vector = (start: Point, end: Point): Vec2 => {\n        return [end.x - start.x, end.y - start.y];\n      };\n\n      // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n      const AB = vector(points[0], points[1]);\n      const BC = vector(points[1], points[2]);\n\n      return [AB, BC];\n    }\n\n    /**\n     * 绕指定点顺时针旋转后的点坐标\n     * 默认绕原点旋转\n     */\n    function rotateAtPoint(point: Point, deg = 0, origin = { x: 0, y: 0 }): Point {\n      const { x, y } = point;\n      return {\n        x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n        y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y,\n      };\n    }\n\n    /**\n     * @private\n     * 转化为顶点坐标数组\n     *\n     * @param {Object} box\n     */\n    function getRectPoints(box: Item): Point[] {\n      const points = [\n        { x: box.x, y: box.y },\n        { x: box.x + box.width, y: box.y },\n        { x: box.x + box.width, y: box.y + box.height },\n        { x: box.x, y: box.y + box.height },\n      ];\n\n      const rotation = box.rotation;\n      if (rotation) {\n        return [\n          rotateAtPoint(points[0], rotation, points[0]),\n          rotateAtPoint(points[1], rotation, points[0]),\n          rotateAtPoint(points[2], rotation, points[0]),\n          rotateAtPoint(points[3], rotation, points[0]),\n        ];\n      }\n\n      return points;\n    }\n\n    /**\n     * 2. 获取多边形在投影轴上的投影\n     *\n     * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n     * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n     */\n    function getProjection(points: Point[] /** 多边形的关键点 */, axis: Vec2): Projection {\n      // 目前先处理矩形的场景\n      if (points.length > 4) {\n        return { min: 0, max: 0 };\n      }\n\n      const scalars = [];\n      points.forEach((point) => {\n        scalars.push(dot([point.x, point.y], axis));\n      });\n\n      return { min: Math.min.apply(null, scalars), max: Math.max.apply(null, scalars) };\n    }\n\n    function isProjectionOverlap(projection1: Projection, projection2: Projection): boolean {\n      return projection1.max > projection2.min && projection1.min < projection2.max;\n    }\n\n    function isValidNumber(d: number) {\n      return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n    }\n\n    function isValidBox(box: Item) {\n      return ['x', 'y', 'width', 'height'].every(attr => isValidNumber(box[attr]))\n    }\n\n    function isIntersectRect(box1: Item, box2: Item, margin: number = 0): boolean {\n      return !(\n        box2.x > box1.x + box1.width + margin ||\n        box2.x + box2.width < box1.x - margin ||\n        box2.y > box1.y + box1.height + margin ||\n        box2.y + box2.height < box1.y - margin\n      );\n    }\n    function intersect(box1: Item, box2: Item, margin: number = 0) {\n      if (!isValidBox(box1) || !isValidBox(box2)) return false;\n\n      // Quick detect, if rotation is null or zero.\n      if (!box1.rotation && !box2.rotation) {\n        return isIntersectRect(box1, box2, margin);\n      }\n\n      // 分别获取 4 个关键点\n      const rect1Points = getRectPoints(box1);\n      const rect2Points = getRectPoints(box2);\n\n      // 获取所有投影轴\n      const axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n\n      for (let i = 0; i < axes.length; i++) {\n        const axis = axes[i];\n        const projection1 = getProjection(rect1Points, axis);\n        const projection2 = getProjection(rect2Points, axis);\n\n        if (!isProjectionOverlap(projection1, projection2)) return false;\n      }\n\n      return true;\n    }\n    return { intersect }\n  }\n  const { intersect } = generateUtils();\n\n  // Label layouts.\n  function hideOverlap(items: Item[]) {\n    const boxes = items.slice();\n    for (let i = 0; i < boxes.length; i++) {\n      const box1 = boxes[i];\n      if (box1.visible) {\n        for (let j = i + 1; j < boxes.length; j++) {\n          const box2 = boxes[j];\n          if (box1 !== box2 && box2.visible) {\n            if (intersect(box1, box2)) {\n              box2.visible = false;\n            }\n          }\n        }\n      }\n    }\n    return boxes;\n  }\n\n  const methods = {\n    'hide-overlap': hideOverlap,\n  }\n\n  // Main\n  try {\n    const eventData = JSON.parse(e.data);\n    if (!eventData || !eventData.type || !methods[eventData.type]) return;\n\n    const { type, items } = eventData;\n    const result = methods[type](items);\n    self.postMessage(result);\n  } catch (e) {\n    throw e;\n  }\n}\n\nconst code = `\n   self.onmessage = ${onmessage.toString()}\n`\nexport { code };\n"]},"metadata":{},"sourceType":"module"}