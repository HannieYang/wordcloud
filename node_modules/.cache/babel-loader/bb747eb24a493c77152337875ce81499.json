{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { __assign, __extends, __read, __rest, __values } from \"tslib\";\nimport { contains, deepMix, each, get, isArray, isFunction, isNil, isString, keys, upperFirst, find, includes } from '@antv/util';\nimport { Annotation as AnnotationComponent } from '../../dependents';\nimport { DEFAULT_ANIMATE_CFG } from '../../animate/';\nimport { COMPONENT_TYPE, DIRECTION, GEOMETRY_LIFE_CIRCLE, LAYER, VIEW_LIFE_CIRCLE } from '../../constant';\nimport { getAngleByPoint, getDistanceToCenter } from '../../util/coordinate';\nimport { omit } from '../../util/helper';\nimport { getNormalizedValue } from '../../util/annotation';\nimport { Controller } from './base';\n/** 需要在图形绘制完成后才渲染的辅助组件类型列表 */\n\nvar ANNOTATIONS_AFTER_RENDER = ['regionFilter', 'shape'];\n/**\n * Annotation controller, 主要作用:\n * 1. 创建 Annotation: line、text、arc ...\n * 2. 生命周期: init、layout、render、clear、destroy\n */\n\nvar Annotation =\n/** @class */\nfunction (_super) {\n  __extends(Annotation, _super);\n\n  function Annotation(view) {\n    var _this = _super.call(this, view) || this;\n    /* 组件更新的 cache，组件配置 object : 组件 */\n\n\n    _this.cache = new Map();\n    _this.foregroundContainer = _this.view.getLayer(LAYER.FORE).addGroup();\n    _this.backgroundContainer = _this.view.getLayer(LAYER.BG).addGroup();\n    _this.option = [];\n    return _this;\n  }\n\n  Object.defineProperty(Annotation.prototype, \"name\", {\n    get: function () {\n      return 'annotation';\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Annotation.prototype.init = function () {};\n  /**\n   * 因为 annotation 需要依赖坐标系信息，所以 render 阶段为空方法，实际的创建逻辑都在 layout 中\n   */\n\n\n  Annotation.prototype.layout = function () {\n    this.update();\n  }; // 因为 Annotation 不参与布局，但是渲染的位置依赖于坐标系，所以可以将绘制阶段延迟到 layout() 进行\n\n\n  Annotation.prototype.render = function () {};\n  /**\n   * 更新\n   */\n\n\n  Annotation.prototype.update = function () {\n    var _this = this; // 1. 先处理需要在图形渲染之后的辅助组件 需要在 Geometry 完成之后，拿到图形信息\n\n\n    this.onAfterRender(function () {\n      var updated = new Map(); // 先看是否有 regionFilter/shape 要更新\n\n      each(_this.option, function (option) {\n        if (includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n          var co = _this.updateOrCreate(option); // 存储已经处理过的\n\n\n          if (co) {\n            updated.set(_this.getCacheKey(option), co);\n          }\n        }\n      }); // 处理完成之后，更新 cache\n      // 处理完成之后，销毁删除的\n\n      _this.cache = _this.syncCache(updated);\n    }); // 2. 处理非 regionFilter\n\n    var updateCache = new Map();\n    each(this.option, function (option) {\n      if (!includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n        var co = _this.updateOrCreate(option); // 存储已经处理过的\n\n\n        if (co) {\n          updateCache.set(_this.getCacheKey(option), co);\n        }\n      }\n    });\n    this.cache = this.syncCache(updateCache);\n  };\n  /**\n   * 清空\n   * @param includeOption 是否清空 option 配置项\n   */\n\n\n  Annotation.prototype.clear = function (includeOption) {\n    if (includeOption === void 0) {\n      includeOption = false;\n    }\n\n    _super.prototype.clear.call(this);\n\n    this.clearComponents();\n    this.foregroundContainer.clear();\n    this.backgroundContainer.clear(); // clear all option\n\n    if (includeOption) {\n      this.option = [];\n    }\n  };\n\n  Annotation.prototype.destroy = function () {\n    this.clear(true);\n    this.foregroundContainer.remove(true);\n    this.backgroundContainer.remove(true);\n  };\n  /**\n   * 复写基类的方法\n   */\n\n\n  Annotation.prototype.getComponents = function () {\n    var co = [];\n    this.cache.forEach(function (value) {\n      co.push(value);\n    });\n    return co;\n  };\n  /**\n   * 清除当前的组件\n   */\n\n\n  Annotation.prototype.clearComponents = function () {\n    this.getComponents().forEach(function (co) {\n      co.component.destroy();\n    });\n    this.cache.clear();\n  };\n  /**\n   * region filter 比较特殊的渲染时机\n   * @param doWhat\n   */\n\n\n  Annotation.prototype.onAfterRender = function (doWhat) {\n    if (this.view.getOptions().animate) {\n      this.view.geometries.forEach(function (g) {\n        // 如果 geometry 开启，则监听\n        if (g.animateOption) {\n          g.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function () {\n            doWhat();\n          });\n        }\n      });\n    } else {\n      this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, function () {\n        doWhat();\n      });\n    }\n  };\n\n  Annotation.prototype.createAnnotation = function (option) {\n    var type = option.type;\n    var Ctor = AnnotationComponent[upperFirst(type)];\n\n    if (Ctor) {\n      var theme = this.getAnnotationTheme(type);\n      var cfg = this.getAnnotationCfg(type, option, theme); // 不创建\n\n      if (!cfg) {\n        return null;\n      }\n\n      var annotation = new Ctor(cfg);\n      return {\n        component: annotation,\n        layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.ANNOTATION,\n        extra: option\n      };\n    }\n  }; // APIs for creating annotation component\n\n\n  Annotation.prototype.annotation = function (option) {\n    this.option.push(option);\n  };\n  /**\n   * 创建 Arc\n   * @param option\n   * @returns AnnotationController\n   */\n\n\n  Annotation.prototype.arc = function (option) {\n    this.annotation(__assign({\n      type: 'arc'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 image\n   * @param option\n   * @returns AnnotationController\n   */\n\n\n  Annotation.prototype.image = function (option) {\n    this.annotation(__assign({\n      type: 'image'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 Line\n   * @param option\n   * @returns AnnotationController\n   */\n\n\n  Annotation.prototype.line = function (option) {\n    this.annotation(__assign({\n      type: 'line'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 Region\n   * @param option\n   * @returns AnnotationController\n   */\n\n\n  Annotation.prototype.region = function (option) {\n    this.annotation(__assign({\n      type: 'region'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 Text\n   * @param option\n   * @returns AnnotationController\n   */\n\n\n  Annotation.prototype.text = function (option) {\n    this.annotation(__assign({\n      type: 'text'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 DataMarker\n   * @param option\n   * @returns AnnotationController\n   */\n\n\n  Annotation.prototype.dataMarker = function (option) {\n    this.annotation(__assign({\n      type: 'dataMarker'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 DataRegion\n   * @param option\n   * @returns AnnotationController\n   */\n\n\n  Annotation.prototype.dataRegion = function (option) {\n    this.annotation(__assign({\n      type: 'dataRegion'\n    }, option));\n  };\n  /**\n   * 创建 RegionFilter\n   * @param option\n   * @returns AnnotationController\n   */\n\n\n  Annotation.prototype.regionFilter = function (option) {\n    this.annotation(__assign({\n      type: 'regionFilter'\n    }, option));\n  };\n  /**\n   * 创建 ShapeAnnotation\n   * @param option\n   */\n\n\n  Annotation.prototype.shape = function (option) {\n    this.annotation(__assign({\n      type: 'shape'\n    }, option));\n  };\n  /**\n   * 创建 HtmlAnnotation\n   * @param option\n   */\n\n\n  Annotation.prototype.html = function (option) {\n    this.annotation(__assign({\n      type: 'html'\n    }, option));\n  }; // end API\n\n  /**\n   * parse the point position to [x, y]\n   * @param p Position\n   * @returns { x, y }\n   */\n\n\n  Annotation.prototype.parsePosition = function (p) {\n    var e_1, _a;\n\n    var xScale = this.view.getXScale(); // 转成 object\n\n    var yScales = this.view.getScalesByDim('y');\n    var position = isFunction(p) ? p.call(null, xScale, yScales) : p;\n    var x = 0;\n    var y = 0; // 入参是 [24, 24] 这类时\n\n    if (isArray(position)) {\n      var _b = __read(position, 2),\n          xPos = _b[0],\n          yPos = _b[1]; // 如果数据格式是 ['50%', '50%'] 的格式\n      // fix: 原始数据中可能会包含 'xxx5%xxx' 这样的数据，需要判断下 https://github.com/antvis/f2/issues/590\n      // @ts-ignore\n\n\n      if (isString(xPos) && xPos.indexOf('%') !== -1 && !isNaN(xPos.slice(0, -1))) {\n        return this.parsePercentPosition(position);\n      }\n\n      x = getNormalizedValue(xPos, xScale);\n      y = getNormalizedValue(yPos, Object.values(yScales)[0]);\n    } else if (!isNil(position)) {\n      try {\n        // 入参是 object 结构，数据点\n        for (var _c = __values(keys(position)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var key = _d.value;\n          var value = position[key];\n\n          if (key === xScale.field) {\n            x = getNormalizedValue(value, xScale);\n          }\n\n          if (yScales[key]) {\n            y = getNormalizedValue(value, yScales[key]);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    if (isNaN(x) || isNaN(y)) {\n      return null;\n    }\n\n    return this.view.getCoordinate().convert({\n      x: x,\n      y: y\n    });\n  };\n  /**\n   * parse all the points between start and end\n   * @param start\n   * @param end\n   * @return Point[]\n   */\n\n\n  Annotation.prototype.getRegionPoints = function (start, end) {\n    var _this = this;\n\n    var xScale = this.view.getXScale();\n    var yScales = this.view.getScalesByDim('y');\n    var yScale = Object.values(yScales)[0];\n    var xField = xScale.field;\n    var viewData = this.view.getData();\n    var startXValue = isArray(start) ? start[0] : start[xField];\n    var endXValue = isArray(end) ? end[0] : end[xField];\n    var arr = [];\n    var startIndex;\n    each(viewData, function (item, idx) {\n      if (item[xField] === startXValue) {\n        startIndex = idx;\n      }\n\n      if (idx >= startIndex) {\n        var point = _this.parsePosition([item[xField], item[yScale.field]]);\n\n        if (point) {\n          arr.push(point);\n        }\n      }\n\n      if (item[xField] === endXValue) {\n        return false;\n      }\n    });\n    return arr;\n  };\n  /**\n   * parse percent position\n   * @param position\n   */\n\n\n  Annotation.prototype.parsePercentPosition = function (position) {\n    var xPercent = parseFloat(position[0]) / 100;\n    var yPercent = parseFloat(position[1]) / 100;\n    var coordinate = this.view.getCoordinate();\n    var start = coordinate.start,\n        end = coordinate.end;\n    var topLeft = {\n      x: Math.min(start.x, end.x),\n      y: Math.min(start.y, end.y)\n    };\n    var x = coordinate.getWidth() * xPercent + topLeft.x;\n    var y = coordinate.getHeight() * yPercent + topLeft.y;\n    return {\n      x: x,\n      y: y\n    };\n  };\n  /**\n   * get coordinate bbox\n   */\n\n\n  Annotation.prototype.getCoordinateBBox = function () {\n    var coordinate = this.view.getCoordinate();\n    var start = coordinate.start,\n        end = coordinate.end;\n    var width = coordinate.getWidth();\n    var height = coordinate.getHeight();\n    var topLeft = {\n      x: Math.min(start.x, end.x),\n      y: Math.min(start.y, end.y)\n    };\n    return {\n      x: topLeft.x,\n      y: topLeft.y,\n      minX: topLeft.x,\n      minY: topLeft.y,\n      maxX: topLeft.x + width,\n      maxY: topLeft.y + height,\n      width: width,\n      height: height\n    };\n  };\n  /**\n   * get annotation component config by different type\n   * @param type\n   * @param option 用户的配置\n   * @param theme\n   */\n\n\n  Annotation.prototype.getAnnotationCfg = function (type, option, theme) {\n    var _this = this;\n\n    var coordinate = this.view.getCoordinate();\n    var canvas = this.view.getCanvas();\n    var o = {};\n\n    if (isNil(option)) {\n      return null;\n    }\n\n    var start = option.start,\n        end = option.end,\n        position = option.position;\n    var sp = this.parsePosition(start);\n    var ep = this.parsePosition(end);\n    var textPoint = this.parsePosition(position);\n\n    if (['arc', 'image', 'line', 'region', 'regionFilter'].includes(type) && (!sp || !ep)) {\n      return null;\n    } else if (['text', 'dataMarker', 'html'].includes(type) && !textPoint) {\n      return null;\n    }\n\n    if (type === 'arc') {\n      var _a = option,\n          start_1 = _a.start,\n          end_1 = _a.end,\n          rest = __rest(_a, [\"start\", \"end\"]);\n\n      var startAngle = getAngleByPoint(coordinate, sp);\n      var endAngle = getAngleByPoint(coordinate, ep);\n\n      if (startAngle > endAngle) {\n        endAngle = Math.PI * 2 + endAngle;\n      }\n\n      o = __assign(__assign({}, rest), {\n        center: coordinate.getCenter(),\n        radius: getDistanceToCenter(coordinate, sp),\n        startAngle: startAngle,\n        endAngle: endAngle\n      });\n    } else if (type === 'image') {\n      var _b = option,\n          start_2 = _b.start,\n          end_2 = _b.end,\n          rest = __rest(_b, [\"start\", \"end\"]);\n\n      o = __assign(__assign({}, rest), {\n        start: sp,\n        end: ep,\n        src: option.src\n      });\n    } else if (type === 'line') {\n      var _c = option,\n          start_3 = _c.start,\n          end_3 = _c.end,\n          rest = __rest(_c, [\"start\", \"end\"]);\n\n      o = __assign(__assign({}, rest), {\n        start: sp,\n        end: ep,\n        text: get(option, 'text', null)\n      });\n    } else if (type === 'region') {\n      var _d = option,\n          start_4 = _d.start,\n          end_4 = _d.end,\n          rest = __rest(_d, [\"start\", \"end\"]);\n\n      o = __assign(__assign({}, rest), {\n        start: sp,\n        end: ep\n      });\n    } else if (type === 'text') {\n      var filteredData = this.view.getData();\n\n      var _e = option,\n          position_1 = _e.position,\n          content = _e.content,\n          rest = __rest(_e, [\"position\", \"content\"]);\n\n      var textContent = content;\n\n      if (isFunction(content)) {\n        textContent = content(filteredData);\n      }\n\n      o = __assign(__assign(__assign({}, textPoint), rest), {\n        content: textContent\n      });\n    } else if (type === 'dataMarker') {\n      var _f = option,\n          position_2 = _f.position,\n          point = _f.point,\n          line = _f.line,\n          text = _f.text,\n          autoAdjust = _f.autoAdjust,\n          direction = _f.direction,\n          rest = __rest(_f, [\"position\", \"point\", \"line\", \"text\", \"autoAdjust\", \"direction\"]);\n\n      o = __assign(__assign(__assign({}, rest), textPoint), {\n        coordinateBBox: this.getCoordinateBBox(),\n        point: point,\n        line: line,\n        text: text,\n        autoAdjust: autoAdjust,\n        direction: direction\n      });\n    } else if (type === 'dataRegion') {\n      var _g = option,\n          start_5 = _g.start,\n          end_5 = _g.end,\n          region = _g.region,\n          text = _g.text,\n          lineLength = _g.lineLength,\n          rest = __rest(_g, [\"start\", \"end\", \"region\", \"text\", \"lineLength\"]);\n\n      o = __assign(__assign({}, rest), {\n        points: this.getRegionPoints(start_5, end_5),\n        region: region,\n        text: text,\n        lineLength: lineLength\n      });\n    } else if (type === 'regionFilter') {\n      var _h = option,\n          start_6 = _h.start,\n          end_6 = _h.end,\n          apply_1 = _h.apply,\n          color = _h.color,\n          rest = __rest(_h, [\"start\", \"end\", \"apply\", \"color\"]);\n\n      var geometries = this.view.geometries;\n      var shapes_1 = [];\n\n      var addShapes_1 = function (item) {\n        if (!item) {\n          return;\n        }\n\n        if (item.isGroup()) {\n          item.getChildren().forEach(function (child) {\n            return addShapes_1(child);\n          });\n        } else {\n          shapes_1.push(item);\n        }\n      };\n\n      each(geometries, function (geom) {\n        if (apply_1) {\n          if (contains(apply_1, geom.type)) {\n            each(geom.elements, function (elem) {\n              addShapes_1(elem.shape);\n            });\n          }\n        } else {\n          each(geom.elements, function (elem) {\n            addShapes_1(elem.shape);\n          });\n        }\n      });\n      o = __assign(__assign({}, rest), {\n        color: color,\n        shapes: shapes_1,\n        start: sp,\n        end: ep\n      });\n    } else if (type === 'shape') {\n      var _j = option,\n          render_1 = _j.render,\n          restOptions = __rest(_j, [\"render\"]);\n\n      var wrappedRender = function (container) {\n        if (isFunction(option.render)) {\n          return render_1(container, _this.view, {\n            parsePosition: _this.parsePosition.bind(_this)\n          });\n        }\n      };\n\n      o = __assign(__assign({}, restOptions), {\n        render: wrappedRender\n      });\n    } else if (type === 'html') {\n      var _k = option,\n          html_1 = _k.html,\n          position_3 = _k.position,\n          restOptions = __rest(_k, [\"html\", \"position\"]);\n\n      var wrappedHtml = function (container) {\n        if (isFunction(html_1)) {\n          return html_1(container, _this.view);\n        }\n\n        return html_1;\n      };\n\n      o = __assign(__assign(__assign({}, restOptions), textPoint), {\n        // html 组件需要指定 parent\n        parent: canvas.get('el').parentNode,\n        html: wrappedHtml\n      });\n    } // 合并主题，用户配置优先级高于默认主题\n\n\n    var cfg = deepMix({}, theme, __assign(__assign({}, o), {\n      top: option.top,\n      style: option.style,\n      offsetX: option.offsetX,\n      offsetY: option.offsetY\n    }));\n\n    if (type !== 'html') {\n      // html 类型不使用 G container\n      cfg.container = this.getComponentContainer(cfg);\n    }\n\n    cfg.animate = this.view.getOptions().animate && cfg.animate && get(option, 'animate', cfg.animate); // 如果 view 关闭动画，则不执行\n\n    cfg.animateOption = deepMix({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);\n    return cfg;\n  };\n  /**\n   * is annotation render on top\n   * @param option\n   * @return whethe on top\n   */\n\n\n  Annotation.prototype.isTop = function (option) {\n    return get(option, 'top', true);\n  };\n  /**\n   * get the container by option.top\n   * default is on top\n   * @param option\n   * @returns the container\n   */\n\n\n  Annotation.prototype.getComponentContainer = function (option) {\n    return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;\n  };\n\n  Annotation.prototype.getAnnotationTheme = function (type) {\n    return get(this.view.getTheme(), ['components', 'annotation', type], {});\n  };\n  /**\n   * 创建或者更新 annotation\n   * @param option\n   */\n\n\n  Annotation.prototype.updateOrCreate = function (option) {\n    // 拿到缓存的内容\n    var co = this.cache.get(this.getCacheKey(option)); // 存在则更新，不存在在创建\n\n    if (co) {\n      var type = option.type;\n      var theme = this.getAnnotationTheme(type);\n      var cfg = this.getAnnotationCfg(type, option, theme); // 忽略掉一些配置\n\n      if (cfg) {\n        omit(cfg, ['container']);\n      }\n\n      co.component.update(__assign(__assign({}, cfg || {}), {\n        visible: !!cfg\n      })); // 对于 regionFilter/shape，因为生命周期的原因，需要额外 render\n\n      if (includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n        co.component.render();\n      }\n    } else {\n      // 不存在，创建\n      co = this.createAnnotation(option);\n\n      if (co) {\n        co.component.init(); // Note：regionFilter/shape 特殊处理，regionFilter/shape 需要取到 Geometry 中的 Shape，需要在 view render 之后处理\n        // 其他组件使用外层的统一 render 逻辑\n\n        if (includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n          co.component.render();\n        }\n      }\n    }\n\n    return co;\n  };\n  /**\n   * 更新缓存，以及销毁组件\n   * @param updated 更新或者创建的组件\n   */\n\n\n  Annotation.prototype.syncCache = function (updated) {\n    var _this = this;\n\n    var newCache = new Map(this.cache); // clone 一份\n    // 将 update 更新到 cache\n\n    updated.forEach(function (co, key) {\n      newCache.set(key, co);\n    }); // 另外和 options 进行对比，删除\n\n    newCache.forEach(function (co, key) {\n      // option 中已经找不到，那么就是删除的\n      if (!find(_this.option, function (option) {\n        return key === _this.getCacheKey(option);\n      })) {\n        co.component.destroy();\n        newCache.delete(key);\n      }\n    });\n    return newCache;\n  };\n  /**\n   * 获得缓存组件的 key\n   * @param option\n   */\n\n\n  Annotation.prototype.getCacheKey = function (option) {\n    // 如果存在 id，则使用 id string，否则直接使用 option 引用作为 key\n    return option; // 后续扩展 id 用\n    // const id = get(option, 'id');\n    // return id ? id : option;\n  };\n\n  return Annotation;\n}(Controller);\n\nexport default Annotation;","map":{"version":3,"mappings":"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","names":["contains","deepMix","each","get","isArray","isFunction","isNil","isString","keys","upperFirst","find","includes","Annotation","AnnotationComponent","DEFAULT_ANIMATE_CFG","COMPONENT_TYPE","DIRECTION","GEOMETRY_LIFE_CIRCLE","LAYER","VIEW_LIFE_CIRCLE","getAngleByPoint","getDistanceToCenter","omit","getNormalizedValue","Controller","ANNOTATIONS_AFTER_RENDER","__extends","view","_super","_this","Map","foregroundContainer","getLayer","FORE","addGroup","backgroundContainer","BG","option","Object","update","onAfterRender","updated","type","co","updateOrCreate","set","getCacheKey","cache","syncCache","updateCache","includeOption","clear","call","clearComponents","remove","forEach","value","push","getComponents","component","destroy","doWhat","getOptions","animate","geometries","g","animateOption","once","AFTER_DRAW_ANIMATE","getRootView","AFTER_RENDER","Ctor","theme","getAnnotationTheme","cfg","getAnnotationCfg","annotation","layer","isTop","direction","NONE","ANNOTATION","extra","__assign","p","xScale","getXScale","yScales","getScalesByDim","position","x","y","xPos","yPos","indexOf","isNaN","slice","parsePercentPosition","values","_d","key","field","getCoordinate","convert","start","end","yScale","xField","viewData","getData","startXValue","endXValue","arr","startIndex","item","idx","point","parsePosition","xPercent","parseFloat","yPercent","coordinate","topLeft","Math","min","getWidth","getHeight","width","height","minX","minY","maxX","maxY","canvas","getCanvas","o","sp","ep","textPoint","_a","start_1","end_1","rest","startAngle","endAngle","PI","center","getCenter","radius","_b","start_2","end_2","src","_c","start_3","end_3","text","start_4","end_4","filteredData","_e","position_1","content","textContent","_f","position_2","line","autoAdjust","coordinateBBox","getCoordinateBBox","_g","start_5","end_5","region","lineLength","points","getRegionPoints","_h","start_6","end_6","apply_1","color","shapes_1","addShapes_1","isGroup","getChildren","child","geom","elements","elem","shape","shapes","_j","render_1","restOptions","wrappedRender","container","render","bind","_k","html_1","position_3","wrappedHtml","parent","parentNode","html","top","style","offsetX","offsetY","getComponentContainer","getTheme","visible","createAnnotation","init","newCache","delete"],"sourceRoot":"","sources":["../../../src/chart/controller/annotation.ts"],"sourcesContent":["import {\n  contains,\n  deepMix,\n  each,\n  get,\n  isArray,\n  isFunction,\n  isNil,\n  isString,\n  keys,\n  upperFirst,\n  find,\n  includes,\n} from '@antv/util';\nimport { Annotation as AnnotationComponent, IElement, IGroup } from '../../dependents';\nimport {\n  AnnotationBaseOption as BaseOption,\n  AnnotationPosition as Position,\n  ArcOption,\n  ComponentOption,\n  ShapeAnnotationOption,\n  Data,\n  DataMarkerOption,\n  DataRegionOption,\n  Datum,\n  HtmlAnnotationOption,\n  ImageOption,\n  LineOption,\n  Point,\n  RegionFilterOption,\n  RegionOption,\n  RegionPositionBaseOption,\n  TextOption,\n} from '../../interface';\n\nimport { DEFAULT_ANIMATE_CFG } from '../../animate/';\nimport { COMPONENT_TYPE, DIRECTION, GEOMETRY_LIFE_CIRCLE, LAYER, VIEW_LIFE_CIRCLE } from '../../constant';\n\nimport Geometry from '../../geometry/base';\nimport Element from '../../geometry/element';\nimport { getAngleByPoint, getDistanceToCenter } from '../../util/coordinate';\nimport { omit } from '../../util/helper';\nimport { getNormalizedValue } from '../../util/annotation';\nimport View from '../view';\nimport { Controller } from './base';\nimport { Scale } from '@antv/attr';\n\n/** 需要在图形绘制完成后才渲染的辅助组件类型列表 */\nconst ANNOTATIONS_AFTER_RENDER = ['regionFilter', 'shape'];\n\n/**\n * Annotation controller, 主要作用:\n * 1. 创建 Annotation: line、text、arc ...\n * 2. 生命周期: init、layout、render、clear、destroy\n */\nexport default class Annotation extends Controller<BaseOption[]> {\n  private foregroundContainer: IGroup;\n  private backgroundContainer: IGroup;\n\n  /* 组件更新的 cache，组件配置 object : 组件 */\n  private cache = new Map<BaseOption, ComponentOption>();\n\n  constructor(view: View) {\n    super(view);\n\n    this.foregroundContainer = this.view.getLayer(LAYER.FORE).addGroup();\n    this.backgroundContainer = this.view.getLayer(LAYER.BG).addGroup();\n\n    this.option = [];\n  }\n\n  public get name(): string {\n    return 'annotation';\n  }\n\n  public init() { }\n\n  /**\n   * 因为 annotation 需要依赖坐标系信息，所以 render 阶段为空方法，实际的创建逻辑都在 layout 中\n   */\n  public layout() {\n    this.update();\n  }\n\n  // 因为 Annotation 不参与布局，但是渲染的位置依赖于坐标系，所以可以将绘制阶段延迟到 layout() 进行\n  public render() { }\n\n  /**\n   * 更新\n   */\n  public update() {\n    // 1. 先处理需要在图形渲染之后的辅助组件 需要在 Geometry 完成之后，拿到图形信息\n    this.onAfterRender(() => {\n      const updated = new Map<BaseOption, ComponentOption>();\n      // 先看是否有 regionFilter/shape 要更新\n      each(this.option, (option: BaseOption) => {\n        if (includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n          const co = this.updateOrCreate(option);\n          // 存储已经处理过的\n          if (co) {\n            updated.set(this.getCacheKey(option), co);\n          }\n        }\n      });\n\n      // 处理完成之后，更新 cache\n      // 处理完成之后，销毁删除的\n      this.cache = this.syncCache(updated);\n    });\n\n    // 2. 处理非 regionFilter\n    const updateCache = new Map<BaseOption, ComponentOption>();\n    each(this.option, (option: BaseOption) => {\n      if (!includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n        const co = this.updateOrCreate(option);\n        // 存储已经处理过的\n        if (co) {\n          updateCache.set(this.getCacheKey(option), co);\n        }\n      }\n    });\n    this.cache = this.syncCache(updateCache);\n  }\n\n  /**\n   * 清空\n   * @param includeOption 是否清空 option 配置项\n   */\n  public clear(includeOption = false) {\n    super.clear();\n\n    this.clearComponents();\n    this.foregroundContainer.clear();\n    this.backgroundContainer.clear();\n\n    // clear all option\n    if (includeOption) {\n      this.option = [];\n    }\n  }\n\n  public destroy() {\n    this.clear(true);\n\n    this.foregroundContainer.remove(true);\n    this.backgroundContainer.remove(true);\n  }\n\n  /**\n   * 复写基类的方法\n   */\n  public getComponents(): ComponentOption[] {\n    const co = [];\n\n    this.cache.forEach((value: ComponentOption) => {\n      co.push(value);\n    });\n\n    return co;\n  }\n\n  /**\n   * 清除当前的组件\n   */\n  private clearComponents() {\n    this.getComponents().forEach((co) => {\n      co.component.destroy();\n    });\n\n    this.cache.clear();\n  }\n\n  /**\n   * region filter 比较特殊的渲染时机\n   * @param doWhat\n   */\n  private onAfterRender(doWhat: () => void) {\n    if (this.view.getOptions().animate) {\n      this.view.geometries.forEach((g: Geometry) => {\n        // 如果 geometry 开启，则监听\n        if (g.animateOption) {\n          g.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, () => {\n            doWhat();\n          });\n        }\n      });\n    } else {\n      this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, () => {\n        doWhat();\n      });\n    }\n  }\n\n  private createAnnotation(option: BaseOption) {\n    const { type } = option;\n\n    const Ctor = AnnotationComponent[upperFirst(type)];\n    if (Ctor) {\n      const theme = this.getAnnotationTheme(type);\n      const cfg = this.getAnnotationCfg(type, option, theme);\n      // 不创建\n      if (!cfg) {\n        return null;\n      }\n      const annotation = new Ctor(cfg);\n\n      return {\n        component: annotation,\n        layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.ANNOTATION,\n        extra: option,\n      };\n    }\n  }\n\n  // APIs for creating annotation component\n  public annotation(option: any) {\n    this.option.push(option);\n  }\n\n  /**\n   * 创建 Arc\n   * @param option\n   * @returns AnnotationController\n   */\n  public arc(option: ArcOption) {\n    this.annotation({\n      type: 'arc',\n      ...option,\n    });\n\n    return this;\n  }\n\n  /**\n   * 创建 image\n   * @param option\n   * @returns AnnotationController\n   */\n  public image(option: ImageOption) {\n    this.annotation({\n      type: 'image',\n      ...option,\n    });\n\n    return this;\n  }\n\n  /**\n   * 创建 Line\n   * @param option\n   * @returns AnnotationController\n   */\n  public line(option: LineOption) {\n    this.annotation({\n      type: 'line',\n      ...option,\n    });\n\n    return this;\n  }\n\n  /**\n   * 创建 Region\n   * @param option\n   * @returns AnnotationController\n   */\n  public region(option: RegionOption) {\n    this.annotation({\n      type: 'region',\n      ...option,\n    });\n\n    return this;\n  }\n\n  /**\n   * 创建 Text\n   * @param option\n   * @returns AnnotationController\n   */\n  public text(option: TextOption) {\n    this.annotation({\n      type: 'text',\n      ...option,\n    });\n\n    return this;\n  }\n\n  /**\n   * 创建 DataMarker\n   * @param option\n   * @returns AnnotationController\n   */\n  public dataMarker(option: DataMarkerOption) {\n    this.annotation({\n      type: 'dataMarker',\n      ...option,\n    });\n\n    return this;\n  }\n\n  /**\n   * 创建 DataRegion\n   * @param option\n   * @returns AnnotationController\n   */\n  public dataRegion(option: DataRegionOption) {\n    this.annotation({\n      type: 'dataRegion',\n      ...option,\n    });\n  }\n\n  /**\n   * 创建 RegionFilter\n   * @param option\n   * @returns AnnotationController\n   */\n  public regionFilter(option: RegionFilterOption) {\n    this.annotation({\n      type: 'regionFilter',\n      ...option,\n    });\n  }\n\n  /**\n   * 创建 ShapeAnnotation\n   * @param option\n   */\n  public shape(option: ShapeAnnotationOption) {\n    this.annotation({\n      type: 'shape',\n      ...option,\n    });\n  }\n\n  /**\n   * 创建 HtmlAnnotation\n   * @param option\n   */\n  public html(option: HtmlAnnotationOption) {\n    this.annotation({\n      type: 'html',\n      ...option,\n    });\n  }\n  // end API\n\n  /**\n   * parse the point position to [x, y]\n   * @param p Position\n   * @returns { x, y }\n   */\n  private parsePosition(\n    p:\n      | [string | number, string | number]\n      | Datum\n      | ((xScale: Scale, yScale: Scale) => [string | number, string | number] | number | Datum)\n  ): Point {\n    const xScale = this.view.getXScale();\n    // 转成 object\n    const yScales = this.view.getScalesByDim('y');\n\n    const position: Position = isFunction(p) ? p.call(null, xScale, yScales) : p;\n\n    let x = 0;\n    let y = 0;\n\n    // 入参是 [24, 24] 这类时\n    if (isArray(position)) {\n      const [xPos, yPos] = position;\n      // 如果数据格式是 ['50%', '50%'] 的格式\n      // fix: 原始数据中可能会包含 'xxx5%xxx' 这样的数据，需要判断下 https://github.com/antvis/f2/issues/590\n      // @ts-ignore\n      if (isString(xPos) && xPos.indexOf('%') !== -1 && !isNaN(xPos.slice(0, -1))) {\n        return this.parsePercentPosition(position as [string, string]);\n      }\n\n      x = getNormalizedValue(xPos, xScale);\n      y = getNormalizedValue(yPos, Object.values(yScales)[0]);\n    } else if (!isNil(position)) {\n      // 入参是 object 结构，数据点\n      for (const key of keys(position)) {\n        const value = position[key];\n        if (key === xScale.field) {\n          x = getNormalizedValue(value, xScale);\n        }\n        if (yScales[key]) {\n          y = getNormalizedValue(value, yScales[key]);\n        }\n      }\n    }\n\n    if (isNaN(x) || isNaN(y)) {\n      return null;\n    }\n\n    return this.view.getCoordinate().convert({ x, y });\n  }\n\n  /**\n   * parse all the points between start and end\n   * @param start\n   * @param end\n   * @return Point[]\n   */\n  private getRegionPoints(start: Position | Data, end: Position | Data): Point[] {\n    const xScale = this.view.getXScale();\n    const yScales = this.view.getScalesByDim('y');\n    const yScale = Object.values(yScales)[0];\n    const xField = xScale.field;\n    const viewData = this.view.getData();\n    const startXValue = isArray(start) ? start[0] : start[xField];\n    const endXValue = isArray(end) ? end[0] : end[xField];\n    const arr = [];\n\n    let startIndex;\n    each(viewData, (item, idx) => {\n      if (item[xField] === startXValue) {\n        startIndex = idx;\n      }\n      if (idx >= startIndex) {\n        const point = this.parsePosition([item[xField], item[yScale.field]]);\n        if (point) {\n          arr.push(point);\n        }\n      }\n      if (item[xField] === endXValue) {\n        return false;\n      }\n    });\n\n    return arr;\n  }\n\n  /**\n   * parse percent position\n   * @param position\n   */\n  private parsePercentPosition(position: [string, string]): Point {\n    const xPercent = parseFloat(position[0]) / 100;\n    const yPercent = parseFloat(position[1]) / 100;\n    const coordinate = this.view.getCoordinate();\n    const { start, end } = coordinate;\n\n    const topLeft = {\n      x: Math.min(start.x, end.x),\n      y: Math.min(start.y, end.y),\n    };\n    const x = coordinate.getWidth() * xPercent + topLeft.x;\n    const y = coordinate.getHeight() * yPercent + topLeft.y;\n    return { x, y };\n  }\n\n  /**\n   * get coordinate bbox\n   */\n  private getCoordinateBBox() {\n    const coordinate = this.view.getCoordinate();\n    const { start, end } = coordinate;\n\n    const width = coordinate.getWidth();\n    const height = coordinate.getHeight();\n    const topLeft = {\n      x: Math.min(start.x, end.x),\n      y: Math.min(start.y, end.y),\n    };\n\n    return {\n      x: topLeft.x,\n      y: topLeft.y,\n      minX: topLeft.x,\n      minY: topLeft.y,\n      maxX: topLeft.x + width,\n      maxY: topLeft.y + height,\n      width,\n      height,\n    };\n  }\n\n  /**\n   * get annotation component config by different type\n   * @param type\n   * @param option 用户的配置\n   * @param theme\n   */\n  private getAnnotationCfg(type: string, option: any, theme: object): object | null {\n    const coordinate = this.view.getCoordinate();\n    const canvas = this.view.getCanvas();\n    let o = {};\n\n    if (isNil(option)) {\n      return null;\n    }\n    const { start, end, position } = option;\n    const sp = this.parsePosition(start);\n    const ep = this.parsePosition(end);\n    const textPoint = this.parsePosition(position);\n    if (['arc', 'image', 'line', 'region', 'regionFilter'].includes(type) && (!sp || !ep)) {\n      return null;\n    } else if (['text', 'dataMarker', 'html'].includes(type) && !textPoint) {\n      return null;\n    }\n\n    if (type === 'arc') {\n      const { start, end, ...rest } = option as ArcOption;\n      const startAngle = getAngleByPoint(coordinate, sp);\n      let endAngle = getAngleByPoint(coordinate, ep);\n      if (startAngle > endAngle) {\n        endAngle = Math.PI * 2 + endAngle;\n      }\n\n      o = {\n        ...rest,\n        center: coordinate.getCenter(),\n        radius: getDistanceToCenter(coordinate, sp),\n        startAngle,\n        endAngle,\n      };\n    } else if (type === 'image') {\n      const { start, end, ...rest } = option as ImageOption;\n      o = {\n        ...rest,\n        start: sp,\n        end: ep,\n        src: option.src,\n      };\n    } else if (type === 'line') {\n      const { start, end, ...rest } = option as LineOption;\n      o = {\n        ...rest,\n        start: sp,\n        end: ep,\n        text: get(option, 'text', null),\n      };\n    } else if (type === 'region') {\n      const { start, end, ...rest } = option as RegionPositionBaseOption;\n      o = {\n        ...rest,\n        start: sp,\n        end: ep,\n      };\n    } else if (type === 'text') {\n      const filteredData = this.view.getData();\n      const { position, content, ...rest } = option as TextOption;\n      let textContent = content;\n      if (isFunction(content)) {\n        textContent = content(filteredData);\n      }\n      o = {\n        ...textPoint,\n        ...rest,\n        content: textContent,\n      };\n    } else if (type === 'dataMarker') {\n      const { position, point, line, text, autoAdjust, direction, ...rest } = option as DataMarkerOption;\n      o = {\n        ...rest,\n        ...textPoint,\n        coordinateBBox: this.getCoordinateBBox(),\n        point,\n        line,\n        text,\n        autoAdjust,\n        direction,\n      };\n    } else if (type === 'dataRegion') {\n      const { start, end, region, text, lineLength, ...rest } = option as DataRegionOption;\n      o = {\n        ...rest,\n        points: this.getRegionPoints(start, end),\n        region,\n        text,\n        lineLength,\n      };\n    } else if (type === 'regionFilter') {\n      const { start, end, apply, color, ...rest } = option as RegionFilterOption;\n      const geometries: Geometry[] = this.view.geometries;\n      const shapes = [];\n      const addShapes = (item?: IElement) => {\n        if (!item) {\n          return;\n        }\n        if (item.isGroup()) {\n          (item as IGroup).getChildren().forEach((child) => addShapes(child));\n        } else {\n          shapes.push(item);\n        }\n      };\n      each(geometries, (geom: Geometry) => {\n        if (apply) {\n          if (contains(apply, geom.type)) {\n            each(geom.elements, (elem: Element) => {\n              addShapes(elem.shape);\n            });\n          }\n        } else {\n          each(geom.elements, (elem: Element) => {\n            addShapes(elem.shape);\n          });\n        }\n      });\n      o = {\n        ...rest,\n        color,\n        shapes,\n        start: sp,\n        end: ep,\n      };\n    } else if (type === 'shape') {\n      const { render, ...restOptions } = option as ShapeAnnotationOption;\n      const wrappedRender = (container: IGroup) => {\n        if (isFunction(option.render)) {\n          return render(container, this.view, { parsePosition: this.parsePosition.bind(this) });\n        }\n      };\n      o = {\n        ...restOptions,\n        render: wrappedRender,\n      };\n    } else if (type === 'html') {\n      const { html, position, ...restOptions } = option as HtmlAnnotationOption;\n      const wrappedHtml = (container: HTMLElement) => {\n        if (isFunction(html)) {\n          return html(container, this.view);\n        }\n        return html;\n      };\n      o = {\n        ...restOptions,\n        ...textPoint,\n        // html 组件需要指定 parent\n        parent: canvas.get('el').parentNode,\n        html: wrappedHtml,\n      };\n    }\n    // 合并主题，用户配置优先级高于默认主题\n    const cfg = deepMix({}, theme, {\n      ...o,\n      top: option.top,\n      style: option.style,\n      offsetX: option.offsetX,\n      offsetY: option.offsetY,\n    });\n    if (type !== 'html') {\n      // html 类型不使用 G container\n      cfg.container = this.getComponentContainer(cfg);\n    }\n    cfg.animate = this.view.getOptions().animate && cfg.animate && get(option, 'animate', cfg.animate); // 如果 view 关闭动画，则不执行\n    cfg.animateOption = deepMix({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);\n\n    return cfg;\n  }\n\n  /**\n   * is annotation render on top\n   * @param option\n   * @return whethe on top\n   */\n  private isTop(option: any): boolean {\n    return get(option, 'top', true);\n  }\n\n  /**\n   * get the container by option.top\n   * default is on top\n   * @param option\n   * @returns the container\n   */\n  private getComponentContainer(option: any) {\n    return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;\n  }\n\n  private getAnnotationTheme(type: string) {\n    return get(this.view.getTheme(), ['components', 'annotation', type], {});\n  }\n\n  /**\n   * 创建或者更新 annotation\n   * @param option\n   */\n  private updateOrCreate(option: BaseOption) {\n    // 拿到缓存的内容\n    let co = this.cache.get(this.getCacheKey(option));\n\n    // 存在则更新，不存在在创建\n    if (co) {\n      const { type } = option;\n      const theme = this.getAnnotationTheme(type);\n      const cfg = this.getAnnotationCfg(type, option, theme);\n\n      // 忽略掉一些配置\n      if (cfg) {\n        omit(cfg, ['container']);\n      }\n      co.component.update({ ...(cfg || {}), visible: !!cfg });\n      // 对于 regionFilter/shape，因为生命周期的原因，需要额外 render\n      if (includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n        co.component.render();\n      }\n    } else {\n      // 不存在，创建\n      co = this.createAnnotation(option);\n      if (co) {\n        co.component.init();\n        // Note：regionFilter/shape 特殊处理，regionFilter/shape 需要取到 Geometry 中的 Shape，需要在 view render 之后处理\n        // 其他组件使用外层的统一 render 逻辑\n        if (includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n          co.component.render();\n        }\n      }\n    }\n    return co;\n  }\n\n  /**\n   * 更新缓存，以及销毁组件\n   * @param updated 更新或者创建的组件\n   */\n  private syncCache(updated: Map<BaseOption, ComponentOption>) {\n    const newCache = new Map(this.cache); // clone 一份\n\n    // 将 update 更新到 cache\n    updated.forEach((co: ComponentOption, key: BaseOption) => {\n      newCache.set(key, co);\n    });\n\n    // 另外和 options 进行对比，删除\n    newCache.forEach((co: ComponentOption, key: BaseOption) => {\n      // option 中已经找不到，那么就是删除的\n      if (\n        !find(this.option, (option: BaseOption) => {\n          return key === this.getCacheKey(option);\n        })\n      ) {\n        co.component.destroy();\n        newCache.delete(key);\n      }\n    });\n\n    return newCache;\n  }\n\n  /**\n   * 获得缓存组件的 key\n   * @param option\n   */\n  private getCacheKey(option: BaseOption) {\n    // 如果存在 id，则使用 id string，否则直接使用 option 引用作为 key\n    return option;\n    // 后续扩展 id 用\n    // const id = get(option, 'id');\n    // return id ? id : option;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}