{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { deepMix, get, isArray } from '@antv/util';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport { polarToCartesian } from '../../util/graphics';\nimport PolarLabel from './polar';\n/**\n * 饼图 label\n */\n\nvar PieLabel =\n/** @class */\nfunction (_super) {\n  __extends(PieLabel, _super);\n\n  function PieLabel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.defaultLayout = 'distribute';\n    return _this;\n  }\n\n  PieLabel.prototype.getDefaultLabelCfg = function (offset, position) {\n    var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);\n\n    return deepMix({}, cfg, get(this.geometry.theme, 'pieLabels', {}));\n  };\n  /** @override */\n\n\n  PieLabel.prototype.getLabelOffset = function (offset) {\n    return _super.prototype.getLabelOffset.call(this, offset) || 0;\n  };\n\n  PieLabel.prototype.getLabelRotate = function (angle, offset, isLabelLimit) {\n    var rotate;\n\n    if (offset < 0) {\n      rotate = angle;\n\n      if (rotate > Math.PI / 2) {\n        rotate = rotate - Math.PI;\n      }\n\n      if (rotate < -Math.PI / 2) {\n        rotate = rotate + Math.PI;\n      }\n    }\n\n    return rotate;\n  };\n\n  PieLabel.prototype.getLabelAlign = function (point) {\n    var coordinate = this.getCoordinate();\n    var center = coordinate.getCenter();\n    var align;\n\n    if (point.angle <= Math.PI / 2 && point.x >= center.x) {\n      align = 'left';\n    } else {\n      align = 'right';\n    }\n\n    if (point.offset <= 0) {\n      if (align === 'right') {\n        align = 'left';\n      } else {\n        align = 'right';\n      }\n    }\n\n    return align;\n  };\n\n  PieLabel.prototype.getArcPoint = function (point) {\n    return point;\n  };\n\n  PieLabel.prototype.getPointAngle = function (point) {\n    var coordinate = this.getCoordinate();\n    var startPoint = {\n      x: isArray(point.x) ? point.x[0] : point.x,\n      y: point.y[0]\n    };\n    var endPoint = {\n      x: isArray(point.x) ? point.x[1] : point.x,\n      y: point.y[1]\n    };\n    var angle;\n    var startAngle = getAngleByPoint(coordinate, startPoint);\n\n    if (point.points && point.points[0].y === point.points[1].y) {\n      angle = startAngle;\n    } else {\n      var endAngle = getAngleByPoint(coordinate, endPoint);\n\n      if (startAngle >= endAngle) {\n        // 100% pie slice\n        endAngle = endAngle + Math.PI * 2;\n      }\n\n      angle = startAngle + (endAngle - startAngle) / 2;\n    }\n\n    return angle;\n  };\n  /** @override */\n\n\n  PieLabel.prototype.getCirclePoint = function (angle, offset) {\n    var coordinate = this.getCoordinate();\n    var center = coordinate.getCenter();\n    var r = coordinate.getRadius() + offset;\n    return __assign(__assign({}, polarToCartesian(center.x, center.y, r, angle)), {\n      angle: angle,\n      r: r\n    });\n  };\n\n  return PieLabel;\n}(PolarLabel);\n\nexport default PieLabel;","map":{"version":3,"mappings":"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","names":["deepMix","get","isArray","getAngleByPoint","polarToCartesian","PolarLabel","__extends","_this","PieLabel","offset","position","cfg","_super","getDefaultLabelCfg","call","geometry","theme","getLabelOffset","angle","isLabelLimit","rotate","Math","PI","point","coordinate","getCoordinate","center","getCenter","align","x","startPoint","y","endPoint","startAngle","points","endAngle","r","getRadius"],"sourceRoot":"","sources":["../../../src/geometry/label/pie.ts"],"sourcesContent":["import { deepMix, get, isArray } from '@antv/util';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport { polarToCartesian } from '../../util/graphics';\nimport { LabelItem } from './interface';\nimport PolarLabel from './polar';\n\n/**\n * 饼图 label\n */\nexport default class PieLabel extends PolarLabel {\n  public defaultLayout = 'distribute';\n\n  protected getDefaultLabelCfg(offset?: number, position?: string) {\n    const cfg = super.getDefaultLabelCfg(offset, position);\n    return deepMix({}, cfg, get(this.geometry.theme, 'pieLabels', {}));\n  }\n\n  /** @override */\n  protected getLabelOffset(offset: string | number): number {\n    return super.getLabelOffset(offset) || 0;\n  }\n\n  protected getLabelRotate(angle: number, offset: number, isLabelLimit: boolean) {\n    let rotate;\n    if (offset < 0) {\n      rotate = angle;\n      if (rotate > Math.PI / 2) {\n        rotate = rotate - Math.PI;\n      }\n      if (rotate < -Math.PI / 2) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  }\n\n  protected getLabelAlign(point: LabelItem) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n\n    let align;\n    if (point.angle <= Math.PI / 2 && point.x >= center.x) {\n      align = 'left';\n    } else {\n      align = 'right';\n    }\n    if (point.offset <= 0) {\n      if (align === 'right') {\n        align = 'left';\n      } else {\n        align = 'right';\n      }\n    }\n    return align;\n  }\n\n  protected getArcPoint(point) {\n    return point;\n  }\n\n  protected getPointAngle(point) {\n    const coordinate = this.getCoordinate();\n    const startPoint = {\n      x: isArray(point.x) ? point.x[0] : point.x,\n      y: point.y[0],\n    };\n    const endPoint = {\n      x: isArray(point.x) ? point.x[1] : point.x,\n      y: point.y[1],\n    };\n    let angle;\n    const startAngle = getAngleByPoint(coordinate, startPoint);\n    if (point.points && point.points[0].y === point.points[1].y) {\n      angle = startAngle;\n    } else {\n      let endAngle = getAngleByPoint(coordinate, endPoint);\n      if (startAngle >= endAngle) {\n        // 100% pie slice\n        endAngle = endAngle + Math.PI * 2;\n      }\n      angle = startAngle + (endAngle - startAngle) / 2;\n    }\n    return angle;\n  }\n\n  /** @override */\n  protected getCirclePoint(angle: number, offset: number) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n    const r = coordinate.getRadius() + offset;\n    return {\n      ...polarToCartesian(center.x, center.y, r, angle),\n      angle,\n      r,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}