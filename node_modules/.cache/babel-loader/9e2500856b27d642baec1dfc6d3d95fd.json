{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\n\nfunction dot(a, b) {\n  return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n}\n/**\n * @private\n * 1. 获取投影轴\n */\n\n\nfunction getAxes(points\n/** 多边形的关键点 */\n) {\n  // 目前先处理 平行矩形 的场景, 其他多边形不处理\n  if (points.length > 4) {\n    return [];\n  } // 获取向量\n\n\n  var vector = function (start, end) {\n    return [end.x - start.x, end.y - start.y];\n  }; // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n\n\n  var AB = vector(points[0], points[1]);\n  var BC = vector(points[1], points[2]);\n  return [AB, BC];\n}\n/**\n * @private\n * 绕指定点顺时针旋转后的点坐标\n * 默认绕原点旋转\n */\n\n\nfunction rotateAtPoint(point, deg, origin) {\n  if (deg === void 0) {\n    deg = 0;\n  }\n\n  if (origin === void 0) {\n    origin = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var x = point.x,\n      y = point.y;\n  return {\n    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y\n  };\n}\n/**\n * @private\n * 转化为顶点坐标数组\n *\n * @param {Object} box\n */\n\n\nfunction getRectPoints(box) {\n  var points = [{\n    x: box.x,\n    y: box.y\n  }, {\n    x: box.x + box.width,\n    y: box.y\n  }, {\n    x: box.x + box.width,\n    y: box.y + box.height\n  }, {\n    x: box.x,\n    y: box.y + box.height\n  }];\n  var rotation = box.rotation;\n\n  if (rotation) {\n    return [rotateAtPoint(points[0], rotation, points[0]), rotateAtPoint(points[1], rotation, points[0]), rotateAtPoint(points[2], rotation, points[0]), rotateAtPoint(points[3], rotation, points[0])];\n  }\n\n  return points;\n}\n/**\n * @private\n * 2. 获取多边形在投影轴上的投影\n *\n * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n */\n\n\nfunction getProjection(points\n/** 多边形的关键点 */\n, axis) {\n  // 目前先处理矩形的场景\n  if (points.length > 4) {\n    return {\n      min: 0,\n      max: 0\n    };\n  }\n\n  var scalars = [];\n  points.forEach(function (point) {\n    scalars.push(dot([point.x, point.y], axis));\n  });\n  return {\n    min: Math.min.apply(Math, __spreadArray([], __read(scalars), false)),\n    max: Math.max.apply(Math, __spreadArray([], __read(scalars), false))\n  };\n}\n\nfunction isProjectionOverlap(projection1, projection2) {\n  return projection1.max > projection2.min && projection1.min < projection2.max;\n}\n\nfunction isValidNumber(d) {\n  return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n}\n\nfunction isValidBox(box) {\n  return ['x', 'y', 'width', 'height'].every(function (attr) {\n    return isValidNumber(box[attr]);\n  });\n}\n/**\n * 快速判断两个无旋转矩形是否遮挡\n */\n\n\nexport function isIntersectRect(box1, box2, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);\n}\n/**\n * detect whether two shape is intersected, useful when shape is been rotated\n * 判断两个矩形是否重叠（相交和包含, 是否旋转）\n *\n * - 原理: 分离轴定律\n */\n\nexport function intersect(box1, box2, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  } // 如果两个 box 中有一个是不合法的 box，也就是不会被渲染出来的，那么它们就不相交。\n\n\n  if (!isValidBox(box1) || !isValidBox(box2)) return false; // 如果两个矩形没有旋转，使用快速判断\n\n  if (!box1.rotation && !box2.rotation) {\n    return isIntersectRect(box1, box2, margin);\n  } // 分别获取 4 个关键点\n\n\n  var rect1Points = getRectPoints(box1);\n  var rect2Points = getRectPoints(box2); // 获取所有投影轴\n\n  var axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n\n  for (var i = 0; i < axes.length; i++) {\n    var axis = axes[i];\n    var projection1 = getProjection(rect1Points, axis);\n    var projection2 = getProjection(rect2Points, axis); // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。\n\n    if (!isProjectionOverlap(projection1, projection2)) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"mappings":"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","names":["dot","a","b","getAxes","points","length","vector","start","end","x","y","AB","BC","rotateAtPoint","point","deg","origin","Math","cos","sin","getRectPoints","box","width","height","rotation","getProjection","axis","min","max","scalars","forEach","push","apply","__spreadArray","isProjectionOverlap","projection1","projection2","isValidNumber","d","Number","isNaN","Infinity","isValidBox","every","attr","isIntersectRect","box1","box2","margin","intersect","rect1Points","rect2Points","axes","concat","i"],"sourceRoot":"","sources":["../../src/util/collision-detect.ts"],"sourcesContent":["import { isNumber } from '@antv/util';\nimport { Point } from '../dependents';\n\ntype Vec2 = [number, number];\n\ntype Item = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  rotation?: number;\n  visible?: boolean;\n};\n/**\n * 定义投影对象\n */\ntype Projection = { min: number; max: number };\n\nfunction dot(a, b) {\n  return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n}\n\n/**\n * @private\n * 1. 获取投影轴\n */\nfunction getAxes(points: Point[] /** 多边形的关键点 */): Vec2[] {\n  // 目前先处理 平行矩形 的场景, 其他多边形不处理\n  if (points.length > 4) {\n    return [];\n  }\n  // 获取向量\n  const vector = (start: Point, end: Point): Vec2 => {\n    return [end.x - start.x, end.y - start.y];\n  };\n\n  // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n  const AB = vector(points[0], points[1]);\n  const BC = vector(points[1], points[2]);\n\n  return [AB, BC];\n}\n\n/**\n * @private\n * 绕指定点顺时针旋转后的点坐标\n * 默认绕原点旋转\n */\nfunction rotateAtPoint(point: Point, deg = 0, origin = { x: 0, y: 0 }): Point {\n  const { x, y } = point;\n  return {\n    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y,\n  };\n}\n\n/**\n * @private\n * 转化为顶点坐标数组\n *\n * @param {Object} box\n */\nfunction getRectPoints(box: Item): Point[] {\n  const points = [\n    { x: box.x, y: box.y },\n    { x: box.x + box.width, y: box.y },\n    { x: box.x + box.width, y: box.y + box.height },\n    { x: box.x, y: box.y + box.height },\n  ];\n\n  const rotation = box.rotation;\n  if (rotation) {\n    return [\n      rotateAtPoint(points[0], rotation, points[0]),\n      rotateAtPoint(points[1], rotation, points[0]),\n      rotateAtPoint(points[2], rotation, points[0]),\n      rotateAtPoint(points[3], rotation, points[0]),\n    ];\n  }\n\n  return points;\n}\n\n/**\n * @private\n * 2. 获取多边形在投影轴上的投影\n *\n * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n */\nfunction getProjection(points: Point[] /** 多边形的关键点 */, axis: Vec2): Projection {\n  // 目前先处理矩形的场景\n  if (points.length > 4) {\n    return { min: 0, max: 0 };\n  }\n\n  const scalars = [];\n  points.forEach((point) => {\n    scalars.push(dot([point.x, point.y], axis));\n  });\n\n  return { min: Math.min(...scalars), max: Math.max(...scalars) };\n}\n\nfunction isProjectionOverlap(projection1: Projection, projection2: Projection): boolean {\n  return projection1.max > projection2.min && projection1.min < projection2.max;\n}\n\nfunction isValidNumber(d: number) {\n  return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n}\n\nfunction isValidBox(box: Item) {\n  return ['x', 'y', 'width', 'height'].every(attr => isValidNumber(box[attr]))\n}\n\n/**\n * 快速判断两个无旋转矩形是否遮挡\n */\nexport function isIntersectRect(box1: Item, box2: Item, margin: number = 0): boolean {\n  return !(\n    box2.x > box1.x + box1.width + margin ||\n    box2.x + box2.width < box1.x - margin ||\n    box2.y > box1.y + box1.height + margin ||\n    box2.y + box2.height < box1.y - margin\n  );\n}\n\n/**\n * detect whether two shape is intersected, useful when shape is been rotated\n * 判断两个矩形是否重叠（相交和包含, 是否旋转）\n *\n * - 原理: 分离轴定律\n */\nexport function intersect(box1: Item, box2: Item, margin: number = 0) {\n  // 如果两个 box 中有一个是不合法的 box，也就是不会被渲染出来的，那么它们就不相交。\n  if (!isValidBox(box1) || !isValidBox(box2)) return false;\n\n  // 如果两个矩形没有旋转，使用快速判断\n  if (!box1.rotation && !box2.rotation) {\n    return isIntersectRect(box1, box2, margin);\n  }\n\n  // 分别获取 4 个关键点\n  const rect1Points = getRectPoints(box1);\n  const rect2Points = getRectPoints(box2);\n\n  // 获取所有投影轴\n  const axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n\n  for (let i = 0; i < axes.length; i++) {\n    const axis = axes[i];\n    const projection1 = getProjection(rect1Points, axis);\n    const projection2 = getProjection(rect2Points, axis);\n\n    // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。\n    if (!isProjectionOverlap(projection1, projection2)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"]},"metadata":{},"sourceType":"module"}