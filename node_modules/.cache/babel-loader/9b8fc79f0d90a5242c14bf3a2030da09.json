{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray } from '@antv/util';\nimport { getField, getAllNodes } from './util';\nvar DEFAULT_OPTIONS = {\n  field: 'value',\n  tile: 'treemapSquarify',\n  size: [1, 1],\n  round: false,\n  ignoreParentValue: true,\n  padding: 0,\n  paddingInner: 0,\n  paddingOuter: 0,\n  paddingTop: 0,\n  paddingRight: 0,\n  paddingBottom: 0,\n  paddingLeft: 0,\n  as: ['x', 'y'],\n  // 默认降序\n  sort: function (a, b) {\n    return b.value - a.value;\n  },\n  // 纵横比, treemapSquarify 布局时可用，默认黄金分割比例\n  ratio: 0.5 * (1 + Math.sqrt(5))\n};\nexport function getTileMethod(tile, ratio) {\n  return tile === 'treemapSquarify' ? d3Hierarchy[tile].ratio(ratio) : d3Hierarchy[tile];\n}\nexport function treemap(data, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  var as = options.as;\n\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n\n  var field;\n\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  var tileMethod = getTileMethod(options.tile, options.ratio);\n\n  var partition = function (data) {\n    return d3Hierarchy.treemap().tile(tileMethod).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft)(\n    /**\n     * d3Hierarchy 布局中需指定 sum 函数计算 node 值，规则是：从当前 node 开始以 post-order traversal 的次序为当前节点以及每个后代节点调用指定的 value 函数，并返回当前 node。\n     * for example:\n     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}\n     * parent 所得的计算值是 sum(node(parent)) + sum(node(child1)) + sum(node(child2))\n     * ignoreParentValue 为 true(默认) 时，父元素的值由子元素累加而来，该值为 0 + 5 + 5 = 10\n     * ignoreParentValue 为 false 时，父元素的值由当前节点 及子元素累加而来，该值为 10 + 5 + 5 = 20\n     * sum 函数中，d 为用户传入的 data, children 为保留字段\n     */\n    d3Hierarchy.hierarchy(data).sum(function (d) {\n      return options.ignoreParentValue && d.children ? 0 : d[field];\n    }).sort(options.sort));\n  };\n\n  var root = partition(data);\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n\n  var x = as[0];\n  var y = as[1];\n  root.each(function (node) {\n    node[x] = [node.x0, node.x1, node.x1, node.x0];\n    node[y] = [node.y1, node.y1, node.y0, node.y0];\n    ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n  return getAllNodes(root);\n}","map":{"version":3,"mappings":"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","names":["d3Hierarchy","assign","isArray","getField","getAllNodes","DEFAULT_OPTIONS","field","tile","size","round","ignoreParentValue","padding","paddingInner","paddingOuter","paddingTop","paddingRight","paddingBottom","paddingLeft","as","sort","a","b","value","ratio","Math","sqrt","getTileMethod","treemap","data","options","length","TypeError","e","console","warn","tileMethod","partition","hierarchy","sum","d","children","root","x","y","each","node","x0","x1","y1","y0","forEach","prop","indexOf"],"sourceRoot":"","sources":["../../../src/utils/hierarchy/treemap.ts"],"sourcesContent":["import * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray } from '@antv/util';\nimport { HierarchyOption } from './types';\nimport { getField, getAllNodes } from './util';\n\nconst DEFAULT_OPTIONS: HierarchyOption = {\n  field: 'value',\n  tile: 'treemapSquarify', // treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify\n  size: [1, 1], // width, height\n  round: false,\n  ignoreParentValue: true,\n  padding: 0,\n  paddingInner: 0,\n  paddingOuter: 0,\n  paddingTop: 0,\n  paddingRight: 0,\n  paddingBottom: 0,\n  paddingLeft: 0,\n  as: ['x', 'y'],\n  // 默认降序\n  sort: (a, b) => b.value - a.value,\n  // 纵横比, treemapSquarify 布局时可用，默认黄金分割比例\n  ratio: 0.5 * (1 + Math.sqrt(5)),\n};\n\nexport function getTileMethod(tile: string, ratio: number) {\n  return tile === 'treemapSquarify' ? d3Hierarchy[tile].ratio(ratio) : d3Hierarchy[tile];\n}\n\nexport function treemap(data: any, options: HierarchyOption): any[] {\n  options = assign({} as HierarchyOption, DEFAULT_OPTIONS, options);\n  const as = options.as;\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n\n  let field;\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  const tileMethod = getTileMethod(options.tile, options.ratio);\n\n  const partition = (data) =>\n    d3Hierarchy\n      .treemap()\n      .tile(tileMethod)\n      .size(options.size)\n      .round(options.round)\n      .padding(options.padding)\n      .paddingInner(options.paddingInner)\n      .paddingOuter(options.paddingOuter)\n      .paddingTop(options.paddingTop)\n      .paddingRight(options.paddingRight)\n      .paddingBottom(options.paddingBottom)\n      .paddingLeft(options.paddingLeft)(\n      /**\n       * d3Hierarchy 布局中需指定 sum 函数计算 node 值，规则是：从当前 node 开始以 post-order traversal 的次序为当前节点以及每个后代节点调用指定的 value 函数，并返回当前 node。\n       * for example:\n       * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}\n       * parent 所得的计算值是 sum(node(parent)) + sum(node(child1)) + sum(node(child2))\n       * ignoreParentValue 为 true(默认) 时，父元素的值由子元素累加而来，该值为 0 + 5 + 5 = 10\n       * ignoreParentValue 为 false 时，父元素的值由当前节点 及子元素累加而来，该值为 10 + 5 + 5 = 20\n       * sum 函数中，d 为用户传入的 data, children 为保留字段\n       */\n      d3Hierarchy\n        .hierarchy(data)\n        .sum((d) => (options.ignoreParentValue && d.children ? 0 : d[field]))\n        .sort(options.sort)\n    );\n  const root = partition(data);\n\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n  const x = as[0];\n  const y = as[1];\n  root.each((node) => {\n    node[x] = [node.x0, node.x1, node.x1, node.x0];\n    node[y] = [node.y1, node.y1, node.y0, node.y0];\n    ['x0', 'x1', 'y0', 'y1'].forEach((prop) => {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n\n  return getAllNodes(root);\n}\n"]},"metadata":{},"sourceType":"module"}