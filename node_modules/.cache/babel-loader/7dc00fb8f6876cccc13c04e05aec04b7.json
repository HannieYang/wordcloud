{"ast":null,"code":"import { each, isEmpty, isNumber, isNumberEqual, max, min } from '@antv/util'; // 获取图形的包围盒\n\nfunction getPointsBox(points) {\n  if (isEmpty(points)) {\n    return null;\n  }\n\n  var minX = points[0].x;\n  var maxX = points[0].x;\n  var minY = points[0].y;\n  var maxY = points[0].y;\n  each(points, function (point) {\n    minX = minX > point.x ? point.x : minX;\n    maxX = maxX < point.x ? point.x : maxX;\n    minY = minY > point.y ? point.y : minY;\n    maxY = maxY < point.y ? point.y : maxY;\n  });\n  return {\n    minX: minX,\n    maxX: maxX,\n    minY: minY,\n    maxY: maxY,\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2\n  };\n}\n\nfunction uniqueValues(array) {\n  return Array.from(new Set(array)).length === 1;\n}\n\nfunction mid(array) {\n  return (min(array) + max(array)) / 2;\n}\n/**\n * @ignore\n * 根据弧度计算极坐标系下的坐标点\n * @param centerX\n * @param centerY\n * @param radius\n * @param angleInRadian\n * @returns\n */\n\n\nexport function polarToCartesian(centerX, centerY, radius, angleInRadian) {\n  return {\n    x: centerX + radius * Math.cos(angleInRadian),\n    y: centerY + radius * Math.sin(angleInRadian)\n  };\n}\n/**\n * @ignore\n * 根据起始角度计算绘制扇形的 path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\n\nexport function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {\n  if (innerRadius === void 0) {\n    innerRadius = 0;\n  }\n\n  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n  var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);\n  var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);\n\n  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {\n    // 整个圆是分割成两个圆\n    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);\n    var circlePathCommands = [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 1, end.x, end.y], ['M', innerStart.x, innerStart.y]];\n\n    if (innerRadius) {\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);\n    }\n\n    circlePathCommands.push(['M', start.x, start.y]);\n    circlePathCommands.push(['Z']);\n    return circlePathCommands;\n  }\n\n  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  var sectorPathCommands = [['M', start.x, start.y], ['A', radius, radius, 0, arcSweep, 1, end.x, end.y], ['L', innerEnd.x, innerEnd.y]];\n\n  if (innerRadius) {\n    sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);\n  }\n\n  sectorPathCommands.push(['L', start.x, start.y]);\n  sectorPathCommands.push(['Z']);\n  return sectorPathCommands;\n}\n/**\n * @ignore\n * Gets arc path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\n\nexport function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {\n  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n\n  if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {\n    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    return [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 1, start.x, start.y], ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 0, start.x, start.y], ['Z']];\n  }\n\n  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  return [['M', start.x, start.y], ['A', radius, radius, 0, arcSweep, 1, end.x, end.y]];\n}\n/**\n * @ignore\n * 从数据模型中的 points 换算角度\n * @param shapeModel\n * @param coordinate\n * @returns\n */\n\nexport function getAngle(shapeModel, coordinate) {\n  var points = shapeModel.points;\n  var box = getPointsBox(points);\n  var endAngle;\n  var startAngle;\n  var coordStartAngle = coordinate.startAngle,\n      coordEndAngle = coordinate.endAngle;\n  var diffAngle = coordEndAngle - coordStartAngle;\n\n  if (coordinate.isTransposed) {\n    endAngle = box.maxY * diffAngle;\n    startAngle = box.minY * diffAngle;\n  } else {\n    endAngle = box.maxX * diffAngle;\n    startAngle = box.minX * diffAngle;\n  }\n\n  endAngle += coordStartAngle;\n  startAngle += coordStartAngle;\n  return {\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n}\n/**\n * @ignore\n * 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon\n */\n\nexport function getPolygonCentroid(xs, ys) {\n  if (isNumber(xs) && isNumber(ys)) {\n    // 普通色块图，xs 和 ys 是数值\n    return [xs, ys];\n  }\n\n  xs = xs;\n  ys = ys; // 当这个 polygon 的点在一条线上的时候\n  // 也就是说 xs 里面的值都相同，比如：[1, 1, 1, 1]\n  // 或者说 ys 里面的值都相同，比如：[0, 0, 0, 0]\n  // 下面计算得到的 k = 0\n  // 导致返回的值是 [NaN, NaN]\n  // 所以这里做相应的处理\n\n  if (uniqueValues(xs) || uniqueValues(ys)) return [mid(xs), mid(ys)];\n  var i = -1;\n  var x = 0;\n  var y = 0;\n  var former;\n  var current = xs.length - 1;\n  var diff;\n  var k = 0;\n\n  while (++i < xs.length) {\n    former = current;\n    current = i;\n    k += diff = xs[former] * ys[current] - xs[current] * ys[former];\n    x += (xs[former] + xs[current]) * diff;\n    y += (ys[former] + ys[current]) * diff;\n  }\n\n  k *= 3;\n  return [x / k, y / k];\n}\n/**\n * @ignore\n * 获取需要替换的属性，如果原先图形元素存在，而新图形不存在，则设置 undefined\n */\n\nexport function getReplaceAttrs(sourceShape, targetShape) {\n  var originAttrs = sourceShape.attr();\n  var newAttrs = targetShape.attr();\n  each(originAttrs, function (v, k) {\n    if (newAttrs[k] === undefined) {\n      newAttrs[k] = undefined;\n    }\n  });\n  return newAttrs;\n}","map":{"version":3,"mappings":"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","names":["each","isEmpty","isNumber","isNumberEqual","max","min","getPointsBox","points","minX","x","maxX","minY","y","maxY","point","centerX","centerY","uniqueValues","array","Array","from","Set","length","mid","polarToCartesian","radius","angleInRadian","Math","cos","sin","getSectorPath","startAngleInRadian","endAngleInRadian","innerRadius","start","end","innerStart","innerEnd","PI","middlePoint","innerMiddlePoint","circlePathCommands","push","arcSweep","sectorPathCommands","getArcPath","getAngle","shapeModel","coordinate","box","endAngle","startAngle","coordStartAngle","coordEndAngle","diffAngle","isTransposed","getPolygonCentroid","xs","ys","i","former","current","diff","k","getReplaceAttrs","sourceShape","targetShape","originAttrs","attr","newAttrs","v","undefined"],"sourceRoot":"","sources":["../../src/util/graphics.ts"],"sourcesContent":["import { BBox } from '@antv/g-svg';\nimport { each, isEmpty, isNumber, isNumberEqual, max, min } from '@antv/util';\nimport { Coordinate, IShape, Point } from '../dependents';\nimport { ShapeInfo } from '../interface';\n\n// 获取图形的包围盒\nfunction getPointsBox(points) {\n  if (isEmpty(points)) {\n    return null;\n  }\n\n  let minX = points[0].x;\n  let maxX = points[0].x;\n  let minY = points[0].y;\n  let maxY = points[0].y;\n  each(points, (point) => {\n    minX = minX > point.x ? point.x : minX;\n    maxX = maxX < point.x ? point.x : maxX;\n    minY = minY > point.y ? point.y : minY;\n    maxY = maxY < point.y ? point.y : maxY;\n  });\n\n  return {\n    minX,\n    maxX,\n    minY,\n    maxY,\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n  };\n}\n\nfunction uniqueValues<T = number>(array: T[]) {\n  return Array.from(new Set(array)).length === 1;\n}\n\nfunction mid(array: number[]) {\n  return (min(array) + max(array)) / 2;\n}\n\n/**\n * @ignore\n * 根据弧度计算极坐标系下的坐标点\n * @param centerX\n * @param centerY\n * @param radius\n * @param angleInRadian\n * @returns\n */\nexport function polarToCartesian(centerX: number, centerY: number, radius: number, angleInRadian: number) {\n  return {\n    x: centerX + radius * Math.cos(angleInRadian),\n    y: centerY + radius * Math.sin(angleInRadian),\n  };\n}\n\n/**\n * @ignore\n * 根据起始角度计算绘制扇形的 path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nexport function getSectorPath(\n  centerX: number,\n  centerY: number,\n  radius: number,\n  startAngleInRadian: number,\n  endAngleInRadian: number,\n  innerRadius: number = 0\n) {\n  const start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  const end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n\n  const innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);\n  const innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);\n\n  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {\n    // 整个圆是分割成两个圆\n    const middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    const innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);\n    const circlePathCommands = [\n      ['M', start.x, start.y],\n      ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n      ['A', radius, radius, 0, 1, 1, end.x, end.y],\n      ['M', innerStart.x, innerStart.y],\n    ];\n    if (innerRadius) {\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);\n    }\n\n    circlePathCommands.push(['M', start.x, start.y]);\n    circlePathCommands.push(['Z']);\n\n    return circlePathCommands;\n  }\n\n  const arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  const sectorPathCommands = [\n    ['M', start.x, start.y],\n    ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n    ['L', innerEnd.x, innerEnd.y],\n  ];\n  if (innerRadius) {\n    sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);\n  }\n  sectorPathCommands.push(['L', start.x, start.y]);\n  sectorPathCommands.push(['Z']);\n\n  return sectorPathCommands;\n}\n\n/**\n * @ignore\n * Gets arc path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nexport function getArcPath(\n  centerX: number,\n  centerY: number,\n  radius: number,\n  startAngleInRadian: number,\n  endAngleInRadian: number\n) {\n  const start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  const end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n\n  if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {\n    const middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    return [\n      ['M', start.x, start.y],\n      ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n      ['A', radius, radius, 0, 1, 1, start.x, start.y],\n      ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],\n      ['A', radius, radius, 0, 1, 0, start.x, start.y],\n      ['Z'],\n    ];\n  }\n  const arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  return [\n    ['M', start.x, start.y],\n    ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n  ];\n}\n\n/**\n * @ignore\n * 从数据模型中的 points 换算角度\n * @param shapeModel\n * @param coordinate\n * @returns\n */\nexport function getAngle(shapeModel: ShapeInfo, coordinate: Coordinate) {\n  const points = shapeModel.points;\n  const box = getPointsBox(points);\n  let endAngle;\n  let startAngle;\n  const { startAngle: coordStartAngle, endAngle: coordEndAngle } = coordinate;\n  const diffAngle = coordEndAngle - coordStartAngle;\n\n  if (coordinate.isTransposed) {\n    endAngle = box.maxY * diffAngle;\n    startAngle = box.minY * diffAngle;\n  } else {\n    endAngle = box.maxX * diffAngle;\n    startAngle = box.minX * diffAngle;\n  }\n  endAngle += coordStartAngle;\n  startAngle += coordStartAngle;\n  return {\n    startAngle,\n    endAngle,\n  };\n}\n\n/**\n * @ignore\n * 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon\n */\nexport function getPolygonCentroid(xs: number | number[], ys: number | number[]) {\n  if (isNumber(xs) && isNumber(ys)) {\n    // 普通色块图，xs 和 ys 是数值\n    return [xs, ys];\n  }\n\n  xs = xs as number[];\n  ys = ys as number[];\n  // 当这个 polygon 的点在一条线上的时候\n  // 也就是说 xs 里面的值都相同，比如：[1, 1, 1, 1]\n  // 或者说 ys 里面的值都相同，比如：[0, 0, 0, 0]\n  // 下面计算得到的 k = 0\n  // 导致返回的值是 [NaN, NaN]\n  // 所以这里做相应的处理\n  if (uniqueValues(xs) || uniqueValues(ys)) return [mid(xs), mid(ys)];\n\n  let i = -1;\n  let x = 0;\n  let y = 0;\n  let former;\n  let current = xs.length - 1;\n  let diff;\n  let k = 0;\n  while (++i < xs.length) {\n    former = current;\n    current = i;\n    k += diff = xs[former] * ys[current] - xs[current] * ys[former];\n    x += (xs[former] + xs[current]) * diff;\n    y += (ys[former] + ys[current]) * diff;\n  }\n  k *= 3;\n  return [x / k, y / k];\n}\n\n/**\n * @ignore\n * 获取需要替换的属性，如果原先图形元素存在，而新图形不存在，则设置 undefined\n */\nexport function getReplaceAttrs(sourceShape: IShape, targetShape: IShape) {\n  const originAttrs = sourceShape.attr();\n  const newAttrs = targetShape.attr();\n  each(originAttrs, (v, k) => {\n    if (newAttrs[k] === undefined) {\n      newAttrs[k] = undefined;\n    }\n  });\n  return newAttrs;\n}\n"]},"metadata":{},"sourceType":"module"}