{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.fmin = global.fmin || {});\n})(this, function (exports) {\n  'use strict';\n  /** finds the zeros of a function, given two starting points (which must\n   * have opposite signs */\n\n  function bisect(f, a, b, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || 100,\n        tolerance = parameters.tolerance || 1e-10,\n        fA = f(a),\n        fB = f(b),\n        delta = b - a;\n\n    if (fA * fB > 0) {\n      throw \"Initial bisect points must have opposite signs\";\n    }\n\n    if (fA === 0) return a;\n    if (fB === 0) return b;\n\n    for (var i = 0; i < maxIterations; ++i) {\n      delta /= 2;\n      var mid = a + delta,\n          fMid = f(mid);\n\n      if (fMid * fA >= 0) {\n        a = mid;\n      }\n\n      if (Math.abs(delta) < tolerance || fMid === 0) {\n        return mid;\n      }\n    }\n\n    return a + delta;\n  } // need some basic operations on vectors, rather than adding a dependency,\n  // just define here\n\n\n  function zeros(x) {\n    var r = new Array(x);\n\n    for (var i = 0; i < x; ++i) {\n      r[i] = 0;\n    }\n\n    return r;\n  }\n\n  function zerosM(x, y) {\n    return zeros(x).map(function () {\n      return zeros(y);\n    });\n  }\n\n  function dot(a, b) {\n    var ret = 0;\n\n    for (var i = 0; i < a.length; ++i) {\n      ret += a[i] * b[i];\n    }\n\n    return ret;\n  }\n\n  function norm2(a) {\n    return Math.sqrt(dot(a, a));\n  }\n\n  function scale(ret, value, c) {\n    for (var i = 0; i < value.length; ++i) {\n      ret[i] = value[i] * c;\n    }\n  }\n\n  function weightedSum(ret, w1, v1, w2, v2) {\n    for (var j = 0; j < ret.length; ++j) {\n      ret[j] = w1 * v1[j] + w2 * v2[j];\n    }\n  }\n  /** minimizes a function using the downhill simplex method */\n\n\n  function nelderMead(f, x0, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || x0.length * 200,\n        nonZeroDelta = parameters.nonZeroDelta || 1.05,\n        zeroDelta = parameters.zeroDelta || 0.001,\n        minErrorDelta = parameters.minErrorDelta || 1e-6,\n        minTolerance = parameters.minErrorDelta || 1e-5,\n        rho = parameters.rho !== undefined ? parameters.rho : 1,\n        chi = parameters.chi !== undefined ? parameters.chi : 2,\n        psi = parameters.psi !== undefined ? parameters.psi : -0.5,\n        sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5,\n        maxDiff; // initialize simplex.\n\n    var N = x0.length,\n        simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n\n    for (var i = 0; i < N; ++i) {\n      var point = x0.slice();\n      point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n      simplex[i + 1] = point;\n      simplex[i + 1].fx = f(point);\n      simplex[i + 1].id = i + 1;\n    }\n\n    function updateSimplex(value) {\n      for (var i = 0; i < value.length; i++) {\n        simplex[N][i] = value[i];\n      }\n\n      simplex[N].fx = value.fx;\n    }\n\n    var sortOrder = function (a, b) {\n      return a.fx - b.fx;\n    };\n\n    var centroid = x0.slice(),\n        reflected = x0.slice(),\n        contracted = x0.slice(),\n        expanded = x0.slice();\n\n    for (var iteration = 0; iteration < maxIterations; ++iteration) {\n      simplex.sort(sortOrder);\n\n      if (parameters.history) {\n        // copy the simplex (since later iterations will mutate) and\n        // sort it to have a consistent order between iterations\n        var sortedSimplex = simplex.map(function (x) {\n          var state = x.slice();\n          state.fx = x.fx;\n          state.id = x.id;\n          return state;\n        });\n        sortedSimplex.sort(function (a, b) {\n          return a.id - b.id;\n        });\n        parameters.history.push({\n          x: simplex[0].slice(),\n          fx: simplex[0].fx,\n          simplex: sortedSimplex\n        });\n      }\n\n      maxDiff = 0;\n\n      for (i = 0; i < N; ++i) {\n        maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n      }\n\n      if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {\n        break;\n      } // compute the centroid of all but the worst point in the simplex\n\n\n      for (i = 0; i < N; ++i) {\n        centroid[i] = 0;\n\n        for (var j = 0; j < N; ++j) {\n          centroid[i] += simplex[j][i];\n        }\n\n        centroid[i] /= N;\n      } // reflect the worst point past the centroid  and compute loss at reflected\n      // point\n\n\n      var worst = simplex[N];\n      weightedSum(reflected, 1 + rho, centroid, -rho, worst);\n      reflected.fx = f(reflected); // if the reflected point is the best seen, then possibly expand\n\n      if (reflected.fx < simplex[0].fx) {\n        weightedSum(expanded, 1 + chi, centroid, -chi, worst);\n        expanded.fx = f(expanded);\n\n        if (expanded.fx < reflected.fx) {\n          updateSimplex(expanded);\n        } else {\n          updateSimplex(reflected);\n        }\n      } // if the reflected point is worse than the second worst, we need to\n      // contract\n      else if (reflected.fx >= simplex[N - 1].fx) {\n        var shouldReduce = false;\n\n        if (reflected.fx > worst.fx) {\n          // do an inside contraction\n          weightedSum(contracted, 1 + psi, centroid, -psi, worst);\n          contracted.fx = f(contracted);\n\n          if (contracted.fx < worst.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        } else {\n          // do an outside contraction\n          weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);\n          contracted.fx = f(contracted);\n\n          if (contracted.fx < reflected.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        }\n\n        if (shouldReduce) {\n          // if we don't contract here, we're done\n          if (sigma >= 1) break; // do a reduction\n\n          for (i = 1; i < simplex.length; ++i) {\n            weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n            simplex[i].fx = f(simplex[i]);\n          }\n        }\n      } else {\n        updateSimplex(reflected);\n      }\n    }\n\n    simplex.sort(sortOrder);\n    return {\n      fx: simplex[0].fx,\n      x: simplex[0]\n    };\n  } /// searches along line 'pk' for a point that satifies the wolfe conditions\n  /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n  /// f : objective function\n  /// pk : search direction\n  /// current: object containing current gradient/loss\n  /// next: output: contains next gradient/loss\n  /// returns a: step size taken\n\n\n  function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n    var phi0 = current.fx,\n        phiPrime0 = dot(current.fxprime, pk),\n        phi = phi0,\n        phi_old = phi0,\n        phiPrime = phiPrime0,\n        a0 = 0;\n    a = a || 1;\n    c1 = c1 || 1e-6;\n    c2 = c2 || 0.1;\n\n    function zoom(a_lo, a_high, phi_lo) {\n      for (var iteration = 0; iteration < 16; ++iteration) {\n        a = (a_lo + a_high) / 2;\n        weightedSum(next.x, 1.0, current.x, a, pk);\n        phi = next.fx = f(next.x, next.fxprime);\n        phiPrime = dot(next.fxprime, pk);\n\n        if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {\n          a_high = a;\n        } else {\n          if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n            return a;\n          }\n\n          if (phiPrime * (a_high - a_lo) >= 0) {\n            a_high = a_lo;\n          }\n\n          a_lo = a;\n          phi_lo = phi;\n        }\n      }\n\n      return 0;\n    }\n\n    for (var iteration = 0; iteration < 10; ++iteration) {\n      weightedSum(next.x, 1.0, current.x, a, pk);\n      phi = next.fx = f(next.x, next.fxprime);\n      phiPrime = dot(next.fxprime, pk);\n\n      if (phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) {\n        return zoom(a0, a, phi_old);\n      }\n\n      if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n        return a;\n      }\n\n      if (phiPrime >= 0) {\n        return zoom(a, a0, phi);\n      }\n\n      phi_old = phi;\n      a0 = a;\n      a *= 2;\n    }\n\n    return a;\n  }\n\n  function conjugateGradient(f, initial, params) {\n    // allocate all memory up front here, keep out of the loop for perfomance\n    // reasons\n    var current = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    },\n        next = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    },\n        yk = initial.slice(),\n        pk,\n        temp,\n        a = 1,\n        maxIterations;\n    params = params || {};\n    maxIterations = params.maxIterations || initial.length * 20;\n    current.fx = f(current.x, current.fxprime);\n    pk = current.fxprime.slice();\n    scale(pk, current.fxprime, -1);\n\n    for (var i = 0; i < maxIterations; ++i) {\n      a = wolfeLineSearch(f, pk, current, next, a); // todo: history in wrong spot?\n\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice(),\n          alpha: a\n        });\n      }\n\n      if (!a) {\n        // faiiled to find point that satifies wolfe conditions.\n        // reset direction for next iteration\n        scale(pk, current.fxprime, -1);\n      } else {\n        // update direction using Polakâ€“Ribiere CG method\n        weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n        var delta_k = dot(current.fxprime, current.fxprime),\n            beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n        weightedSum(pk, beta_k, pk, -1, next.fxprime);\n        temp = current;\n        current = next;\n        next = temp;\n      }\n\n      if (norm2(current.fxprime) <= 1e-5) {\n        break;\n      }\n    }\n\n    if (params.history) {\n      params.history.push({\n        x: current.x.slice(),\n        fx: current.fx,\n        fxprime: current.fxprime.slice(),\n        alpha: a\n      });\n    }\n\n    return current;\n  }\n\n  function gradientDescent(f, initial, params) {\n    params = params || {};\n    var maxIterations = params.maxIterations || initial.length * 100,\n        learnRate = params.learnRate || 0.001,\n        current = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    };\n\n    for (var i = 0; i < maxIterations; ++i) {\n      current.fx = f(current.x, current.fxprime);\n\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice()\n        });\n      }\n\n      weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n\n      if (norm2(current.fxprime) <= 1e-5) {\n        break;\n      }\n    }\n\n    return current;\n  }\n\n  function gradientDescentLineSearch(f, initial, params) {\n    params = params || {};\n    var current = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    },\n        next = {\n      x: initial.slice(),\n      fx: 0,\n      fxprime: initial.slice()\n    },\n        maxIterations = params.maxIterations || initial.length * 100,\n        learnRate = params.learnRate || 1,\n        pk = initial.slice(),\n        c1 = params.c1 || 1e-3,\n        c2 = params.c2 || 0.1,\n        temp,\n        functionCalls = [];\n\n    if (params.history) {\n      // wrap the function call to track linesearch samples\n      var inner = f;\n\n      f = function (x, fxprime) {\n        functionCalls.push(x.slice());\n        return inner(x, fxprime);\n      };\n    }\n\n    current.fx = f(current.x, current.fxprime);\n\n    for (var i = 0; i < maxIterations; ++i) {\n      scale(pk, current.fxprime, -1);\n      learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice(),\n          functionCalls: functionCalls,\n          learnRate: learnRate,\n          alpha: learnRate\n        });\n        functionCalls = [];\n      }\n\n      temp = current;\n      current = next;\n      next = temp;\n      if (learnRate === 0 || norm2(current.fxprime) < 1e-5) break;\n    }\n\n    return current;\n  }\n\n  exports.bisect = bisect;\n  exports.nelderMead = nelderMead;\n  exports.conjugateGradient = conjugateGradient;\n  exports.gradientDescent = gradientDescent;\n  exports.gradientDescentLineSearch = gradientDescentLineSearch;\n  exports.zeros = zeros;\n  exports.zerosM = zerosM;\n  exports.norm2 = norm2;\n  exports.weightedSum = weightedSum;\n  exports.scale = scale;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","fmin","bisect","f","a","b","parameters","maxIterations","tolerance","fA","fB","delta","i","mid","fMid","Math","abs","zeros","x","r","Array","zerosM","y","map","dot","ret","length","norm2","sqrt","scale","value","c","weightedSum","w1","v1","w2","v2","j","nelderMead","x0","nonZeroDelta","zeroDelta","minErrorDelta","minTolerance","rho","undefined","chi","psi","sigma","maxDiff","N","simplex","fx","id","point","slice","updateSimplex","sortOrder","centroid","reflected","contracted","expanded","iteration","sort","history","sortedSimplex","state","push","max","worst","shouldReduce","wolfeLineSearch","pk","current","next","c1","c2","phi0","phiPrime0","fxprime","phi","phi_old","phiPrime","a0","zoom","a_lo","a_high","phi_lo","conjugateGradient","initial","params","yk","temp","alpha","delta_k","beta_k","gradientDescent","learnRate","gradientDescentLineSearch","functionCalls","inner"],"sources":["C:/Users/Administrator/Desktop/wordcloud_new/node_modules/fmin/build/fmin.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.fmin = global.fmin || {})));\n}(this, function (exports) { 'use strict';\n\n    /** finds the zeros of a function, given two starting points (which must\n     * have opposite signs */\n    function bisect(f, a, b, parameters) {\n        parameters = parameters || {};\n        var maxIterations = parameters.maxIterations || 100,\n            tolerance = parameters.tolerance || 1e-10,\n            fA = f(a),\n            fB = f(b),\n            delta = b - a;\n\n        if (fA * fB > 0) {\n            throw \"Initial bisect points must have opposite signs\";\n        }\n\n        if (fA === 0) return a;\n        if (fB === 0) return b;\n\n        for (var i = 0; i < maxIterations; ++i) {\n            delta /= 2;\n            var mid = a + delta,\n                fMid = f(mid);\n\n            if (fMid * fA >= 0) {\n                a = mid;\n            }\n\n            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\n                return mid;\n            }\n        }\n        return a + delta;\n    }\n\n    // need some basic operations on vectors, rather than adding a dependency,\n    // just define here\n    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }\n    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }\n\n    function dot(a, b) {\n        var ret = 0;\n        for (var i = 0; i < a.length; ++i) {\n            ret += a[i] * b[i];\n        }\n        return ret;\n    }\n\n    function norm2(a)  {\n        return Math.sqrt(dot(a, a));\n    }\n\n    function scale(ret, value, c) {\n        for (var i = 0; i < value.length; ++i) {\n            ret[i] = value[i] * c;\n        }\n    }\n\n    function weightedSum(ret, w1, v1, w2, v2) {\n        for (var j = 0; j < ret.length; ++j) {\n            ret[j] = w1 * v1[j] + w2 * v2[j];\n        }\n    }\n\n    /** minimizes a function using the downhill simplex method */\n    function nelderMead(f, x0, parameters) {\n        parameters = parameters || {};\n\n        var maxIterations = parameters.maxIterations || x0.length * 200,\n            nonZeroDelta = parameters.nonZeroDelta || 1.05,\n            zeroDelta = parameters.zeroDelta || 0.001,\n            minErrorDelta = parameters.minErrorDelta || 1e-6,\n            minTolerance = parameters.minErrorDelta || 1e-5,\n            rho = (parameters.rho !== undefined) ? parameters.rho : 1,\n            chi = (parameters.chi !== undefined) ? parameters.chi : 2,\n            psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,\n            sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,\n            maxDiff;\n\n        // initialize simplex.\n        var N = x0.length,\n            simplex = new Array(N + 1);\n        simplex[0] = x0;\n        simplex[0].fx = f(x0);\n        simplex[0].id = 0;\n        for (var i = 0; i < N; ++i) {\n            var point = x0.slice();\n            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n            simplex[i+1] = point;\n            simplex[i+1].fx = f(point);\n            simplex[i+1].id = i+1;\n        }\n\n        function updateSimplex(value) {\n            for (var i = 0; i < value.length; i++) {\n                simplex[N][i] = value[i];\n            }\n            simplex[N].fx = value.fx;\n        }\n\n        var sortOrder = function(a, b) { return a.fx - b.fx; };\n\n        var centroid = x0.slice(),\n            reflected = x0.slice(),\n            contracted = x0.slice(),\n            expanded = x0.slice();\n\n        for (var iteration = 0; iteration < maxIterations; ++iteration) {\n            simplex.sort(sortOrder);\n\n            if (parameters.history) {\n                // copy the simplex (since later iterations will mutate) and\n                // sort it to have a consistent order between iterations\n                var sortedSimplex = simplex.map(function (x) {\n                    var state = x.slice();\n                    state.fx = x.fx;\n                    state.id = x.id;\n                    return state;\n                });\n                sortedSimplex.sort(function(a,b) { return a.id - b.id; });\n\n                parameters.history.push({x: simplex[0].slice(),\n                                         fx: simplex[0].fx,\n                                         simplex: sortedSimplex});\n            }\n\n            maxDiff = 0;\n            for (i = 0; i < N; ++i) {\n                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n            }\n\n            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\n                (maxDiff < minTolerance)) {\n                break;\n            }\n\n            // compute the centroid of all but the worst point in the simplex\n            for (i = 0; i < N; ++i) {\n                centroid[i] = 0;\n                for (var j = 0; j < N; ++j) {\n                    centroid[i] += simplex[j][i];\n                }\n                centroid[i] /= N;\n            }\n\n            // reflect the worst point past the centroid  and compute loss at reflected\n            // point\n            var worst = simplex[N];\n            weightedSum(reflected, 1+rho, centroid, -rho, worst);\n            reflected.fx = f(reflected);\n\n            // if the reflected point is the best seen, then possibly expand\n            if (reflected.fx < simplex[0].fx) {\n                weightedSum(expanded, 1+chi, centroid, -chi, worst);\n                expanded.fx = f(expanded);\n                if (expanded.fx < reflected.fx) {\n                    updateSimplex(expanded);\n                }  else {\n                    updateSimplex(reflected);\n                }\n            }\n\n            // if the reflected point is worse than the second worst, we need to\n            // contract\n            else if (reflected.fx >= simplex[N-1].fx) {\n                var shouldReduce = false;\n\n                if (reflected.fx > worst.fx) {\n                    // do an inside contraction\n                    weightedSum(contracted, 1+psi, centroid, -psi, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < worst.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                } else {\n                    // do an outside contraction\n                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < reflected.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                }\n\n                if (shouldReduce) {\n                    // if we don't contract here, we're done\n                    if (sigma >= 1) break;\n\n                    // do a reduction\n                    for (i = 1; i < simplex.length; ++i) {\n                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                        simplex[i].fx = f(simplex[i]);\n                    }\n                }\n            } else {\n                updateSimplex(reflected);\n            }\n        }\n\n        simplex.sort(sortOrder);\n        return {fx : simplex[0].fx,\n                x : simplex[0]};\n    }\n\n    /// searches along line 'pk' for a point that satifies the wolfe conditions\n    /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n    /// f : objective function\n    /// pk : search direction\n    /// current: object containing current gradient/loss\n    /// next: output: contains next gradient/loss\n    /// returns a: step size taken\n    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),\n            phi = phi0, phi_old = phi0,\n            phiPrime = phiPrime0,\n            a0 = 0;\n\n        a = a || 1;\n        c1 = c1 || 1e-6;\n        c2 = c2 || 0.1;\n\n        function zoom(a_lo, a_high, phi_lo) {\n            for (var iteration = 0; iteration < 16; ++iteration) {\n                a = (a_lo + a_high)/2;\n                weightedSum(next.x, 1.0, current.x, a, pk);\n                phi = next.fx = f(next.x, next.fxprime);\n                phiPrime = dot(next.fxprime, pk);\n\n                if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                    (phi >= phi_lo)) {\n                    a_high = a;\n\n                } else  {\n                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                        return a;\n                    }\n\n                    if (phiPrime * (a_high - a_lo) >=0) {\n                        a_high = a_lo;\n                    }\n\n                    a_lo = a;\n                    phi_lo = phi;\n                }\n            }\n\n            return 0;\n        }\n\n        for (var iteration = 0; iteration < 10; ++iteration) {\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                (iteration && (phi >= phi_old))) {\n                return zoom(a0, a, phi_old);\n            }\n\n            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                return a;\n            }\n\n            if (phiPrime >= 0 ) {\n                return zoom(a, a0, phi);\n            }\n\n            phi_old = phi;\n            a0 = a;\n            a *= 2;\n        }\n\n        return a;\n    }\n\n    function conjugateGradient(f, initial, params) {\n        // allocate all memory up front here, keep out of the loop for perfomance\n        // reasons\n        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            yk = initial.slice(),\n            pk, temp,\n            a = 1,\n            maxIterations;\n\n        params = params || {};\n        maxIterations = params.maxIterations || initial.length * 20;\n\n        current.fx = f(current.x, current.fxprime);\n        pk = current.fxprime.slice();\n        scale(pk, current.fxprime,-1);\n\n        for (var i = 0; i < maxIterations; ++i) {\n            a = wolfeLineSearch(f, pk, current, next, a);\n\n            // todo: history in wrong spot?\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice(),\n                                     alpha: a});\n            }\n\n            if (!a) {\n                // faiiled to find point that satifies wolfe conditions.\n                // reset direction for next iteration\n                scale(pk, current.fxprime, -1);\n\n            } else {\n                // update direction using Polakâ€“Ribiere CG method\n                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\n                var delta_k = dot(current.fxprime, current.fxprime),\n                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\n                weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\n                temp = current;\n                current = next;\n                next = temp;\n            }\n\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n\n        if (params.history) {\n            params.history.push({x: current.x.slice(),\n                                 fx: current.fx,\n                                 fxprime: current.fxprime.slice(),\n                                 alpha: a});\n        }\n\n        return current;\n    }\n\n    function gradientDescent(f, initial, params) {\n        params = params || {};\n        var maxIterations = params.maxIterations || initial.length * 100,\n            learnRate = params.learnRate || 0.001,\n            current = {x: initial.slice(), fx: 0, fxprime: initial.slice()};\n\n        for (var i = 0; i < maxIterations; ++i) {\n            current.fx = f(current.x, current.fxprime);\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice()});\n            }\n\n            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n\n        return current;\n    }\n\n    function gradientDescentLineSearch(f, initial, params) {\n        params = params || {};\n        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            maxIterations = params.maxIterations || initial.length * 100,\n            learnRate = params.learnRate || 1,\n            pk = initial.slice(),\n            c1 = params.c1 || 1e-3,\n            c2 = params.c2 || 0.1,\n            temp,\n            functionCalls = [];\n\n        if (params.history) {\n            // wrap the function call to track linesearch samples\n            var inner = f;\n            f = function(x, fxprime) {\n                functionCalls.push(x.slice());\n                return inner(x, fxprime);\n            };\n        }\n\n        current.fx = f(current.x, current.fxprime);\n        for (var i = 0; i < maxIterations; ++i) {\n            scale(pk, current.fxprime, -1);\n            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice(),\n                                     functionCalls: functionCalls,\n                                     learnRate: learnRate,\n                                     alpha: learnRate});\n                functionCalls = [];\n            }\n\n\n            temp = current;\n            current = next;\n            next = temp;\n\n            if ((learnRate === 0) || (norm2(current.fxprime) < 1e-5)) break;\n        }\n\n        return current;\n    }\n\n    exports.bisect = bisect;\n    exports.nelderMead = nelderMead;\n    exports.conjugateGradient = conjugateGradient;\n    exports.gradientDescent = gradientDescent;\n    exports.gradientDescentLineSearch = gradientDescentLineSearch;\n    exports.zeros = zeros;\n    exports.zerosM = zerosM;\n    exports.norm2 = norm2;\n    exports.weightedSum = weightedSum;\n    exports.scale = scale;\n\n}));"],"mappings":"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"},"metadata":{},"sourceType":"script"}