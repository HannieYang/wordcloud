{"ast":null,"code":"var SMALL = 1e-10;\n/** Returns the intersection area of a bunch of circles (where each circle\n is an object having an x,y and radius property) */\n\nexport function intersectionArea(circles, stats) {\n  // get all the intersection points of the circles\n  var intersectionPoints = getIntersectionPoints(circles); // filter out points that aren't included in all the circles\n\n  var innerPoints = intersectionPoints.filter(function (p) {\n    return containedInCircles(p, circles);\n  });\n  var arcArea = 0,\n      polygonArea = 0,\n      i;\n  var arcs = []; // if we have intersection points that are within all the circles,\n  // then figure out the area contained by them\n\n  if (innerPoints.length > 1) {\n    // sort the points by angle from the center of the polygon, which lets\n    // us just iterate over points to get the edges\n    var center = getCenter(innerPoints);\n\n    for (i = 0; i < innerPoints.length; ++i) {\n      var p = innerPoints[i];\n      p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n    }\n\n    innerPoints.sort(function (a, b) {\n      return b.angle - a.angle;\n    }); // iterate over all points, get arc between the points\n    // and update the areas\n\n    var p2 = innerPoints[innerPoints.length - 1];\n\n    for (i = 0; i < innerPoints.length; ++i) {\n      var p1 = innerPoints[i]; // polygon area updates easily ...\n\n      polygonArea += (p2.x + p1.x) * (p1.y - p2.y); // updating the arc area is a little more involved\n\n      var midPoint = {\n        x: (p1.x + p2.x) / 2,\n        y: (p1.y + p2.y) / 2\n      };\n      var arc = null;\n\n      for (var j = 0; j < p1.parentIndex.length; ++j) {\n        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n          // figure out the angle halfway between the two points\n          // on the current circle\n          var circle = circles[p1.parentIndex[j]],\n              a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n              a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n          var angleDiff = a2 - a1;\n\n          if (angleDiff < 0) {\n            angleDiff += 2 * Math.PI;\n          } // and use that angle to figure out the width of the\n          // arc\n\n\n          var a = a2 - angleDiff / 2;\n          var width = distance(midPoint, {\n            x: circle.x + circle.radius * Math.sin(a),\n            y: circle.y + circle.radius * Math.cos(a)\n          }); // clamp the width to the largest is can actually be\n          // (sometimes slightly overflows because of FP errors)\n\n          if (width > circle.radius * 2) {\n            width = circle.radius * 2;\n          } // pick the circle whose arc has the smallest width\n\n\n          if (arc === null || arc.width > width) {\n            arc = {\n              circle: circle,\n              width: width,\n              p1: p1,\n              p2: p2\n            };\n          }\n        }\n      }\n\n      if (arc !== null) {\n        arcs.push(arc);\n        arcArea += circleArea(arc.circle.radius, arc.width);\n        p2 = p1;\n      }\n    }\n  } else {\n    // no intersection points, is either disjoint - or is completely\n    // overlapped. figure out which by examining the smallest circle\n    var smallest = circles[0];\n\n    for (i = 1; i < circles.length; ++i) {\n      if (circles[i].radius < smallest.radius) {\n        smallest = circles[i];\n      }\n    } // make sure the smallest circle is completely contained in all\n    // the other circles\n\n\n    var disjoint = false;\n\n    for (i = 0; i < circles.length; ++i) {\n      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n        disjoint = true;\n        break;\n      }\n    }\n\n    if (disjoint) {\n      arcArea = polygonArea = 0;\n    } else {\n      arcArea = smallest.radius * smallest.radius * Math.PI;\n      arcs.push({\n        circle: smallest,\n        p1: {\n          x: smallest.x,\n          y: smallest.y + smallest.radius\n        },\n        p2: {\n          x: smallest.x - SMALL,\n          y: smallest.y + smallest.radius\n        },\n        width: smallest.radius * 2\n      });\n    }\n  }\n\n  polygonArea /= 2;\n\n  if (stats) {\n    stats.area = arcArea + polygonArea;\n    stats.arcArea = arcArea;\n    stats.polygonArea = polygonArea;\n    stats.arcs = arcs;\n    stats.innerPoints = innerPoints;\n    stats.intersectionPoints = intersectionPoints;\n  }\n\n  return arcArea + polygonArea;\n}\n/** returns whether a point is contained by all of a list of circles */\n\nexport function containedInCircles(point, circles) {\n  for (var i = 0; i < circles.length; ++i) {\n    if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/** Gets all intersection points between a bunch of circles */\n\nfunction getIntersectionPoints(circles) {\n  var ret = [];\n\n  for (var i = 0; i < circles.length; ++i) {\n    for (var j = i + 1; j < circles.length; ++j) {\n      var intersect = circleCircleIntersection(circles[i], circles[j]);\n\n      for (var k = 0; k < intersect.length; ++k) {\n        var p = intersect[k];\n        p.parentIndex = [i, j];\n        ret.push(p);\n      }\n    }\n  }\n\n  return ret;\n}\n/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\n\n\nexport function circleArea(r, width) {\n  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n/** euclidean distance between two points */\n\nexport function distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n/** Returns the overlap area of two circles of radius r1 and r2 - that\nhave their centers separated by distance d. Simpler faster\ncircle intersection for only two circles */\n\nexport function circleOverlap(r1, r2, d) {\n  // no overlap\n  if (d >= r1 + r2) {\n    return 0;\n  } // completely overlapped\n\n\n  if (d <= Math.abs(r1 - r2)) {\n    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n  }\n\n  var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n      w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n  return circleArea(r1, w1) + circleArea(r2, w2);\n}\n/** Given two circles (containing a x/y/radius attributes),\nreturns the intersecting points if possible.\nnote: doesn't handle cases where there are infinitely many\nintersection points (circles are equivalent):, or only one intersection point*/\n\nexport function circleCircleIntersection(p1, p2) {\n  var d = distance(p1, p2),\n      r1 = p1.radius,\n      r2 = p2.radius; // if to far away, or self contained - can't be done\n\n  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n    return [];\n  }\n\n  var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n      h = Math.sqrt(r1 * r1 - a * a),\n      x0 = p1.x + a * (p2.x - p1.x) / d,\n      y0 = p1.y + a * (p2.y - p1.y) / d,\n      rx = -(p2.y - p1.y) * (h / d),\n      ry = -(p2.x - p1.x) * (h / d);\n  return [{\n    x: x0 + rx,\n    y: y0 - ry\n  }, {\n    x: x0 - rx,\n    y: y0 + ry\n  }];\n}\n/** Returns the center of a bunch of points */\n\nexport function getCenter(points) {\n  var center = {\n    x: 0,\n    y: 0\n  };\n\n  for (var i = 0; i < points.length; ++i) {\n    center.x += points[i].x;\n    center.y += points[i].y;\n  }\n\n  center.x /= points.length;\n  center.y /= points.length;\n  return center;\n}","map":{"version":3,"mappings":"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","names":["SMALL","intersectionArea","circles","stats","intersectionPoints","getIntersectionPoints","innerPoints","filter","p","containedInCircles","arcArea","polygonArea","i","arcs","length","center","getCenter","angle","Math","atan2","x","y","sort","a","b","p2","p1","midPoint","arc","j","parentIndex","indexOf","circle","a1","a2","angleDiff","PI","width","distance","radius","sin","cos","push","circleArea","smallest","disjoint","abs","area","point","ret","intersect","circleCircleIntersection","k","r","acos","sqrt","circleOverlap","r1","r2","d","min","w1","w2","h","x0","y0","rx","ry","points"],"sourceRoot":"","sources":["../../../../src/plots/venn/layout/circleintersection.ts"],"sourcesContent":["const SMALL = 1e-10;\n\n/** Returns the intersection area of a bunch of circles (where each circle\n is an object having an x,y and radius property) */\nexport function intersectionArea(circles, stats?: any) {\n  // get all the intersection points of the circles\n  const intersectionPoints = getIntersectionPoints(circles);\n\n  // filter out points that aren't included in all the circles\n  const innerPoints = intersectionPoints.filter(function (p) {\n    return containedInCircles(p, circles);\n  });\n\n  let arcArea = 0,\n    polygonArea = 0,\n    i;\n  const arcs = [];\n  // if we have intersection points that are within all the circles,\n  // then figure out the area contained by them\n  if (innerPoints.length > 1) {\n    // sort the points by angle from the center of the polygon, which lets\n    // us just iterate over points to get the edges\n    const center = getCenter(innerPoints);\n    for (i = 0; i < innerPoints.length; ++i) {\n      const p = innerPoints[i];\n      p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n    }\n    innerPoints.sort(function (a, b) {\n      return b.angle - a.angle;\n    });\n\n    // iterate over all points, get arc between the points\n    // and update the areas\n    let p2 = innerPoints[innerPoints.length - 1];\n    for (i = 0; i < innerPoints.length; ++i) {\n      const p1 = innerPoints[i];\n\n      // polygon area updates easily ...\n      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n      // updating the arc area is a little more involved\n      const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };\n      let arc = null;\n\n      for (let j = 0; j < p1.parentIndex.length; ++j) {\n        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n          // figure out the angle halfway between the two points\n          // on the current circle\n          const circle = circles[p1.parentIndex[j]],\n            a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n            a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n          let angleDiff = a2 - a1;\n          if (angleDiff < 0) {\n            angleDiff += 2 * Math.PI;\n          }\n\n          // and use that angle to figure out the width of the\n          // arc\n          const a = a2 - angleDiff / 2;\n          let width = distance(midPoint, {\n            x: circle.x + circle.radius * Math.sin(a),\n            y: circle.y + circle.radius * Math.cos(a),\n          });\n\n          // clamp the width to the largest is can actually be\n          // (sometimes slightly overflows because of FP errors)\n          if (width > circle.radius * 2) {\n            width = circle.radius * 2;\n          }\n\n          // pick the circle whose arc has the smallest width\n          if (arc === null || arc.width > width) {\n            arc = { circle: circle, width: width, p1: p1, p2: p2 };\n          }\n        }\n      }\n\n      if (arc !== null) {\n        arcs.push(arc);\n        arcArea += circleArea(arc.circle.radius, arc.width);\n        p2 = p1;\n      }\n    }\n  } else {\n    // no intersection points, is either disjoint - or is completely\n    // overlapped. figure out which by examining the smallest circle\n    let smallest = circles[0];\n    for (i = 1; i < circles.length; ++i) {\n      if (circles[i].radius < smallest.radius) {\n        smallest = circles[i];\n      }\n    }\n\n    // make sure the smallest circle is completely contained in all\n    // the other circles\n    let disjoint = false;\n    for (i = 0; i < circles.length; ++i) {\n      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n        disjoint = true;\n        break;\n      }\n    }\n\n    if (disjoint) {\n      arcArea = polygonArea = 0;\n    } else {\n      arcArea = smallest.radius * smallest.radius * Math.PI;\n      arcs.push({\n        circle: smallest,\n        p1: { x: smallest.x, y: smallest.y + smallest.radius },\n        p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },\n        width: smallest.radius * 2,\n      });\n    }\n  }\n\n  polygonArea /= 2;\n  if (stats) {\n    stats.area = arcArea + polygonArea;\n    stats.arcArea = arcArea;\n    stats.polygonArea = polygonArea;\n    stats.arcs = arcs;\n    stats.innerPoints = innerPoints;\n    stats.intersectionPoints = intersectionPoints;\n  }\n\n  return arcArea + polygonArea;\n}\n\n/** returns whether a point is contained by all of a list of circles */\nexport function containedInCircles(point, circles) {\n  for (let i = 0; i < circles.length; ++i) {\n    if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** Gets all intersection points between a bunch of circles */\nfunction getIntersectionPoints(circles) {\n  const ret = [];\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const intersect = circleCircleIntersection(circles[i], circles[j]);\n      for (let k = 0; k < intersect.length; ++k) {\n        const p: any = intersect[k];\n        p.parentIndex = [i, j];\n        ret.push(p);\n      }\n    }\n  }\n  return ret;\n}\n\n/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\nexport function circleArea(r, width) {\n  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n\n/** euclidean distance between two points */\nexport function distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n/** Returns the overlap area of two circles of radius r1 and r2 - that\nhave their centers separated by distance d. Simpler faster\ncircle intersection for only two circles */\nexport function circleOverlap(r1, r2, d) {\n  // no overlap\n  if (d >= r1 + r2) {\n    return 0;\n  }\n\n  // completely overlapped\n  if (d <= Math.abs(r1 - r2)) {\n    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n  }\n\n  const w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n    w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n  return circleArea(r1, w1) + circleArea(r2, w2);\n}\n\n/** Given two circles (containing a x/y/radius attributes),\nreturns the intersecting points if possible.\nnote: doesn't handle cases where there are infinitely many\nintersection points (circles are equivalent):, or only one intersection point*/\nexport function circleCircleIntersection(p1, p2) {\n  const d = distance(p1, p2),\n    r1 = p1.radius,\n    r2 = p2.radius;\n\n  // if to far away, or self contained - can't be done\n  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n    return [];\n  }\n\n  const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n    h = Math.sqrt(r1 * r1 - a * a),\n    x0 = p1.x + (a * (p2.x - p1.x)) / d,\n    y0 = p1.y + (a * (p2.y - p1.y)) / d,\n    rx = -(p2.y - p1.y) * (h / d),\n    ry = -(p2.x - p1.x) * (h / d);\n\n  return [\n    { x: x0 + rx, y: y0 - ry },\n    { x: x0 - rx, y: y0 + ry },\n  ];\n}\n\n/** Returns the center of a bunch of points */\nexport function getCenter(points) {\n  const center = { x: 0, y: 0 };\n  for (let i = 0; i < points.length; ++i) {\n    center.x += points[i].x;\n    center.y += points[i].y;\n  }\n  center.x /= points.length;\n  center.y /= points.length;\n  return center;\n}\n"]},"metadata":{},"sourceType":"module"}