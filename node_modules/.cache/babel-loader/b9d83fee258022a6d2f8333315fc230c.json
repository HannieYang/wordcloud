{"ast":null,"code":"import { each, isArray } from '@antv/util';\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nimport { splitPoints } from '../util/split-points';\nimport { getLineMarker } from './util';\n\nfunction getShapeAttrs(cfg, smooth, constraint) {\n  var isStack = cfg.isStack,\n      connectNulls = cfg.connectNulls,\n      isInCircle = cfg.isInCircle,\n      showSinglePoint = cfg.showSinglePoint;\n  var shapeAttrs = getStyle(cfg, true, false, 'lineWidth');\n  var points = getPathPoints(cfg.points, connectNulls, showSinglePoint); // 根据 connectNulls 值处理 points\n\n  var path = [];\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var eachLinePoints = points[i];\n    path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));\n  }\n\n  shapeAttrs.path = path;\n  return shapeAttrs;\n} // 单条 path\n\n\nfunction getSinglePath(points, isInCircle, smooth, constraint, style) {\n  if (points.length === 1) {\n    // 只有一个点时\n    return [['M', points[0].x, points[0].y - style.lineWidth / 2], ['L', points[0].x, points[0].y], ['L', points[0].x, points[0].y + style.lineWidth / 2]];\n  }\n\n  var path;\n\n  if (!smooth) {\n    path = getLinePath(points, false);\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  } else {\n    // 直角坐标系下绘制曲线时限制最大值、最小值\n    if (isInCircle && points.length) {\n      points.push({\n        x: points[0].x,\n        y: points[0].y\n      });\n    }\n\n    path = getSplinePath(points, false, constraint);\n  }\n\n  return path;\n}\n\nfunction getRangePath(points, isInCircle, isStack, smooth, constraint, style) {\n  var topPoints = [];\n  var bottomPoints = [];\n  each(points, function (point) {\n    var result = splitPoints(point);\n    topPoints.push(result[1]); // 上边\n\n    bottomPoints.push(result[0]); // 底边\n  });\n  var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);\n  var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);\n\n  if (isStack) {\n    return topPath;\n  }\n\n  return topPath.concat(bottomPath);\n}\n/**\n * 获取折线图 path\n */\n\n\nexport function getPath(points, isInCircle, isStack, smooth, constraint, style) {\n  if (points.length) {\n    var first = points[0];\n    return isArray(first.y) ? getRangePath(points, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points, isInCircle, smooth, constraint, style);\n  }\n\n  return [];\n}\nvar LineShapeFactory = registerShapeFactory('line', {\n  defaultShapeType: 'line'\n}); // 这里因为代码公用，所以直接全部注册\n// 'line' 默认折线；'dot' 点线 ···；'dash' 断线 - - -\n\neach(['line', 'dot', 'dash', 'smooth'], function (shapeType) {\n  registerShape('line', shapeType, {\n    draw: function (cfg, container) {\n      var smooth = shapeType === 'smooth';\n      var constraint;\n\n      if (smooth) {\n        var _a = this.coordinate,\n            start = _a.start,\n            end = _a.end;\n        constraint = [[start.x, end.y], [end.x, start.y]];\n      }\n\n      var attrs = getShapeAttrs(cfg, smooth, constraint);\n      var shape = container.addShape({\n        type: 'path',\n        attrs: attrs,\n        name: 'line',\n        capture: !smooth\n      });\n      return shape;\n    },\n    getMarker: function (markerCfg) {\n      return getLineMarker(markerCfg, shapeType);\n    }\n  });\n});\nexport default LineShapeFactory;","map":{"version":3,"mappings":"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","names":["each","isArray","registerShape","registerShapeFactory","getPathPoints","getStyle","getLinePath","getSplinePath","splitPoints","getLineMarker","getShapeAttrs","cfg","smooth","constraint","connectNulls","isInCircle","showSinglePoint","shapeAttrs","points","path","i","len","length","eachLinePoints","concat","getPath","isStack","getSinglePath","style","x","y","lineWidth","push","getRangePath","topPoints","bottomPoints","point","result","topPath","bottomPath","first","LineShapeFactory","defaultShapeType","shapeType","draw","container","coordinate","start","end","attrs","shape","addShape","type","name","capture","getMarker","markerCfg"],"sourceRoot":"","sources":["../../../../src/geometry/shape/line/index.ts"],"sourcesContent":["import { each, isArray } from '@antv/util';\nimport { IGroup, ShapeAttrs } from '../../../dependents';\nimport { Point, Position, RangePoint, ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nimport { splitPoints } from '../util/split-points';\nimport { getLineMarker } from './util';\n\nfunction getShapeAttrs(cfg: ShapeInfo, smooth?: boolean, constraint?: Position[]) {\n  const { isStack, connectNulls, isInCircle, showSinglePoint } = cfg;\n  const shapeAttrs = getStyle(cfg, true, false, 'lineWidth');\n\n  const points = getPathPoints(cfg.points, connectNulls, showSinglePoint); // 根据 connectNulls 值处理 points\n  let path = [];\n  for (let i = 0, len = points.length; i < len; i++) {\n    const eachLinePoints = points[i];\n    path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));\n  }\n  shapeAttrs.path = path;\n\n  return shapeAttrs;\n}\n\n// 单条 path\nfunction getSinglePath(\n  points: Point[],\n  isInCircle: boolean,\n  smooth?: boolean,\n  constraint?: Position[],\n  style?: ShapeAttrs\n) {\n  if (points.length === 1) {\n    // 只有一个点时\n    return [\n      ['M', points[0].x, points[0].y - style.lineWidth / 2],\n      ['L', points[0].x, points[0].y],\n      ['L', points[0].x, points[0].y + style.lineWidth / 2],\n    ];\n  }\n\n  let path;\n  if (!smooth) {\n    path = getLinePath(points, false);\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  } else {\n    // 直角坐标系下绘制曲线时限制最大值、最小值\n    if (isInCircle && points.length) {\n      points.push({ x: points[0].x, y: points[0].y });\n    }\n    path = getSplinePath(points, false, constraint);\n  }\n\n  return path;\n}\n\nfunction getRangePath(\n  points: RangePoint[],\n  isInCircle: boolean,\n  isStack?: boolean,\n  smooth?: boolean,\n  constraint?: Position[],\n  style?: ShapeAttrs\n) {\n  const topPoints = [];\n  const bottomPoints = [];\n  each(points, (point: RangePoint) => {\n    const result = splitPoints(point);\n    topPoints.push(result[1]); // 上边\n    bottomPoints.push(result[0]); // 底边\n  });\n\n  const topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);\n  const bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);\n  if (isStack) {\n    return topPath;\n  }\n  return topPath.concat(bottomPath);\n}\n\n/**\n * 获取折线图 path\n */\nexport function getPath(\n  points: Point[] | RangePoint[],\n  isInCircle: boolean,\n  isStack?: boolean,\n  smooth?: boolean,\n  constraint?: Position[],\n  style?: ShapeAttrs\n) {\n  if (points.length) {\n    const first = points[0];\n\n    return isArray(first.y)\n      ? getRangePath(points as RangePoint[], isInCircle, isStack, smooth, constraint, style)\n      : getSinglePath(points as Point[], isInCircle, smooth, constraint, style);\n  }\n  return [];\n}\n\nconst LineShapeFactory = registerShapeFactory('line', {\n  defaultShapeType: 'line',\n});\n\n// 这里因为代码公用，所以直接全部注册\n// 'line' 默认折线；'dot' 点线 ···；'dash' 断线 - - -\neach(['line', 'dot', 'dash', 'smooth'], (shapeType) => {\n  registerShape('line', shapeType, {\n    draw(cfg: ShapeInfo, container: IGroup) {\n      const smooth = shapeType === 'smooth';\n      let constraint;\n      if (smooth) {\n        const { start, end } = this.coordinate;\n        constraint = [\n          [start.x, end.y],\n          [end.x, start.y],\n        ];\n      }\n\n      const attrs = getShapeAttrs(cfg, smooth, constraint);\n      const shape = container.addShape({\n        type: 'path',\n        attrs,\n        name: 'line',\n        capture: !smooth,\n      });\n\n      return shape;\n    },\n    getMarker(markerCfg: ShapeMarkerCfg) {\n      return getLineMarker(markerCfg, shapeType);\n    },\n  });\n});\n\nexport default LineShapeFactory;\n"]},"metadata":{},"sourceType":"module"}