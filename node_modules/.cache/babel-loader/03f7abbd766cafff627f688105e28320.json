{"ast":null,"code":"import { __assign, __read } from \"tslib\";\nimport { getArcParams } from '@antv/g-canvas';\nimport { isNumberEqual, isEqual } from '@antv/util';\nimport { getArcPath, getSectorPath } from '../../util/graphics';\n\nfunction getAngle(startPoint, arcPath) {\n  var _a;\n\n  var _b = getArcParams(startPoint, arcPath),\n      startAngle = _b.startAngle,\n      endAngle = _b.endAngle;\n\n  if (!isNumberEqual(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {\n    startAngle += Math.PI * 2;\n  }\n\n  if (!isNumberEqual(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {\n    endAngle += Math.PI * 2;\n  }\n\n  if (arcPath[5] === 0) {\n    // 逆时针，需要将 startAngle 和 endAngle 转置，因为 G2 极坐标系为顺时针方向\n    _a = __read([endAngle, startAngle], 2), startAngle = _a[0], endAngle = _a[1];\n  }\n\n  if (isNumberEqual(startAngle, Math.PI * 1.5)) {\n    startAngle = Math.PI * -0.5;\n  } // 当 startAngle, endAngle 接近相等时，不进行 endAngle = Math.PI * 1.5 防止变化从整个圆开始\n\n\n  if (isNumberEqual(endAngle, Math.PI * -0.5) && !isNumberEqual(startAngle, endAngle)) {\n    endAngle = Math.PI * 1.5;\n  }\n\n  return {\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n}\n\nfunction getArcStartPoint(path) {\n  var startPoint;\n\n  if (path[0] === 'M' || path[0] === 'L') {\n    startPoint = [path[1], path[2]];\n  } else if (path[0] === 'a' || path[0] === 'A' || path[0] === 'C') {\n    startPoint = [path[path.length - 2], path[path.length - 1]];\n  }\n\n  return startPoint;\n}\n/**\n * path 存在以下情况\n * 1. 饼图不为整圆的 path，命令为 M, L, A, L, Z\n * 2. 饼图为整圆的 path，命令为 M, M, A, A, M, Z\n * 3. 环图不为整圆的 path，命令为 M, A, L, A, L, Z\n * 4. 环图为整圆的 path，命令为 M, A, A, M, A, A, M, Z\n * 5. radial-line, 不为整圆时的 path, 命令为 M, A, A, Z\n * 6. radial-line, 为整圆时的 path，命令为 M, A, A, A, A, Z\n * @param path theta 坐标系下圆弧的 path 命令\n */\n\n\nexport function getArcInfo(path) {\n  var _a;\n\n  var startAngle;\n  var endAngle;\n  var arcPaths = path.filter(function (command) {\n    return command[0] === 'A' || command[0] === 'a';\n  });\n\n  if (arcPaths.length === 0) {\n    return {\n      startAngle: 0,\n      endAngle: 0,\n      radius: 0,\n      innerRadius: 0\n    };\n  }\n\n  var firstArcPathCommand = arcPaths[0];\n  var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];\n  var firstIndex = path.indexOf(firstArcPathCommand);\n  var lastIndex = path.indexOf(lastArcPathCommand);\n  var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);\n  var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);\n\n  var _b = getAngle(firstStartPoint, firstArcPathCommand),\n      firstStartAngle = _b.startAngle,\n      firstEndAngle = _b.endAngle;\n\n  var _c = getAngle(lastStartPoint, lastArcPathCommand),\n      lastStartAngle = _c.startAngle,\n      lastEndAngle = _c.endAngle;\n\n  if (isNumberEqual(firstStartAngle, lastStartAngle) && isNumberEqual(firstEndAngle, lastEndAngle)) {\n    startAngle = firstStartAngle;\n    endAngle = firstEndAngle;\n  } else {\n    startAngle = Math.min(firstStartAngle, lastStartAngle);\n    endAngle = Math.max(firstEndAngle, lastEndAngle);\n  }\n\n  var radius = firstArcPathCommand[1];\n  var innerRadius = arcPaths[arcPaths.length - 1][1];\n\n  if (radius < innerRadius) {\n    _a = __read([innerRadius, radius], 2), radius = _a[0], innerRadius = _a[1];\n  } else if (radius === innerRadius) {\n    innerRadius = 0;\n  }\n\n  return {\n    startAngle: startAngle,\n    endAngle: endAngle,\n    radius: radius,\n    innerRadius: innerRadius\n  };\n}\n/**\n * @ignore\n * 饼图更新动画\n * @param shape 文本图形\n * @param animateCfg\n * @param cfg\n */\n\nexport function sectorPathUpdate(shape, animateCfg, cfg) {\n  var toAttrs = cfg.toAttrs,\n      coordinate = cfg.coordinate;\n  var path = toAttrs.path || [];\n  var pathCommands = path.map(function (command) {\n    return command[0];\n  });\n  if (path.length < 1) return;\n\n  var _a = getArcInfo(path),\n      curStartAngle = _a.startAngle,\n      curEndAngle = _a.endAngle,\n      radius = _a.radius,\n      innerRadius = _a.innerRadius;\n\n  var _b = getArcInfo(shape.attr('path')),\n      preStartAngle = _b.startAngle,\n      preEndAngle = _b.endAngle;\n\n  var center = coordinate.getCenter();\n  var diffStartAngle = curStartAngle - preStartAngle;\n  var diffEndAngle = curEndAngle - preEndAngle; // 没有 diff 时直接返回最终 attrs，不需要额外动画\n\n  if (diffStartAngle === 0 && diffEndAngle === 0) {\n    shape.attr('path', path);\n    return;\n  }\n\n  shape.animate(function (ratio) {\n    var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;\n    var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;\n    return __assign(__assign({}, toAttrs), {\n      path: // hack, 兼容 /examples/bar/basic/demo/radial-line.ts 动画\n      isEqual(pathCommands, ['M', 'A', 'A', 'Z']) ? getArcPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle) : getSectorPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius)\n    });\n  }, __assign(__assign({}, animateCfg), {\n    callback: function () {\n      // 将 path 保持原始态，否则会影响 setState() 的动画\n      shape.attr('path', path);\n    }\n  }));\n}","map":{"version":3,"mappings":"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","names":["getArcParams","isNumberEqual","isEqual","getArcPath","getSectorPath","getAngle","startPoint","arcPath","startAngle","endAngle","Math","PI","_a","getArcStartPoint","path","length","getArcInfo","arcPaths","filter","command","radius","innerRadius","firstArcPathCommand","lastArcPathCommand","firstIndex","indexOf","lastIndex","firstStartPoint","lastStartPoint","firstStartAngle","firstEndAngle","lastStartAngle","lastEndAngle","min","max","sectorPathUpdate","shape","animateCfg","cfg","coordinate","toAttrs","pathCommands","map","curStartAngle","curEndAngle","attr","preStartAngle","preEndAngle","center","getCenter","diffStartAngle","diffEndAngle","animate","ratio","onFrameStartAngle","onFrameEndAngle","x","y","__assign","callback"],"sourceRoot":"","sources":["../../../src/animate/animation/sector-path-update.ts"],"sourcesContent":["import { getArcParams } from '@antv/g-canvas';\nimport { isNumberEqual, isEqual } from '@antv/util';\n\nimport { IShape, PathCommand } from '../../dependents';\nimport { GAnimateCfg } from '../../interface';\nimport { AnimateExtraCfg } from '../interface';\n\nimport { getArcPath, getSectorPath } from '../../util/graphics';\n\nfunction getAngle(startPoint: number[], arcPath: PathCommand) {\n  let { startAngle, endAngle } = getArcParams(startPoint, arcPath);\n\n  if (!isNumberEqual(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {\n    startAngle += Math.PI * 2;\n  }\n  if (!isNumberEqual(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {\n    endAngle += Math.PI * 2;\n  }\n\n  if (arcPath[5] === 0) {\n    // 逆时针，需要将 startAngle 和 endAngle 转置，因为 G2 极坐标系为顺时针方向\n    [startAngle, endAngle] = [endAngle, startAngle];\n  }\n\n  if (isNumberEqual(startAngle, Math.PI * 1.5)) {\n    startAngle = Math.PI * -0.5;\n  }\n\n  // 当 startAngle, endAngle 接近相等时，不进行 endAngle = Math.PI * 1.5 防止变化从整个圆开始\n  if (isNumberEqual(endAngle, Math.PI * -0.5) && !isNumberEqual(startAngle, endAngle)) {\n    endAngle = Math.PI * 1.5;\n  }\n\n  return {\n    startAngle,\n    endAngle,\n  };\n}\n\nfunction getArcStartPoint(path: PathCommand) {\n  let startPoint;\n  if (path[0] === 'M' || path[0] === 'L') {\n    startPoint = [path[1], path[2]];\n  } else if (path[0] === 'a' || path[0] === 'A' || path[0] === 'C') {\n    startPoint = [path[path.length - 2], path[path.length - 1]];\n  }\n\n  return startPoint;\n}\n\n/**\n * path 存在以下情况\n * 1. 饼图不为整圆的 path，命令为 M, L, A, L, Z\n * 2. 饼图为整圆的 path，命令为 M, M, A, A, M, Z\n * 3. 环图不为整圆的 path，命令为 M, A, L, A, L, Z\n * 4. 环图为整圆的 path，命令为 M, A, A, M, A, A, M, Z\n * 5. radial-line, 不为整圆时的 path, 命令为 M, A, A, Z\n * 6. radial-line, 为整圆时的 path，命令为 M, A, A, A, A, Z\n * @param path theta 坐标系下圆弧的 path 命令\n */\nexport function getArcInfo(path: PathCommand[]) {\n  let startAngle;\n  let endAngle;\n\n  const arcPaths = path.filter((command) => {\n    return command[0] === 'A' || command[0] === 'a';\n  });\n\n  if (arcPaths.length === 0) {\n    return {\n      startAngle: 0,\n      endAngle: 0,\n      radius: 0,\n      innerRadius: 0,\n    };\n  }\n\n  const firstArcPathCommand = arcPaths[0];\n  const lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];\n  const firstIndex = path.indexOf(firstArcPathCommand);\n  const lastIndex = path.indexOf(lastArcPathCommand);\n  const firstStartPoint = getArcStartPoint(path[firstIndex - 1]);\n  const lastStartPoint = getArcStartPoint(path[lastIndex - 1]);\n\n  const { startAngle: firstStartAngle, endAngle: firstEndAngle } = getAngle(firstStartPoint, firstArcPathCommand);\n  const { startAngle: lastStartAngle, endAngle: lastEndAngle } = getAngle(lastStartPoint, lastArcPathCommand);\n\n  if (isNumberEqual(firstStartAngle, lastStartAngle) && isNumberEqual(firstEndAngle, lastEndAngle)) {\n    startAngle = firstStartAngle;\n    endAngle = firstEndAngle;\n  } else {\n    startAngle = Math.min(firstStartAngle, lastStartAngle);\n    endAngle = Math.max(firstEndAngle, lastEndAngle);\n  }\n\n  let radius = firstArcPathCommand[1];\n  let innerRadius = arcPaths[arcPaths.length - 1][1];\n  if (radius < innerRadius) {\n    [radius, innerRadius] = [innerRadius, radius];\n  } else if (radius === innerRadius) {\n    innerRadius = 0;\n  }\n\n  return {\n    startAngle,\n    endAngle,\n    radius,\n    innerRadius,\n  };\n}\n\n/**\n * @ignore\n * 饼图更新动画\n * @param shape 文本图形\n * @param animateCfg\n * @param cfg\n */\nexport function sectorPathUpdate(shape: IShape, animateCfg: GAnimateCfg, cfg: AnimateExtraCfg) {\n  const { toAttrs, coordinate } = cfg;\n  const path = (toAttrs as { path: PathCommand[] }).path || [];\n  const pathCommands = path.map((command) => command[0]);\n\n  if (path.length < 1) return;\n\n  const { startAngle: curStartAngle, endAngle: curEndAngle, radius, innerRadius } = getArcInfo(path);\n  const { startAngle: preStartAngle, endAngle: preEndAngle } = getArcInfo(shape.attr('path'));\n\n  const center = coordinate.getCenter();\n  const diffStartAngle = curStartAngle - preStartAngle;\n  const diffEndAngle = curEndAngle - preEndAngle;\n  // 没有 diff 时直接返回最终 attrs，不需要额外动画\n  if (diffStartAngle === 0 && diffEndAngle === 0) {\n    shape.attr('path', path);\n    return;\n  }\n\n  shape.animate(\n    (ratio) => {\n      const onFrameStartAngle = preStartAngle + ratio * diffStartAngle;\n      const onFrameEndAngle = preEndAngle + ratio * diffEndAngle;\n      return {\n        ...toAttrs,\n        path:\n          // hack, 兼容 /examples/bar/basic/demo/radial-line.ts 动画\n          isEqual(pathCommands, ['M', 'A', 'A', 'Z'])\n            ? getArcPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle)\n            : getSectorPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius),\n      };\n    },\n    {\n      ...animateCfg,\n      callback: () => {\n        // 将 path 保持原始态，否则会影响 setState() 的动画\n        shape.attr('path', path);\n      },\n    }\n  );\n}\n"]},"metadata":{},"sourceType":"module"}