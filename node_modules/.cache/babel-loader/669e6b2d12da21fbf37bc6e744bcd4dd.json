{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n// from https://github.com/simple-statistics\n\n/**\n * This is the internal implementation of quantiles: when you know\n * that the order is sorted, you don't need to re-sort it, and the computations\n * are faster.\n *\n * @param {Array<number>} x sample of one or more data points\n * @param {number} p desired quantile: a number between 0 to 1, inclusive\n * @returns {number} quantile value\n * @throws {Error} if p ix outside of the range from 0 to 1\n * @throws {Error} if x is empty\n * @example\n * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9\n */\nexport function quantileSorted(x, p) {\n  var idx = x.length * p;\n\n  if (x.length === 0) {\n    throw new Error('quantile requires at least one data point.');\n  } else if (p < 0 || p > 1) {\n    throw new Error('quantiles must be between 0 and 1');\n  } else if (p === 1) {\n    // If p is 1, directly return the last element\n    return x[x.length - 1];\n  } else if (p === 0) {\n    // If p is 0, directly return the first element\n    return x[0];\n  } else if (idx % 1 !== 0) {\n    // If p is not integer, return the next element in array\n    return x[Math.ceil(idx) - 1];\n  } else if (x.length % 2 === 0) {\n    // If the list has even-length, we'll take the average of this number\n    // and the next value, if there is one\n    return (x[idx - 1] + x[idx]) / 2;\n  } else {\n    // Finally, in the simple case of an integer value\n    // with an odd-length list, return the x value at the index.\n    return x[idx];\n  }\n}\n/**\n * 交换数组位置\n * @param arr T[]\n * @param i number\n * @param j number\n */\n\nexport function swap(arr, i, j) {\n  var tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}\n/**\n * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.\n * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.\n *\n * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm\n *\n * @param {Array<number>} arr input array\n * @param {number} k pivot index\n * @param {number} [left] left index\n * @param {number} [right] right index\n * @returns {void} mutates input array\n * @example\n * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];\n * quickselect(arr, 8);\n * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]\n */\n\nexport function quickselect(arr, k, left, right) {\n  left = left || 0;\n  right = right || arr.length - 1;\n\n  while (right > left) {\n    // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time\n    if (right - left > 600) {\n      var n = right - left + 1;\n      var m = k - left + 1;\n      var z = Math.log(n);\n      var s = 0.5 * Math.exp(2 * z / 3);\n      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n);\n      if (m - n / 2 < 0) sd *= -1;\n      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n      quickselect(arr, k, newLeft, newRight);\n    }\n\n    var t = arr[k];\n    var i = left;\n    var j = right;\n    swap(arr, left, k);\n    if (arr[right] > t) swap(arr, left, right);\n\n    while (i < j) {\n      swap(arr, i, j);\n      i++;\n      j--;\n\n      while (arr[i] < t) i++;\n\n      while (arr[j] > t) j--;\n    }\n\n    if (arr[left] === t) swap(arr, left, j);else {\n      j++;\n      swap(arr, j, right);\n    }\n    if (j <= k) left = j + 1;\n    if (k <= j) right = j - 1;\n  }\n}\n\nfunction quantile(x, p) {\n  var copy = x.slice();\n\n  if (Array.isArray(p)) {\n    // rearrange elements so that each element corresponding to a requested\n    // quantile is on a place it would be if the array was fully sorted\n    multiQuantileSelect(copy, p); // Initialize the result array\n\n    var results = []; // For each requested quantile\n\n    for (var i = 0; i < p.length; i++) {\n      results[i] = quantileSorted(copy, p[i]);\n    }\n\n    return results;\n  } else {\n    var idx = quantileIndex(copy.length, p);\n    quantileSelect(copy, idx, 0, copy.length - 1);\n    return quantileSorted(copy, p);\n  }\n}\n\nfunction quantileSelect(arr, k, left, right) {\n  if (k % 1 === 0) {\n    quickselect(arr, k, left, right);\n  } else {\n    k = Math.floor(k);\n    quickselect(arr, k, left, right);\n    quickselect(arr, k + 1, k + 1, right);\n  }\n}\n\nfunction multiQuantileSelect(arr, p) {\n  var indices = [0];\n\n  for (var i = 0; i < p.length; i++) {\n    indices.push(quantileIndex(arr.length, p[i]));\n  }\n\n  indices.push(arr.length - 1);\n  indices.sort(compare);\n  var stack = [0, indices.length - 1];\n\n  while (stack.length) {\n    var r = Math.ceil(stack.pop());\n    var l = Math.floor(stack.pop());\n    if (r - l <= 1) continue;\n    var m = Math.floor((l + r) / 2);\n    quantileSelect(arr, indices[m], Math.floor(indices[l]), Math.ceil(indices[r]));\n    stack.push(l, m, m, r);\n  }\n}\n\nfunction compare(a, b) {\n  return a - b;\n}\n\nfunction quantileIndex(len, p) {\n  var idx = len * p;\n\n  if (p === 1) {\n    // If p is 1, directly return the last index\n    return len - 1;\n  } else if (p === 0) {\n    // If p is 0, directly return the first index\n    return 0;\n  } else if (idx % 1 !== 0) {\n    // If index is not integer, return the next index in array\n    return Math.ceil(idx) - 1;\n  } else if (len % 2 === 0) {\n    // If the list has even-length, we'll return the middle of two indices\n    // around quantile to indicate that we need an average value of the two\n    return idx - 0.5;\n  } else {\n    // Finally, in the simple case of an integer index\n    // with an odd-length list, return the index\n    return idx;\n  }\n}\n\nexport { quantile };","map":{"version":3,"mappings":"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","names":["quantileSorted","x","p","idx","length","Error","Math","ceil","swap","arr","i","j","tmp","quickselect","k","left","right","n","m","z","log","s","exp","sd","sqrt","newLeft","max","floor","newRight","min","t","quantile","copy","slice","Array","isArray","multiQuantileSelect","results","quantileIndex","quantileSelect","indices","push","sort","compare","stack","r","pop","l","a","b","len"],"sourceRoot":"","sources":["../../../src/utils/transform/quantile.ts"],"sourcesContent":["// from https://github.com/simple-statistics\n\n/**\n * This is the internal implementation of quantiles: when you know\n * that the order is sorted, you don't need to re-sort it, and the computations\n * are faster.\n *\n * @param {Array<number>} x sample of one or more data points\n * @param {number} p desired quantile: a number between 0 to 1, inclusive\n * @returns {number} quantile value\n * @throws {Error} if p ix outside of the range from 0 to 1\n * @throws {Error} if x is empty\n * @example\n * quantileSorted([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9\n */\nexport function quantileSorted(x: number[], p: number) {\n  const idx = x.length * p;\n  if (x.length === 0) {\n    throw new Error('quantile requires at least one data point.');\n  } else if (p < 0 || p > 1) {\n    throw new Error('quantiles must be between 0 and 1');\n  } else if (p === 1) {\n    // If p is 1, directly return the last element\n    return x[x.length - 1];\n  } else if (p === 0) {\n    // If p is 0, directly return the first element\n    return x[0];\n  } else if (idx % 1 !== 0) {\n    // If p is not integer, return the next element in array\n    return x[Math.ceil(idx) - 1];\n  } else if (x.length % 2 === 0) {\n    // If the list has even-length, we'll take the average of this number\n    // and the next value, if there is one\n    return (x[idx - 1] + x[idx]) / 2;\n  } else {\n    // Finally, in the simple case of an integer value\n    // with an odd-length list, return the x value at the index.\n    return x[idx];\n  }\n}\n\n/**\n * 交换数组位置\n * @param arr T[]\n * @param i number\n * @param j number\n */\nexport function swap<T = any>(arr: T[], i: number, j: number): void {\n  const tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}\n\n/**\n * Rearrange items in `arr` so that all items in `[left, k]` range are the smallest.\n * The `k`-th element will have the `(k - left + 1)`-th smallest value in `[left, right]`.\n *\n * Implements Floyd-Rivest selection algorithm https://en.wikipedia.org/wiki/Floyd-Rivest_algorithm\n *\n * @param {Array<number>} arr input array\n * @param {number} k pivot index\n * @param {number} [left] left index\n * @param {number} [right] right index\n * @returns {void} mutates input array\n * @example\n * var arr = [65, 28, 59, 33, 21, 56, 22, 95, 50, 12, 90, 53, 28, 77, 39];\n * quickselect(arr, 8);\n * // = [39, 28, 28, 33, 21, 12, 22, 50, 53, 56, 59, 65, 90, 77, 95]\n */\nexport function quickselect(arr: number[], k, left?: number, right?: number): void {\n  left = left || 0;\n  right = right || arr.length - 1;\n\n  while (right > left) {\n    // 600 and 0.5 are arbitrary constants chosen in the original paper to minimize execution time\n    if (right - left > 600) {\n      const n = right - left + 1;\n      const m = k - left + 1;\n      const z = Math.log(n);\n      const s = 0.5 * Math.exp((2 * z) / 3);\n      let sd = 0.5 * Math.sqrt((z * s * (n - s)) / n);\n      if (m - n / 2 < 0) sd *= -1;\n      const newLeft = Math.max(left, Math.floor(k - (m * s) / n + sd));\n      const newRight = Math.min(right, Math.floor(k + ((n - m) * s) / n + sd));\n      quickselect(arr, k, newLeft, newRight);\n    }\n\n    const t = arr[k];\n    let i = left;\n    let j = right;\n\n    swap(arr, left, k);\n    if (arr[right] > t) swap(arr, left, right);\n\n    while (i < j) {\n      swap(arr, i, j);\n      i++;\n      j--;\n      while (arr[i] < t) i++;\n      while (arr[j] > t) j--;\n    }\n\n    if (arr[left] === t) swap(arr, left, j);\n    else {\n      j++;\n      swap(arr, j, right);\n    }\n\n    if (j <= k) left = j + 1;\n    if (k <= j) right = j - 1;\n  }\n}\n\n/**\n * The [quantile](https://en.wikipedia.org/wiki/Quantile):\n * this is a population quantile, since we assume to know the entire\n * dataset in this library. This is an implementation of the\n * [Quantiles of a Population](http://en.wikipedia.org/wiki/Quantile#Quantiles_of_a_population)\n * algorithm from wikipedia.\n *\n * Sample is a one-dimensional array of numbers,\n * and p is either a decimal number from 0 to 1 or an array of decimal\n * numbers from 0 to 1.\n * In terms of a k/q quantile, p = k/q - it's just dealing with fractions or dealing\n * with decimal values.\n * When p is an array, the result of the function is also an array containing the appropriate\n * quantiles in input order\n *\n * @param {Array<number>} x sample of one or more numbers\n * @param {Array<number> | number} p the desired quantile, as a number between 0 and 1\n * @returns {number} quantile\n * @example\n * quantile([3, 6, 7, 8, 8, 9, 10, 13, 15, 16, 20], 0.5); // => 9\n */\nfunction quantile(x: number[], p: number): number;\nfunction quantile(x: number[], p: number[]): number[];\nfunction quantile(x: any, p: any): any {\n  const copy = x.slice();\n\n  if (Array.isArray(p)) {\n    // rearrange elements so that each element corresponding to a requested\n    // quantile is on a place it would be if the array was fully sorted\n    multiQuantileSelect(copy, p);\n    // Initialize the result array\n    const results: number[] = [];\n    // For each requested quantile\n    for (let i = 0; i < p.length; i++) {\n      results[i] = quantileSorted(copy, p[i]);\n    }\n    return results;\n  } else {\n    const idx = quantileIndex(copy.length, p);\n    quantileSelect(copy, idx, 0, copy.length - 1);\n    return quantileSorted(copy, p);\n  }\n}\n\nfunction quantileSelect(arr, k, left, right) {\n  if (k % 1 === 0) {\n    quickselect(arr, k, left, right);\n  } else {\n    k = Math.floor(k);\n    quickselect(arr, k, left, right);\n    quickselect(arr, k + 1, k + 1, right);\n  }\n}\n\nfunction multiQuantileSelect(arr, p) {\n  const indices = [0];\n  for (let i = 0; i < p.length; i++) {\n    indices.push(quantileIndex(arr.length, p[i]));\n  }\n  indices.push(arr.length - 1);\n  indices.sort(compare);\n\n  const stack = [0, indices.length - 1];\n\n  while (stack.length) {\n    const r = Math.ceil(stack.pop());\n    const l = Math.floor(stack.pop());\n    if (r - l <= 1) continue;\n\n    const m = Math.floor((l + r) / 2);\n    quantileSelect(arr, indices[m], Math.floor(indices[l]), Math.ceil(indices[r]));\n\n    stack.push(l, m, m, r);\n  }\n}\n\nfunction compare(a, b) {\n  return a - b;\n}\n\nfunction quantileIndex(len, p) {\n  const idx = len * p;\n  if (p === 1) {\n    // If p is 1, directly return the last index\n    return len - 1;\n  } else if (p === 0) {\n    // If p is 0, directly return the first index\n    return 0;\n  } else if (idx % 1 !== 0) {\n    // If index is not integer, return the next index in array\n    return Math.ceil(idx) - 1;\n  } else if (len % 2 === 0) {\n    // If the list has even-length, we'll return the middle of two indices\n    // around quantile to indicate that we need an average value of the two\n    return idx - 0.5;\n  } else {\n    // Finally, in the simple case of an integer index\n    // with an odd-length list, return the index\n    return idx;\n  }\n}\n\nexport { quantile };\n"]},"metadata":{},"sourceType":"module"}