{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { groupBy, min, max } from '@antv/util';\nimport pdf from 'pdfast';\nimport { quantile } from '../../utils/transform/quantile';\nexport var toBoxValue = function (values) {\n  return {\n    low: min(values),\n    high: max(values),\n    q1: quantile(values, 0.25),\n    q3: quantile(values, 0.75),\n    median: quantile(values, [0.5]),\n    minMax: [min(values), max(values)],\n    quantile: [quantile(values, 0.25), quantile(values, 0.75)]\n  };\n};\nexport var toViolinValue = function (values, pdfOptions) {\n  var pdfResults = pdf.create(values, pdfOptions);\n  return {\n    violinSize: pdfResults.map(function (result) {\n      return result.y;\n    }),\n    violinY: pdfResults.map(function (result) {\n      return result.x;\n    })\n  };\n};\nexport var transformViolinData = function (options) {\n  var xField = options.xField,\n      yField = options.yField,\n      seriesField = options.seriesField,\n      data = options.data,\n      kde = options.kde;\n  /** 生成概率密度函数的配置 */\n\n  var pdfOptions = {\n    min: kde.min,\n    max: kde.max,\n    size: kde.sampleSize,\n    width: kde.width\n  }; // 无拆分\n\n  if (!seriesField) {\n    var group_1 = groupBy(data, xField);\n    return Object.keys(group_1).map(function (x) {\n      var records = group_1[x];\n      var values = records.map(function (record) {\n        return record[yField];\n      });\n      return __assign(__assign({\n        x: x\n      }, toViolinValue(values, pdfOptions)), toBoxValue(values));\n    });\n  } // 有拆分\n\n\n  var resultList = [];\n  var seriesGroup = groupBy(data, seriesField);\n  Object.keys(seriesGroup).forEach(function (series) {\n    var group = groupBy(seriesGroup[series], xField);\n    return Object.keys(group).forEach(function (key) {\n      var _a;\n\n      var records = group[key];\n      var values = records.map(function (record) {\n        return record[yField];\n      });\n      resultList.push(__assign(__assign((_a = {\n        x: key\n      }, _a[seriesField] = series, _a), toViolinValue(values, pdfOptions)), toBoxValue(values)));\n    });\n  });\n  return resultList;\n};","map":{"version":3,"mappings":"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","names":["groupBy","min","max","pdf","quantile","toBoxValue","values","low","high","q1","q3","median","minMax","toViolinValue","pdfOptions","pdfResults","create","violinSize","map","result","y","violinY","x","transformViolinData","options","yField","seriesField","data","kde","size","sampleSize","width","group_1","xField","Object","keys","records","record","resultList","seriesGroup","forEach","series","group","key","push","__assign","_a"],"sourceRoot":"","sources":["../../../src/plots/violin/utils.ts"],"sourcesContent":["import { groupBy, min, max } from '@antv/util';\nimport pdf from 'pdfast';\nimport { quantile } from '../../utils/transform/quantile';\nimport { ViolinOptions } from './types';\n\nexport type ViolinData = {\n  /** X轴 */\n  x: string;\n\n  /** 小提琴轮廓的 size 通道数据 */\n  violinSize: number[];\n  /** 小提琴轮廓的 y 通道数据 */\n  violinY: number[];\n\n  // 箱线图基础数据\n  /** 最大值 */\n  high: number;\n  /** 最小值 */\n  low: number;\n  /** 上四分位数 */\n  q1: number;\n  /** 下四分位数 */\n  q3: number;\n  /** 箱线图中的中位值 */\n  median: number[];\n\n  /** 箱线图中的上线边缘线 */\n  minMax: number[];\n  /** 箱线图中的上下四分位点 */\n  quantile: number[];\n};\n\nexport type PdfOptions = {\n  min: number;\n  max: number;\n  size: number;\n  width: number;\n};\n\nexport const toBoxValue = (values: number[]) => {\n  return {\n    low: min(values),\n    high: max(values),\n    q1: quantile(values, 0.25),\n    q3: quantile(values, 0.75),\n    median: quantile(values, [0.5]),\n    minMax: [min(values), max(values)],\n    quantile: [quantile(values, 0.25), quantile(values, 0.75)],\n  };\n};\n\nexport const toViolinValue = (values: number[], pdfOptions: PdfOptions) => {\n  const pdfResults: Array<{ x: number; y: number }> = pdf.create(values, pdfOptions);\n  return {\n    violinSize: pdfResults.map((result) => result.y),\n    violinY: pdfResults.map((result) => result.x),\n  };\n};\n\nexport const transformViolinData = (options: ViolinOptions): ViolinData[] => {\n  const { xField, yField, seriesField, data, kde } = options;\n\n  /** 生成概率密度函数的配置 */\n  const pdfOptions: PdfOptions = {\n    min: kde.min,\n    max: kde.max,\n    size: kde.sampleSize,\n    width: kde.width,\n  };\n\n  // 无拆分\n  if (!seriesField) {\n    const group = groupBy(data, xField);\n    return Object.keys(group).map((x) => {\n      const records = group[x];\n      const values = records.map((record) => record[yField]);\n      return {\n        x,\n        ...toViolinValue(values, pdfOptions),\n        ...toBoxValue(values),\n      };\n    });\n  }\n\n  // 有拆分\n  const resultList: ViolinData[] = [];\n  const seriesGroup = groupBy(data, seriesField);\n  Object.keys(seriesGroup).forEach((series) => {\n    const group = groupBy(seriesGroup[series], xField);\n    return Object.keys(group).forEach((key) => {\n      const records = group[key];\n      const values = records.map((record) => record[yField]);\n      resultList.push({\n        x: key,\n        [seriesField]: series,\n        ...toViolinValue(values, pdfOptions),\n        ...toBoxValue(values),\n      });\n    });\n  });\n  return resultList;\n};\n"]},"metadata":{},"sourceType":"module"}