{"ast":null,"code":"import { BBox } from '../../../../util/bbox';\nimport { findLabelTextShape } from '../../util';\n\nfunction shouldInShapeSingle(geometry, label, shape) {\n  var coordinate = geometry.coordinate;\n  var textShape = findLabelTextShape(label);\n  var textBBox = BBox.fromObject(textShape.getCanvasBBox());\n  var shapeBBox = BBox.fromObject(shape.getBBox());\n  return coordinate.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;\n}\n\nfunction shouldInShape(geometry, labels, shapes) {\n  var isStack = !!geometry.getAdjust('stack');\n  return isStack || labels.every(function (label, index) {\n    var shape = shapes[index];\n    return shouldInShapeSingle(geometry, label, shape);\n  });\n}\n\nfunction moveInShape(geometry, label, shape) {\n  var coordinate = geometry.coordinate;\n  var shapeBBox = BBox.fromObject(shape.getBBox());\n  var textShape = findLabelTextShape(label);\n\n  if (coordinate.isTransposed) {\n    // 水平方向：条形图系列\n    textShape.attr({\n      x: shapeBBox.minX + shapeBBox.width / 2,\n      textAlign: 'center'\n    });\n  } else {\n    // 垂直方向：柱形图系列\n    textShape.attr({\n      y: shapeBBox.minY + shapeBBox.height / 2,\n      textBaseline: 'middle'\n    });\n  }\n}\n/**\n * 适用于 interval geometry 的数据标签位置自动调整布局方法\n * @param items\n * @param labels\n * @param shapes\n */\n\n\nexport function intervalAdjustPosition(items, labels, shapes) {\n  var _a;\n\n  if (shapes.length === 0) {\n    return;\n  }\n\n  var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');\n  var geometry = element === null || element === void 0 ? void 0 : element.geometry;\n\n  if (!geometry || geometry.type !== 'interval') {\n    return;\n  }\n\n  var inShape = shouldInShape(geometry, labels, shapes);\n\n  if (inShape) {\n    shapes.forEach(function (shape, index) {\n      var label = labels[index];\n      moveInShape(geometry, label, shape);\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["BBox","findLabelTextShape","shouldInShapeSingle","geometry","label","shape","coordinate","textShape","textBBox","fromObject","getCanvasBBox","shapeBBox","getBBox","isTransposed","height","width","shouldInShape","labels","shapes","isStack","getAdjust","every","index","moveInShape","attr","x","minX","textAlign","y","minY","textBaseline","intervalAdjustPosition","items","length","element","_a","get","type","inShape","forEach"],"sourceRoot":"","sources":["../../../../../src/geometry/label/layout/interval/adjust-position.ts"],"sourcesContent":["import { IElement, IGroup, IShape } from '../../../../dependents';\nimport { BBox } from '../../../../util/bbox';\nimport Geometry from '../../../base';\nimport Element from '../../../element';\nimport { LabelItem } from '../../interface';\nimport { findLabelTextShape } from '../../util';\n\nfunction shouldInShapeSingle(geometry: Geometry, label: IGroup, shape: IElement): boolean {\n  const coordinate = geometry.coordinate;\n  const textShape = findLabelTextShape(label);\n  const textBBox = BBox.fromObject(textShape.getCanvasBBox());\n  const shapeBBox = BBox.fromObject(shape.getBBox());\n\n  return coordinate.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;\n}\n\nfunction shouldInShape(geometry: Geometry, labels: IGroup[], shapes: IShape[] | IGroup[]): boolean {\n  const isStack = !!geometry.getAdjust('stack');\n\n  return (\n    isStack ||\n    labels.every((label: IGroup, index: number) => {\n      const shape = shapes[index];\n      return shouldInShapeSingle(geometry, label, shape);\n    })\n  );\n}\n\nfunction moveInShape(geometry: Geometry, label: IGroup, shape: IElement): void {\n  const coordinate = geometry.coordinate;\n  const shapeBBox = BBox.fromObject(shape.getBBox());\n  const textShape = findLabelTextShape(label);\n\n  if (coordinate.isTransposed) {\n    // 水平方向：条形图系列\n    textShape.attr({\n      x: shapeBBox.minX + shapeBBox.width / 2,\n      textAlign: 'center',\n    });\n  } else {\n    // 垂直方向：柱形图系列\n    textShape.attr({\n      y: shapeBBox.minY + shapeBBox.height / 2,\n      textBaseline: 'middle',\n    });\n  }\n}\n\n/**\n * 适用于 interval geometry 的数据标签位置自动调整布局方法\n * @param items\n * @param labels\n * @param shapes\n */\nexport function intervalAdjustPosition(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[]) {\n  if (shapes.length === 0) {\n    return;\n  }\n  const element: Element = shapes[0]?.get('element');\n  const geometry: Geometry = element?.geometry;\n  if (!geometry || geometry.type !== 'interval') {\n    return;\n  }\n\n  const inShape = shouldInShape(geometry, labels, shapes);\n  if (inShape) {\n    shapes.forEach((shape: IShape | IGroup, index: number) => {\n      const label = labels[index];\n      moveInShape(geometry, label, shape);\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}