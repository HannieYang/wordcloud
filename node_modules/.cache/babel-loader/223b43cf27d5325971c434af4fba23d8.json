{"ast":null,"code":"import { isNil, isFunction, assign } from '@antv/util';\nvar DEFAULT_OPTIONS = {\n  font: function () {\n    return 'serif';\n  },\n  padding: 1,\n  size: [500, 500],\n  spiral: 'archimedean',\n  // timeInterval: Infinity // max execute time\n  timeInterval: 3000\n};\n/**\n * 根据对应的数据对象，计算每个\n * 词语在画布中的渲染位置，并返回\n * 计算后的数据对象\n * @param words\n * @param options\n */\n\nexport function wordCloud(words, options) {\n  // 混入默认配置\n  options = assign({}, DEFAULT_OPTIONS, options);\n  return transform(words, options);\n}\n/**\n * 抛出没有混入默认配置的方法，用于测试。\n * @param words\n * @param options\n */\n\nexport function transform(words, options) {\n  // 布局对象\n  var layout = tagCloud();\n  ['font', 'fontSize', 'fontWeight', 'padding', 'rotate', 'size', 'spiral', 'timeInterval', 'random'].forEach(function (key) {\n    if (!isNil(options[key])) {\n      layout[key](options[key]);\n    }\n  });\n  layout.words(words);\n\n  if (options.imageMask) {\n    layout.createMask(options.imageMask);\n  }\n\n  var result = layout.start();\n  var tags = result._tags;\n  tags.forEach(function (tag) {\n    tag.x += options.size[0] / 2;\n    tag.y += options.size[1] / 2;\n  });\n  var _a = options.size,\n      w = _a[0],\n      h = _a[1]; // 添加两个参照数据，分别表示左上角和右下角。\n  // 不添加的话不会按照真实的坐标渲染，而是以\n  // 数据中的边界坐标为边界进行拉伸，以铺满画布。\n  // 这样的后果会导致词语之间的重叠。\n\n  tags.push({\n    text: '',\n    value: 0,\n    x: 0,\n    y: 0,\n    opacity: 0\n  });\n  tags.push({\n    text: '',\n    value: 0,\n    x: w,\n    y: h,\n    opacity: 0\n  });\n  return tags;\n}\nvar cloudRadians = Math.PI / 180,\n    cw = 1 << 11 >> 5,\n    ch = 1 << 11;\n\nfunction cloudText(d) {\n  return d.text;\n}\n\nfunction cloudFont() {\n  return 'serif';\n}\n\nfunction cloudFontNormal() {\n  return 'normal';\n}\n\nfunction cloudFontSize(d) {\n  return d.value;\n}\n\nfunction cloudRotate() {\n  return ~~(Math.random() * 2) * 90;\n}\n\nfunction cloudPadding() {\n  return 1;\n} // Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\n\n\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  var c = contextAndRatio.context,\n      ratio = contextAndRatio.ratio;\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  var x = 0,\n      y = 0,\n      maxh = 0;\n  var n = data.length;\n  --di;\n\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;\n    var w = c.measureText(d.text + 'm').width * ratio,\n        h = d.size << 1;\n\n    if (d.rotate) {\n      var sr = Math.sin(d.rotate * cloudRadians),\n          cr = Math.cos(d.rotate * cloudRadians),\n          wcr = w * cr,\n          wsr = w * sr,\n          hcr = h * cr,\n          hsr = h * sr;\n      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = w + 0x1f >> 5 << 5;\n    }\n\n    if (h > maxh) maxh = h;\n\n    if (x + w >= cw << 5) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\n    c.fillText(d.text, 0, 0);\n\n    if (d.padding) {\n      c.lineWidth = 2 * d.padding;\n      c.strokeText(d.text, 0, 0);\n    }\n\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n\n  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n      sprite = [];\n\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    var w = d.width,\n        w32 = w >> 5;\n    var h = d.y1 - d.y0; // Zero the buffer\n\n    for (var i = 0; i < h * w32; i++) sprite[i] = 0;\n\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    var seen = 0,\n        seenRow = -1;\n\n    for (var j = 0; j < h; j++) {\n      for (var i = 0; i < w; i++) {\n        var k = w32 * j + (i >> 5),\n            m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n\n      if (seen) seenRow = j;else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n} // Use mask-based collision detection.\n\n\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  var sprite = tag.sprite,\n      w = tag.width >> 5,\n      lx = tag.x - (w << 4),\n      sx = lx & 0x7f,\n      msx = 32 - sx,\n      h = tag.y1 - tag.y0;\n  var x = (tag.y + tag.y0) * sw + (lx >> 5),\n      last;\n\n  for (var j = 0; j < h; j++) {\n    last = 0;\n\n    for (var i = 0; i <= w; i++) {\n      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;\n    }\n\n    x += sw;\n  }\n\n  return false;\n}\n\nfunction cloudBounds(bounds, d) {\n  var b0 = bounds[0],\n      b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\n\nfunction collideRects(a, b) {\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\n\nfunction archimedeanSpiral(size) {\n  var e = size[0] / size[1];\n  return function (t) {\n    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\n\nfunction rectangularSpiral(size) {\n  var dy = 4,\n      dx = dy * size[0] / size[1];\n  var x = 0,\n      y = 0;\n  return function (t) {\n    var sign = t < 0 ? -1 : 1; // See triangular numbers: T_n = n * (n + 1) / 2.\n\n    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {\n      case 0:\n        x += dx;\n        break;\n\n      case 1:\n        y += dy;\n        break;\n\n      case 2:\n        x -= dx;\n        break;\n\n      default:\n        y -= dy;\n        break;\n    }\n\n    return [x, y];\n  };\n} // TODO reuse arrays?\n\n\nfunction zeroArray(n) {\n  var a = [];\n  var i = -1;\n\n  while (++i < n) a[i] = 0;\n\n  return a;\n}\n\nfunction cloudCanvas() {\n  return document.createElement('canvas');\n}\n\nexport function functor(d) {\n  return isFunction(d) ? d : function () {\n    return d;\n  };\n}\nvar spirals = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral\n};\n\nfunction tagCloud() {\n  var size = [256, 256],\n      font = cloudFont,\n      fontSize = cloudFontSize,\n      fontWeight = cloudFontNormal,\n      rotate = cloudRotate,\n      padding = cloudPadding,\n      spiral = archimedeanSpiral,\n      random = Math.random,\n      words = [],\n      timeInterval = Infinity;\n  var text = cloudText;\n  var fontStyle = cloudFontNormal;\n  var canvas = cloudCanvas;\n  var cloud = {};\n\n  cloud.start = function () {\n    var width = size[0],\n        height = size[1];\n    var contextAndRatio = getContext(canvas()),\n        board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]),\n        n = words.length,\n        tags = [],\n        data = words.map(function (d, i, data) {\n      d.text = text.call(this, d, i, data);\n      d.font = font.call(this, d, i, data);\n      d.style = fontStyle.call(this, d, i, data);\n      d.weight = fontWeight.call(this, d, i, data);\n      d.rotate = rotate.call(this, d, i, data);\n      d.size = ~~fontSize.call(this, d, i, data);\n      d.padding = padding.call(this, d, i, data);\n      return d;\n    }).sort(function (a, b) {\n      return b.size - a.size;\n    });\n    var i = -1,\n        bounds = !cloud.board ? null : [{\n      x: 0,\n      y: 0\n    }, {\n      x: width,\n      y: height\n    }];\n    step();\n\n    function step() {\n      var start = Date.now();\n\n      while (Date.now() - start < timeInterval && ++i < n) {\n        var d = data[i];\n        d.x = width * (random() + 0.5) >> 1;\n        d.y = height * (random() + 0.5) >> 1;\n        cloudSprite(contextAndRatio, d, data, i);\n\n        if (d.hasText && place(board, d, bounds)) {\n          tags.push(d);\n\n          if (bounds) {\n            if (!cloud.hasImage) {\n              // update bounds if image mask not set\n              cloudBounds(bounds, d);\n            }\n          } else {\n            bounds = [{\n              x: d.x + d.x0,\n              y: d.y + d.y0\n            }, {\n              x: d.x + d.x1,\n              y: d.y + d.y1\n            }];\n          } // Temporary hack\n\n\n          d.x -= size[0] >> 1;\n          d.y -= size[1] >> 1;\n        }\n      }\n\n      cloud._tags = tags;\n      cloud._bounds = bounds;\n    }\n\n    return cloud;\n  };\n\n  function getContext(canvas) {\n    canvas.width = canvas.height = 1;\n    var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n    var context = canvas.getContext('2d');\n    context.fillStyle = context.strokeStyle = 'red';\n    context.textAlign = 'center';\n    return {\n      context: context,\n      ratio: ratio\n    };\n  }\n\n  function place(board, tag, bounds) {\n    // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\n    var startX = tag.x,\n        startY = tag.y,\n        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n        s = spiral(size),\n        dt = random() < 0.5 ? 1 : -1;\n    var dxdy,\n        t = -dt,\n        dx,\n        dy;\n\n    while (dxdy = s(t += dt)) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue; // TODO only check for collisions within current bounds.\n\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\n        if (!bounds || collideRects(tag, bounds)) {\n          var sprite = tag.sprite,\n              w = tag.width >> 5,\n              sw = size[0] >> 5,\n              lx = tag.x - (w << 4),\n              sx = lx & 0x7f,\n              msx = 32 - sx,\n              h = tag.y1 - tag.y0;\n          var last = void 0,\n              x = (tag.y + tag.y0) * sw + (lx >> 5);\n\n          for (var j = 0; j < h; j++) {\n            last = 0;\n\n            for (var i = 0; i <= w; i++) {\n              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n\n            x += sw;\n          }\n\n          delete tag.sprite;\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  cloud.createMask = function (img) {\n    var can = document.createElement('canvas');\n    var width = size[0],\n        height = size[1]; // 当 width 或 height 为 0 时，调用 cxt.getImageData 会报错\n\n    if (!width || !height) {\n      return;\n    }\n\n    var w32 = width >> 5;\n    var board = zeroArray((width >> 5) * height);\n    can.width = width;\n    can.height = height;\n    var cxt = can.getContext('2d');\n    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\n    var imageData = cxt.getImageData(0, 0, width, height).data;\n\n    for (var j = 0; j < height; j++) {\n      for (var i = 0; i < width; i++) {\n        var k = w32 * j + (i >> 5);\n        var tmp = j * width + i << 2;\n        var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;\n        var m = flag ? 1 << 31 - i % 32 : 0;\n        board[k] |= m;\n      }\n    }\n\n    cloud.board = board;\n    cloud.hasImage = true;\n  };\n\n  cloud.timeInterval = function (_) {\n    timeInterval = _ == null ? Infinity : _;\n  };\n\n  cloud.words = function (_) {\n    words = _;\n  };\n\n  cloud.size = function (_) {\n    size = [+_[0], +_[1]];\n  };\n\n  cloud.font = function (_) {\n    font = functor(_);\n  };\n\n  cloud.fontWeight = function (_) {\n    fontWeight = functor(_);\n  };\n\n  cloud.rotate = function (_) {\n    rotate = functor(_);\n  };\n\n  cloud.spiral = function (_) {\n    spiral = spirals[_] || _;\n  };\n\n  cloud.fontSize = function (_) {\n    fontSize = functor(_);\n  };\n\n  cloud.padding = function (_) {\n    padding = functor(_);\n  };\n\n  cloud.random = function (_) {\n    random = functor(_);\n  };\n\n  return cloud;\n}","map":{"version":3,"mappings":"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","names":["isNil","isFunction","assign","DEFAULT_OPTIONS","font","padding","size","spiral","timeInterval","wordCloud","words","options","transform","layout","tagCloud","forEach","key","imageMask","createMask","result","start","tags","_tags","tag","x","y","w","h","push","text","value","opacity","cloudRadians","Math","PI","cw","ch","cloudText","d","cloudFont","cloudFontNormal","cloudFontSize","cloudRotate","random","cloudPadding","cloudSprite","contextAndRatio","data","di","sprite","c","context","ratio","clearRect","maxh","n","length","save","style","weight","measureText","width","rotate","sr","sin","cr","cos","wcr","wsr","hcr","hsr","max","abs","translate","fillText","lineWidth","strokeText","restore","height","xoff","yoff","x1","y1","x0","y0","hasText","pixels","getImageData","w32","i","seen","seenRow","j","k","m","slice","cloudCollide","board","sw","lx","sx","msx","last","cloudBounds","bounds","b0","b1","collideRects","a","b","archimedeanSpiral","e","t","rectangularSpiral","dy","dx","sign","sqrt","zeroArray","cloudCanvas","document","createElement","functor","spirals","archimedean","rectangular","fontSize","fontWeight","Infinity","fontStyle","canvas","cloud","getContext","map","call","sort","step","Date","now","place","hasImage","_bounds","fillStyle","strokeStyle","textAlign","startX","startY","maxDelta","s","dt","dxdy","min","img","can","cxt","drawImage","imageData","tmp","flag","_"],"sourceRoot":"","sources":["../../../src/utils/transform/word-cloud.ts"],"sourcesContent":["import { isNil, isFunction, assign } from '@antv/util';\r\nimport { Tag, Word } from '../../plots/word-cloud/types';\r\n\r\ntype FontWeight = number | 'normal' | 'bold' | 'bolder' | 'lighter';\r\n\r\nexport interface Options {\r\n  size: [number, number];\r\n  font?: string | ((row: Word, index?: number, words?: Word[]) => string);\r\n  fontSize?: number | ((row: Word, index?: number, words?: Word[]) => number);\r\n  fontWeight?: FontWeight | ((row: Word, index?: number, words?: Word[]) => FontWeight);\r\n  rotate?: number | ((row: Word, index?: number, words?: Word[]) => number);\r\n  padding?: number | ((row: Word, index?: number, words?: Word[]) => number);\r\n  spiral?: 'archimedean' | 'rectangular' | ((size: [number, number]) => (t: number) => number[]);\r\n  random?: number | (() => number);\r\n  timeInterval?: number;\r\n  imageMask?: HTMLImageElement;\r\n}\r\n\r\nconst DEFAULT_OPTIONS: Options = {\r\n  font: () => 'serif',\r\n  padding: 1,\r\n  size: [500, 500],\r\n  spiral: 'archimedean', // 'archimedean' || 'rectangular' || {function}\r\n  // timeInterval: Infinity // max execute time\r\n  timeInterval: 3000, // max execute time\r\n  // imageMask: '', // instance of Image, must be loaded\r\n};\r\n\r\n/**\r\n * 根据对应的数据对象，计算每个\r\n * 词语在画布中的渲染位置，并返回\r\n * 计算后的数据对象\r\n * @param words\r\n * @param options\r\n */\r\nexport function wordCloud(words: Word[], options?: Partial<Options>): Tag[] {\r\n  // 混入默认配置\r\n  options = assign({} as Options, DEFAULT_OPTIONS, options);\r\n  return transform(words, options as Options);\r\n}\r\n\r\n/**\r\n * 抛出没有混入默认配置的方法，用于测试。\r\n * @param words\r\n * @param options\r\n */\r\nexport function transform(words: Word[], options: Options) {\r\n  // 布局对象\r\n  const layout = tagCloud();\r\n  ['font', 'fontSize', 'fontWeight', 'padding', 'rotate', 'size', 'spiral', 'timeInterval', 'random'].forEach(\r\n    (key: string) => {\r\n      if (!isNil(options[key])) {\r\n        layout[key](options[key]);\r\n      }\r\n    }\r\n  );\r\n\r\n  layout.words(words);\r\n  if (options.imageMask) {\r\n    layout.createMask(options.imageMask);\r\n  }\r\n\r\n  const result = layout.start();\r\n  const tags: any[] = result._tags;\r\n\r\n  tags.forEach((tag) => {\r\n    tag.x += options.size[0] / 2;\r\n    tag.y += options.size[1] / 2;\r\n  });\r\n\r\n  const [w, h] = options.size;\r\n  // 添加两个参照数据，分别表示左上角和右下角。\r\n  // 不添加的话不会按照真实的坐标渲染，而是以\r\n  // 数据中的边界坐标为边界进行拉伸，以铺满画布。\r\n  // 这样的后果会导致词语之间的重叠。\r\n  tags.push({\r\n    text: '',\r\n    value: 0,\r\n    x: 0,\r\n    y: 0,\r\n    opacity: 0,\r\n  });\r\n  tags.push({\r\n    text: '',\r\n    value: 0,\r\n    x: w,\r\n    y: h,\r\n    opacity: 0,\r\n  });\r\n\r\n  return tags;\r\n}\r\n\r\n/*\r\n * Synchronous version of d3-cloud\r\n */\r\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\r\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\r\n/* eslint-disable no-return-assign, no-cond-assign */\r\n\r\ninterface Item {\r\n  value: number;\r\n  text: string;\r\n  sprite: boolean;\r\n}\r\n\r\nconst cloudRadians = Math.PI / 180,\r\n  cw = (1 << 11) >> 5,\r\n  ch = 1 << 11;\r\n\r\nfunction cloudText(d: Item) {\r\n  return d.text;\r\n}\r\n\r\nfunction cloudFont() {\r\n  return 'serif';\r\n}\r\n\r\nfunction cloudFontNormal() {\r\n  return 'normal';\r\n}\r\n\r\nfunction cloudFontSize(d: Item) {\r\n  return d.value;\r\n}\r\n\r\nfunction cloudRotate() {\r\n  return ~~(Math.random() * 2) * 90;\r\n}\r\n\r\nfunction cloudPadding() {\r\n  return 1;\r\n}\r\n\r\n// Fetches a monochrome sprite bitmap for the specified text.\r\n// Load in batches for speed.\r\nfunction cloudSprite(contextAndRatio, d, data, di) {\r\n  if (d.sprite) return;\r\n  const c = contextAndRatio.context,\r\n    ratio = contextAndRatio.ratio;\r\n\r\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\r\n  let x = 0,\r\n    y = 0,\r\n    maxh = 0;\r\n  const n = data.length;\r\n  --di;\r\n  while (++di < n) {\r\n    d = data[di];\r\n    c.save();\r\n    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;\r\n    let w = c.measureText(d.text + 'm').width * ratio,\r\n      h = d.size << 1;\r\n    if (d.rotate) {\r\n      const sr = Math.sin(d.rotate * cloudRadians),\r\n        cr = Math.cos(d.rotate * cloudRadians),\r\n        wcr = w * cr,\r\n        wsr = w * sr,\r\n        hcr = h * cr,\r\n        hsr = h * sr;\r\n      w = ((Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5) << 5;\r\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\r\n    } else {\r\n      w = ((w + 0x1f) >> 5) << 5;\r\n    }\r\n    if (h > maxh) maxh = h;\r\n    if (x + w >= cw << 5) {\r\n      x = 0;\r\n      y += maxh;\r\n      maxh = 0;\r\n    }\r\n    if (y + h >= ch) break;\r\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\r\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\r\n    c.fillText(d.text, 0, 0);\r\n    if (d.padding) {\r\n      c.lineWidth = 2 * d.padding;\r\n      c.strokeText(d.text, 0, 0);\r\n    }\r\n    c.restore();\r\n    d.width = w;\r\n    d.height = h;\r\n    d.xoff = x;\r\n    d.yoff = y;\r\n    d.x1 = w >> 1;\r\n    d.y1 = h >> 1;\r\n    d.x0 = -d.x1;\r\n    d.y0 = -d.y1;\r\n    d.hasText = true;\r\n    x += w;\r\n  }\r\n  const pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\r\n    sprite = [];\r\n  while (--di >= 0) {\r\n    d = data[di];\r\n    if (!d.hasText) continue;\r\n    const w = d.width,\r\n      w32 = w >> 5;\r\n    let h = d.y1 - d.y0;\r\n    // Zero the buffer\r\n    for (let i = 0; i < h * w32; i++) sprite[i] = 0;\r\n    x = d.xoff;\r\n    if (x == null) return;\r\n    y = d.yoff;\r\n    let seen = 0,\r\n      seenRow = -1;\r\n    for (let j = 0; j < h; j++) {\r\n      for (let i = 0; i < w; i++) {\r\n        const k = w32 * j + (i >> 5),\r\n          m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\r\n        sprite[k] |= m;\r\n        seen |= m;\r\n      }\r\n      if (seen) seenRow = j;\r\n      else {\r\n        d.y0++;\r\n        h--;\r\n        j--;\r\n        y++;\r\n      }\r\n    }\r\n    d.y1 = d.y0 + seenRow;\r\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\r\n  }\r\n}\r\n\r\n// Use mask-based collision detection.\r\nfunction cloudCollide(tag, board, sw) {\r\n  sw >>= 5;\r\n  const sprite = tag.sprite,\r\n    w = tag.width >> 5,\r\n    lx = tag.x - (w << 4),\r\n    sx = lx & 0x7f,\r\n    msx = 32 - sx,\r\n    h = tag.y1 - tag.y0;\r\n  let x = (tag.y + tag.y0) * sw + (lx >> 5),\r\n    last;\r\n  for (let j = 0; j < h; j++) {\r\n    last = 0;\r\n    for (let i = 0; i <= w; i++) {\r\n      if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;\r\n    }\r\n    x += sw;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction cloudBounds(bounds, d) {\r\n  const b0 = bounds[0],\r\n    b1 = bounds[1];\r\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\r\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\r\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\r\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\r\n}\r\n\r\nfunction collideRects(a, b) {\r\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\r\n}\r\n\r\nfunction archimedeanSpiral(size) {\r\n  const e = size[0] / size[1];\r\n  return function (t) {\r\n    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\r\n  };\r\n}\r\n\r\nfunction rectangularSpiral(size) {\r\n  const dy = 4,\r\n    dx = (dy * size[0]) / size[1];\r\n  let x = 0,\r\n    y = 0;\r\n  return function (t) {\r\n    const sign = t < 0 ? -1 : 1;\r\n    // See triangular numbers: T_n = n * (n + 1) / 2.\r\n    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\r\n      case 0:\r\n        x += dx;\r\n        break;\r\n      case 1:\r\n        y += dy;\r\n        break;\r\n      case 2:\r\n        x -= dx;\r\n        break;\r\n      default:\r\n        y -= dy;\r\n        break;\r\n    }\r\n    return [x, y];\r\n  };\r\n}\r\n\r\n// TODO reuse arrays?\r\nfunction zeroArray(n) {\r\n  const a = [];\r\n  let i = -1;\r\n  while (++i < n) a[i] = 0;\r\n  return a;\r\n}\r\n\r\nfunction cloudCanvas() {\r\n  return document.createElement('canvas');\r\n}\r\n\r\nexport function functor(d) {\r\n  return isFunction(d)\r\n    ? d\r\n    : function () {\r\n        return d;\r\n      };\r\n}\r\n\r\nconst spirals = {\r\n  archimedean: archimedeanSpiral,\r\n  rectangular: rectangularSpiral,\r\n};\r\n\r\nfunction tagCloud() {\r\n  let size = [256, 256],\r\n    font = cloudFont,\r\n    fontSize = cloudFontSize,\r\n    fontWeight = cloudFontNormal,\r\n    rotate = cloudRotate,\r\n    padding = cloudPadding,\r\n    spiral = archimedeanSpiral,\r\n    random = Math.random,\r\n    words = [],\r\n    timeInterval = Infinity;\r\n\r\n  const text = cloudText;\r\n  const fontStyle = cloudFontNormal;\r\n  const canvas = cloudCanvas;\r\n  const cloud: any = {};\r\n\r\n  cloud.start = function () {\r\n    const [width, height] = size;\r\n    const contextAndRatio = getContext(canvas()),\r\n      board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]),\r\n      n = words.length,\r\n      tags = [],\r\n      data = words\r\n        .map(function (d, i, data) {\r\n          d.text = text.call(this, d, i, data);\r\n          d.font = font.call(this, d, i, data);\r\n          d.style = fontStyle.call(this, d, i, data);\r\n          d.weight = fontWeight.call(this, d, i, data);\r\n          d.rotate = rotate.call(this, d, i, data);\r\n          d.size = ~~fontSize.call(this, d, i, data);\r\n          d.padding = padding.call(this, d, i, data);\r\n          return d;\r\n        })\r\n        .sort(function (a, b) {\r\n          return b.size - a.size;\r\n        });\r\n    let i = -1,\r\n      bounds = !cloud.board\r\n        ? null\r\n        : [\r\n            {\r\n              x: 0,\r\n              y: 0,\r\n            },\r\n            {\r\n              x: width,\r\n              y: height,\r\n            },\r\n          ];\r\n\r\n    step();\r\n\r\n    function step() {\r\n      const start = Date.now();\r\n      while (Date.now() - start < timeInterval && ++i < n) {\r\n        const d = data[i];\r\n        d.x = (width * (random() + 0.5)) >> 1;\r\n        d.y = (height * (random() + 0.5)) >> 1;\r\n        cloudSprite(contextAndRatio, d, data, i);\r\n        if (d.hasText && place(board, d, bounds)) {\r\n          tags.push(d);\r\n          if (bounds) {\r\n            if (!cloud.hasImage) {\r\n              // update bounds if image mask not set\r\n              cloudBounds(bounds, d);\r\n            }\r\n          } else {\r\n            bounds = [\r\n              { x: d.x + d.x0, y: d.y + d.y0 },\r\n              { x: d.x + d.x1, y: d.y + d.y1 },\r\n            ];\r\n          }\r\n          // Temporary hack\r\n          d.x -= size[0] >> 1;\r\n          d.y -= size[1] >> 1;\r\n        }\r\n      }\r\n      cloud._tags = tags;\r\n      cloud._bounds = bounds;\r\n    }\r\n\r\n    return cloud;\r\n  };\r\n\r\n  function getContext(canvas: HTMLCanvasElement) {\r\n    canvas.width = canvas.height = 1;\r\n    const ratio = Math.sqrt(canvas.getContext('2d')!.getImageData(0, 0, 1, 1).data.length >> 2);\r\n    canvas.width = (cw << 5) / ratio;\r\n    canvas.height = ch / ratio;\r\n\r\n    const context = canvas.getContext('2d') as CanvasRenderingContext2D;\r\n    context.fillStyle = context.strokeStyle = 'red';\r\n    context.textAlign = 'center';\r\n    return { context, ratio };\r\n  }\r\n\r\n  function place(board, tag, bounds) {\r\n    // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\r\n    const startX = tag.x,\r\n      startY = tag.y,\r\n      maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\r\n      s = spiral(size),\r\n      dt = random() < 0.5 ? 1 : -1;\r\n    let dxdy,\r\n      t = -dt,\r\n      dx,\r\n      dy;\r\n\r\n    while ((dxdy = s((t += dt)))) {\r\n      dx = ~~dxdy[0];\r\n      dy = ~~dxdy[1];\r\n\r\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\r\n\r\n      tag.x = startX + dx;\r\n      tag.y = startY + dy;\r\n\r\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\r\n      // TODO only check for collisions within current bounds.\r\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\r\n        if (!bounds || collideRects(tag, bounds)) {\r\n          const sprite = tag.sprite,\r\n            w = tag.width >> 5,\r\n            sw = size[0] >> 5,\r\n            lx = tag.x - (w << 4),\r\n            sx = lx & 0x7f,\r\n            msx = 32 - sx,\r\n            h = tag.y1 - tag.y0;\r\n          let last,\r\n            x = (tag.y + tag.y0) * sw + (lx >> 5);\r\n          for (let j = 0; j < h; j++) {\r\n            last = 0;\r\n            for (let i = 0; i <= w; i++) {\r\n              board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\r\n            }\r\n            x += sw;\r\n          }\r\n          delete tag.sprite;\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  cloud.createMask = (img: HTMLImageElement) => {\r\n    const can: HTMLCanvasElement = document.createElement('canvas');\r\n    const [width, height] = size;\r\n\r\n    // 当 width 或 height 为 0 时，调用 cxt.getImageData 会报错\r\n    if (!width || !height) {\r\n      return;\r\n    }\r\n    const w32 = width >> 5;\r\n    const board = zeroArray((width >> 5) * height);\r\n    can.width = width;\r\n    can.height = height;\r\n    const cxt = can.getContext('2d') as CanvasRenderingContext2D;\r\n    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\r\n    const imageData = cxt.getImageData(0, 0, width, height).data;\r\n    for (let j = 0; j < height; j++) {\r\n      for (let i = 0; i < width; i++) {\r\n        const k = w32 * j + (i >> 5);\r\n        const tmp = (j * width + i) << 2;\r\n        const flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;\r\n        const m = flag ? 1 << (31 - (i % 32)) : 0;\r\n        board[k] |= m;\r\n      }\r\n    }\r\n    cloud.board = board;\r\n    cloud.hasImage = true;\r\n  };\r\n\r\n  cloud.timeInterval = function (_) {\r\n    timeInterval = _ == null ? Infinity : _;\r\n  };\r\n\r\n  cloud.words = function (_) {\r\n    words = _;\r\n  };\r\n\r\n  cloud.size = function (_) {\r\n    size = [+_[0], +_[1]];\r\n  };\r\n\r\n  cloud.font = function (_) {\r\n    font = functor(_);\r\n  };\r\n\r\n  cloud.fontWeight = function (_) {\r\n    fontWeight = functor(_);\r\n  };\r\n\r\n  cloud.rotate = function (_) {\r\n    rotate = functor(_);\r\n  };\r\n\r\n  cloud.spiral = function (_) {\r\n    spiral = spirals[_] || _;\r\n  };\r\n\r\n  cloud.fontSize = function (_) {\r\n    fontSize = functor(_);\r\n  };\r\n\r\n  cloud.padding = function (_) {\r\n    padding = functor(_);\r\n  };\r\n\r\n  cloud.random = function (_) {\r\n    random = functor(_);\r\n  };\r\n\r\n  return cloud;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}