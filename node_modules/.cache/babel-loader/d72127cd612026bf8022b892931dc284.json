{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { __assign, __read, __spreadArray } from \"tslib\";\nimport { firstValue, get, isEmpty, isNil, isNumber, isString, valuesOfKey } from '@antv/util';\nimport { GROUP_ATTRS } from '../constant';\nimport { getScale } from '../dependents';\nimport { isFullCircle } from './coordinate';\nvar dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\1(?:29|30)|(?:0?[13578]|1[02])\\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\\2(?:29))(\\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;\n/**\n * 获取字段对应数据的类型\n * @param field 数据字段名\n * @param data 数据源\n * @returns default type 返回对应的数据类型\n */\n\nfunction getDefaultType(value) {\n  var type = 'linear';\n\n  if (dateRegex.test(value)) {\n    type = 'timeCat';\n  } else if (isString(value)) {\n    type = 'cat';\n  }\n\n  return type;\n}\n/**\n * using the scale type if user specified, otherwise infer the type\n */\n\n\nexport function inferScaleType(scale, scaleDef, attrType, geometryType) {\n  if (scaleDef === void 0) {\n    scaleDef = {};\n  }\n\n  if (scaleDef.type) return scaleDef.type; // identity scale 直接返回\n  // geometry 类型有: edge,heatmap,interval,line,path,point,polygon,schema,voilin等；理论上，interval 下，可以用 linear scale 作为分组字段\n\n  if (scale.type !== 'identity' && GROUP_ATTRS.includes(attrType) && ['interval'].includes(geometryType)) {\n    return 'cat';\n  }\n\n  return scale.isCategory ? 'cat' : scale.type;\n}\n/**\n * @ignore\n * 为指定的 `field` 字段数据创建 scale\n * @param field 字段名\n * @param [data] 数据集，可为空\n * @param [scaleDef] 列定义，可为空\n * @returns scale 返回创建的 Scale 实例\n */\n\nexport function createScaleByField(field, data, scaleDef) {\n  var validData = data || [];\n\n  if (isNumber(field) || isNil(firstValue(validData, field)) && isEmpty(scaleDef)) {\n    var Identity = getScale('identity');\n    return new Identity({\n      field: field.toString(),\n      values: [field]\n    });\n  }\n\n  var values = valuesOfKey(validData, field); // 如果已经定义过这个度量 (fix-later 单纯从数据中，推断 scale type 是不精确的)\n\n  var type = get(scaleDef, 'type', getDefaultType(values[0]));\n  var ScaleCtor = getScale(type);\n  return new ScaleCtor(__assign({\n    field: field,\n    values: values\n  }, scaleDef));\n}\n/**\n * @ignore\n * 同步 scale\n * @todo 是否可以通过 scale.update() 方法进行更新\n * @param scale 需要同步的 scale 实例\n * @param newScale 同步源 Scale\n */\n\nexport function syncScale(scale, newScale) {\n  if (scale.type !== 'identity' && newScale.type !== 'identity') {\n    var obj = {};\n\n    for (var k in newScale) {\n      if (Object.prototype.hasOwnProperty.call(newScale, k)) {\n        obj[k] = newScale[k];\n      }\n    }\n\n    scale.change(obj);\n  }\n}\n/**\n * @ignore\n * get the scale name, if alias exist, return alias, or else field\n * @param scale\n * @returns the name of field\n */\n\nexport function getName(scale) {\n  return scale.alias || scale.field;\n}\n/**\n * 根据 scale values 和 coordinate 获取分类默认 range\n * @param scale 需要获取的 scale 实例\n * @param coordinate coordinate 实例\n * @param theme theme\n */\n\nexport function getDefaultCategoryScaleRange(scale, coordinate, theme) {\n  var values = scale.values;\n  var count = values.length;\n  var range;\n\n  if (count === 1) {\n    range = [0.5, 1]; // 只有一个分类时,防止计算出现 [0.5,0.5] 的状态\n  } else {\n    var widthRatio = 1;\n    var offset = 0;\n\n    if (isFullCircle(coordinate)) {\n      if (!coordinate.isTransposed) {\n        range = [0, 1 - 1 / count];\n      } else {\n        widthRatio = get(theme, 'widthRatio.multiplePie', 1 / 1.3);\n        offset = 1 / count * widthRatio;\n        range = [offset / 2, 1 - offset / 2];\n      }\n    } else {\n      offset = 1 / count / 2; // 两边留下分类空间的一半\n\n      range = [offset, 1 - offset]; // 坐标轴最前面和最后面留下空白防止绘制柱状图时\n    }\n  }\n\n  return range;\n}\n/**\n * @function y轴scale的max\n * @param {yScale}\n */\n\nexport function getMaxScale(scale) {\n  // 过滤values[]中 NaN/undefined/null 等\n  var values = scale.values.filter(function (item) {\n    return !isNil(item) && !isNaN(item);\n  });\n  return Math.max.apply(Math, __spreadArray(__spreadArray([], __read(values), false), [isNil(scale.max) ? -Infinity : scale.max], false));\n}","map":{"version":3,"mappings":"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","names":["firstValue","get","isEmpty","isNil","isNumber","isString","valuesOfKey","GROUP_ATTRS","getScale","isFullCircle","dateRegex","getDefaultType","value","type","test","inferScaleType","scale","scaleDef","attrType","geometryType","includes","isCategory","createScaleByField","field","data","validData","Identity","toString","values","ScaleCtor","__assign","syncScale","newScale","obj","k","Object","prototype","hasOwnProperty","call","change","getName","alias","getDefaultCategoryScaleRange","coordinate","theme","count","length","range","widthRatio","offset","isTransposed","getMaxScale","filter","item","isNaN","Math","max","apply","__spreadArray","Infinity"],"sourceRoot":"","sources":["../../src/util/scale.ts"],"sourcesContent":["import { firstValue, get, isEmpty, isNil, isNumber, isString, valuesOfKey } from '@antv/util';\nimport { GROUP_ATTRS } from '../constant';\nimport { getScale, Scale, Coordinate } from '../dependents';\nimport { LooseObject, ScaleOption, ViewCfg } from '../interface';\nimport { isFullCircle } from './coordinate';\n\nconst dateRegex =\n  /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\1(?:29|30)|(?:0?[13578]|1[02])\\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\\2(?:29))(\\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;\n\n/**\n * 获取字段对应数据的类型\n * @param field 数据字段名\n * @param data 数据源\n * @returns default type 返回对应的数据类型\n */\nfunction getDefaultType(value: any): string {\n  let type = 'linear';\n  if (dateRegex.test(value)) {\n    type = 'timeCat';\n  } else if (isString(value)) {\n    type = 'cat';\n  }\n  return type;\n}\n\n/**\n * using the scale type if user specified, otherwise infer the type\n */\nexport function inferScaleType(scale: Scale, scaleDef: ScaleOption = {}, attrType: string, geometryType: string): string {\n  if (scaleDef.type) return scaleDef.type;\n  // identity scale 直接返回\n  // geometry 类型有: edge,heatmap,interval,line,path,point,polygon,schema,voilin等；理论上，interval 下，可以用 linear scale 作为分组字段\n  if (scale.type !== 'identity' && GROUP_ATTRS.includes(attrType) && ['interval'].includes(geometryType)) {\n    return 'cat';\n  }\n  return scale.isCategory ? 'cat' : scale.type;\n}\n\n/**\n * @ignore\n * 为指定的 `field` 字段数据创建 scale\n * @param field 字段名\n * @param [data] 数据集，可为空\n * @param [scaleDef] 列定义，可为空\n * @returns scale 返回创建的 Scale 实例\n */\nexport function createScaleByField(field: string | number, data?: LooseObject[] | [], scaleDef?: ScaleOption): Scale {\n  const validData = data || [];\n\n  if (isNumber(field) || (isNil(firstValue(validData, field)) && isEmpty(scaleDef))) {\n    const Identity = getScale('identity');\n    return new Identity({\n      field: field.toString(),\n      values: [field],\n    });\n  }\n\n  const values = valuesOfKey(validData, field);\n\n  // 如果已经定义过这个度量 (fix-later 单纯从数据中，推断 scale type 是不精确的)\n  const type = get(scaleDef, 'type', getDefaultType(values[0]));\n  const ScaleCtor = getScale(type);\n  return new ScaleCtor({\n    field,\n    values,\n    ...scaleDef,\n  });\n}\n\n/**\n * @ignore\n * 同步 scale\n * @todo 是否可以通过 scale.update() 方法进行更新\n * @param scale 需要同步的 scale 实例\n * @param newScale 同步源 Scale\n */\nexport function syncScale(scale: Scale, newScale: Scale) {\n  if (scale.type !== 'identity' && newScale.type !== 'identity') {\n    const obj = {};\n    for (const k in newScale) {\n      if (Object.prototype.hasOwnProperty.call(newScale, k)) {\n        obj[k] = newScale[k];\n      }\n    }\n\n    scale.change(obj);\n  }\n}\n\n/**\n * @ignore\n * get the scale name, if alias exist, return alias, or else field\n * @param scale\n * @returns the name of field\n */\nexport function getName(scale: Scale): string {\n  return scale.alias || scale.field;\n}\n\n/**\n * 根据 scale values 和 coordinate 获取分类默认 range\n * @param scale 需要获取的 scale 实例\n * @param coordinate coordinate 实例\n * @param theme theme\n */\nexport function getDefaultCategoryScaleRange(\n  scale: Scale,\n  coordinate: Coordinate,\n  theme: ViewCfg['theme']\n): Scale['range'] {\n  const { values } = scale;\n  const count = values.length;\n  let range;\n\n  if (count === 1) {\n    range = [0.5, 1]; // 只有一个分类时,防止计算出现 [0.5,0.5] 的状态\n  } else {\n    let widthRatio = 1;\n    let offset = 0;\n\n    if (isFullCircle(coordinate)) {\n      if (!coordinate.isTransposed) {\n        range = [0, 1 - 1 / count];\n      } else {\n        widthRatio = get(theme, 'widthRatio.multiplePie', 1 / 1.3);\n        offset = (1 / count) * widthRatio;\n        range = [offset / 2, 1 - offset / 2];\n      }\n    } else {\n      offset = 1 / count / 2; // 两边留下分类空间的一半\n      range = [offset, 1 - offset]; // 坐标轴最前面和最后面留下空白防止绘制柱状图时\n    }\n  }\n  return range;\n}\n\n/**\n * @function y轴scale的max\n * @param {yScale}\n */\nexport function getMaxScale(scale: Scale) {\n  // 过滤values[]中 NaN/undefined/null 等\n  const values = scale.values.filter((item) => !isNil(item) && !isNaN(item));\n\n  return Math.max(...values, isNil(scale.max) ? -Infinity : scale.max);\n}\n"]},"metadata":{},"sourceType":"module"}