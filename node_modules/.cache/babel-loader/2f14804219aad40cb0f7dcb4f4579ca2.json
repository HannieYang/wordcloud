{"ast":null,"code":"import { nelderMead } from 'fmin';\nimport { intersectionArea, distance, getCenter } from './circleintersection';\n\nfunction circleMargin(current, interior, exterior) {\n  var margin = interior[0].radius - distance(interior[0], current),\n      i,\n      m;\n\n  for (i = 1; i < interior.length; ++i) {\n    m = interior[i].radius - distance(interior[i], current);\n\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    m = distance(exterior[i], current) - exterior[i].radius;\n\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  return margin;\n} // compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\n\n\nexport function computeTextCentre(interior, exterior) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  var points = [];\n  var i;\n\n  for (i = 0; i < interior.length; ++i) {\n    var c = interior[i];\n    points.push({\n      x: c.x,\n      y: c.y\n    });\n    points.push({\n      x: c.x + c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x - c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x,\n      y: c.y + c.radius / 2\n    });\n    points.push({\n      x: c.x,\n      y: c.y - c.radius / 2\n    });\n  }\n\n  var initial = points[0],\n      margin = circleMargin(points[0], interior, exterior);\n\n  for (i = 1; i < points.length; ++i) {\n    var m = circleMargin(points[i], interior, exterior);\n\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  } // maximize the margin numerically\n\n\n  var solution = nelderMead(function (p) {\n    return -1 * circleMargin({\n      x: p[0],\n      y: p[1]\n    }, interior, exterior);\n  }, [initial.x, initial.y], {\n    maxIterations: 500,\n    minErrorDelta: 1e-10\n  }).x;\n  var ret = {\n    x: solution[0],\n    y: solution[1]\n  }; // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n\n  var valid = true;\n\n  for (i = 0; i < interior.length; ++i) {\n    if (distance(ret, interior[i]) > interior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    if (distance(ret, exterior[i]) < exterior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  if (!valid) {\n    if (interior.length == 1) {\n      ret = {\n        x: interior[0].x,\n        y: interior[0].y\n      };\n    } else {\n      var areaStats = {};\n      intersectionArea(interior, areaStats);\n\n      if (areaStats.arcs.length === 0) {\n        ret = {\n          x: 0,\n          y: -1000,\n          disjoint: true\n        };\n      } else if (areaStats.arcs.length == 1) {\n        ret = {\n          x: areaStats.arcs[0].circle.x,\n          y: areaStats.arcs[0].circle.y\n        };\n      } else if (exterior.length) {\n        // try again without other circles\n        ret = computeTextCentre(interior, []);\n      } else {\n        // take average of all the points in the intersection\n        // polygon. this should basically never happen\n        // and has some issues:\n        // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n        ret = getCenter(areaStats.arcs.map(function (a) {\n          return a.p1;\n        }));\n      }\n    }\n  }\n\n  return ret;\n} // given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\n\nfunction getOverlappingCircles(circles) {\n  var ret = {},\n      circleids = [];\n\n  for (var circleid in circles) {\n    circleids.push(circleid);\n    ret[circleid] = [];\n  }\n\n  for (var i = 0; i < circleids.length; i++) {\n    var a = circles[circleids[i]];\n\n    for (var j = i + 1; j < circleids.length; ++j) {\n      var b = circles[circleids[j]],\n          d = distance(a, b);\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[circleids[j]].push(circleids[i]);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[circleids[i]].push(circleids[j]);\n      }\n    }\n  }\n\n  return ret;\n}\n\nexport function computeTextCentres(circles, areas) {\n  var ret = {},\n      overlapped = getOverlappingCircles(circles);\n\n  for (var i = 0; i < areas.length; ++i) {\n    var area = areas[i].sets,\n        areaids = {},\n        exclude = {};\n\n    for (var j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      var overlaps = overlapped[area[j]]; // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n\n      for (var k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n\n    var interior = [],\n        exterior = [];\n\n    for (var setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n\n    var centre = computeTextCentre(interior, exterior);\n    ret[area] = centre;\n\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n\n  return ret;\n}\n/**\n * 根据圆心(x, y) 半径 r 返回圆的绘制 path\n * @param x 圆心点 x\n * @param y 圆心点 y\n * @param r 圆的半径\n * @returns 圆的 path\n */\n\nexport function circlePath(x, y, r) {\n  var ret = []; // ret.push('\\nM', x, y);\n  // ret.push('\\nm', -r, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n\n  var x0 = x - r;\n  var y0 = y;\n  ret.push('M', x0, y0);\n  ret.push('A', r, r, 0, 1, 0, x0 + 2 * r, y0);\n  ret.push('A', r, r, 0, 1, 0, x0, y0);\n  return ret.join(' ');\n} // inverse of the circlePath function, returns a circle object from an svg path\n\nexport function circleFromPath(path) {\n  var tokens = path.split(' ');\n  return {\n    x: parseFloat(tokens[1]),\n    y: parseFloat(tokens[2]),\n    radius: -parseFloat(tokens[4])\n  };\n}\n/** returns a svg path of the intersection area of a bunch of circles */\n\nexport function intersectionAreaPath(circles) {\n  var stats = {};\n  intersectionArea(circles, stats);\n  var arcs = stats.arcs;\n\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  } else if (arcs.length == 1) {\n    var circle = arcs[0].circle;\n    return circlePath(circle.x, circle.y, circle.radius);\n  } else {\n    // draw path around arcs\n    var ret = ['\\nM', arcs[0].p2.x, arcs[0].p2.y];\n\n    for (var i = 0; i < arcs.length; ++i) {\n      var arc = arcs[i],\n          r = arc.circle.radius,\n          wide = arc.width > r;\n      ret.push('\\nA', r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);\n    }\n\n    return ret.join(' ');\n  }\n}","map":{"version":3,"mappings":"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","names":["nelderMead","intersectionArea","distance","getCenter","circleMargin","current","interior","exterior","margin","radius","i","m","length","computeTextCentre","points","c","push","x","y","initial","solution","p","maxIterations","minErrorDelta","ret","valid","areaStats","arcs","disjoint","circle","map","a","p1","getOverlappingCircles","circles","circleids","circleid","j","b","d","computeTextCentres","areas","overlapped","area","sets","areaids","exclude","overlaps","k","setid","centre","size","console","log","circlePath","r","x0","y0","join","circleFromPath","path","tokens","split","parseFloat","intersectionAreaPath","stats","p2","arc","wide","width"],"sourceRoot":"","sources":["../../../../src/plots/venn/layout/diagram.ts"],"sourcesContent":["import { nelderMead } from 'fmin';\nimport { intersectionArea, distance, getCenter } from './circleintersection';\n\nfunction circleMargin(current, interior, exterior) {\n  let margin = interior[0].radius - distance(interior[0], current),\n    i,\n    m;\n  for (i = 1; i < interior.length; ++i) {\n    m = interior[i].radius - distance(interior[i], current);\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    m = distance(exterior[i], current) - exterior[i].radius;\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  return margin;\n}\n\n// compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\nexport function computeTextCentre(interior, exterior) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  const points = [];\n  let i;\n  for (i = 0; i < interior.length; ++i) {\n    const c = interior[i];\n    points.push({ x: c.x, y: c.y });\n    points.push({ x: c.x + c.radius / 2, y: c.y });\n    points.push({ x: c.x - c.radius / 2, y: c.y });\n    points.push({ x: c.x, y: c.y + c.radius / 2 });\n    points.push({ x: c.x, y: c.y - c.radius / 2 });\n  }\n  let initial = points[0],\n    margin = circleMargin(points[0], interior, exterior);\n  for (i = 1; i < points.length; ++i) {\n    const m = circleMargin(points[i], interior, exterior);\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  }\n\n  // maximize the margin numerically\n  const solution = nelderMead(\n    function (p) {\n      return -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior);\n    },\n    [initial.x, initial.y],\n    { maxIterations: 500, minErrorDelta: 1e-10 }\n  ).x;\n  let ret: any = { x: solution[0], y: solution[1] };\n\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  let valid = true;\n  for (i = 0; i < interior.length; ++i) {\n    if (distance(ret, interior[i]) > interior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    if (distance(ret, exterior[i]) < exterior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  if (!valid) {\n    if (interior.length == 1) {\n      ret = { x: interior[0].x, y: interior[0].y };\n    } else {\n      const areaStats: any = {};\n      intersectionArea(interior, areaStats);\n\n      if (areaStats.arcs.length === 0) {\n        ret = { x: 0, y: -1000, disjoint: true };\n      } else if (areaStats.arcs.length == 1) {\n        ret = { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };\n      } else if (exterior.length) {\n        // try again without other circles\n        ret = computeTextCentre(interior, []);\n      } else {\n        // take average of all the points in the intersection\n        // polygon. this should basically never happen\n        // and has some issues:\n        // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n        ret = getCenter(\n          areaStats.arcs.map(function (a) {\n            return a.p1;\n          })\n        );\n      }\n    }\n  }\n\n  return ret;\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n  const ret = {},\n    circleids = [];\n  for (const circleid in circles) {\n    circleids.push(circleid);\n    ret[circleid] = [];\n  }\n  for (let i = 0; i < circleids.length; i++) {\n    const a = circles[circleids[i]];\n    for (let j = i + 1; j < circleids.length; ++j) {\n      const b = circles[circleids[j]],\n        d = distance(a, b);\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[circleids[j]].push(circleids[i]);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[circleids[i]].push(circleids[j]);\n      }\n    }\n  }\n  return ret;\n}\n\nexport function computeTextCentres(circles, areas) {\n  const ret = {},\n    overlapped = getOverlappingCircles(circles);\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i].sets,\n      areaids = {},\n      exclude = {};\n    for (let j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      const overlaps = overlapped[area[j]];\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (let k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n\n    const interior = [],\n      exterior = [];\n    for (const setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n    const centre = computeTextCentre(interior, exterior);\n    ret[area] = centre;\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n  return ret;\n}\n\n/**\n * 根据圆心(x, y) 半径 r 返回圆的绘制 path\n * @param x 圆心点 x\n * @param y 圆心点 y\n * @param r 圆的半径\n * @returns 圆的 path\n */\nexport function circlePath(x, y, r) {\n  const ret = [];\n  // ret.push('\\nM', x, y);\n  // ret.push('\\nm', -r, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n  const x0 = x - r;\n  const y0 = y;\n  ret.push('M', x0, y0);\n  ret.push('A', r, r, 0, 1, 0, x0 + 2 * r, y0);\n  ret.push('A', r, r, 0, 1, 0, x0, y0);\n\n  return ret.join(' ');\n}\n\n// inverse of the circlePath function, returns a circle object from an svg path\nexport function circleFromPath(path) {\n  const tokens = path.split(' ');\n  return { x: parseFloat(tokens[1]), y: parseFloat(tokens[2]), radius: -parseFloat(tokens[4]) };\n}\n\n/** returns a svg path of the intersection area of a bunch of circles */\nexport function intersectionAreaPath(circles) {\n  const stats: any = {};\n  intersectionArea(circles, stats);\n  const arcs = stats.arcs;\n\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  } else if (arcs.length == 1) {\n    const circle = arcs[0].circle;\n    return circlePath(circle.x, circle.y, circle.radius);\n  } else {\n    // draw path around arcs\n    const ret = ['\\nM', arcs[0].p2.x, arcs[0].p2.y];\n    for (let i = 0; i < arcs.length; ++i) {\n      const arc = arcs[i],\n        r = arc.circle.radius,\n        wide = arc.width > r;\n      ret.push('\\nA', r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);\n    }\n    return ret.join(' ');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}