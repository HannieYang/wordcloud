{"ast":null,"code":"import { getSectorPath } from './graphics';\nimport { isBetween } from './helper';\nimport { BBox } from './bbox';\n/**\n * @ignore\n * Gets x dimension length\n * @param coordinate\n * @returns x dimension length\n */\n\nexport function getXDimensionLength(coordinate) {\n  if (coordinate.isPolar && !coordinate.isTransposed) {\n    // 极坐标系下 width 为弧长\n    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();\n  } // 直角坐标系\n\n\n  var start = coordinate.convert({\n    x: 0,\n    y: 0\n  });\n  var end = coordinate.convert({\n    x: 1,\n    y: 0\n  }); // 坐标系有可能发生 transpose 等变换，所有通过两点之间的距离进行计算\n\n  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n}\n/**\n * @ignore\n * Determines whether full circle is\n * @param coordinate\n * @returns true if full circle\n */\n\nexport function isFullCircle(coordinate) {\n  if (coordinate.isPolar) {\n    var startAngle = coordinate.startAngle,\n        endAngle = coordinate.endAngle;\n    return endAngle - startAngle === Math.PI * 2;\n  }\n\n  return false;\n}\n/**\n * @ignore\n * 获取当前点到坐标系圆心的距离\n * @param coordinate 坐标系\n * @param point 当前点\n * @returns distance to center\n */\n\nexport function getDistanceToCenter(coordinate, point) {\n  var center = coordinate.getCenter();\n  return Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));\n}\n/**\n * @ignore\n * 坐标点是否在坐标系中\n * @param coordinate\n * @param point\n */\n\nexport function isPointInCoordinate(coordinate, point) {\n  var result = false;\n\n  if (coordinate) {\n    if (coordinate.type === 'theta') {\n      var start = coordinate.start,\n          end = coordinate.end;\n      result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);\n    } else {\n      var invertPoint = coordinate.invert(point);\n      result = isBetween(invertPoint.x, 0, 1) && isBetween(invertPoint.y, 0, 1);\n    }\n  }\n\n  return result;\n}\n/**\n * @ignore\n * 获取点到圆心的连线与水平方向的夹角\n */\n\nexport function getAngleByPoint(coordinate, point) {\n  var center = coordinate.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n/**\n * @ignore\n * 获取同坐标系范围相同的剪切区域\n * @param coordinate\n * @returns\n */\n\nexport function getCoordinateClipCfg(coordinate, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  var start = coordinate.start,\n      end = coordinate.end;\n  var width = coordinate.getWidth();\n  var height = coordinate.getHeight();\n\n  if (coordinate.isPolar) {\n    var startAngle_1 = coordinate.startAngle,\n        endAngle_1 = coordinate.endAngle;\n    var center_1 = coordinate.getCenter();\n    var radius_1 = coordinate.getRadius();\n    return {\n      type: 'path',\n      startState: {\n        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)\n      },\n      endState: function (ratio) {\n        var diff = (endAngle_1 - startAngle_1) * ratio + startAngle_1;\n        var path = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff);\n        return {\n          path: path\n        };\n      },\n      attrs: {\n        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)\n      }\n    };\n  }\n\n  var endState;\n\n  if (coordinate.isTransposed) {\n    endState = {\n      height: height + margin * 2\n    };\n  } else {\n    endState = {\n      width: width + margin * 2\n    };\n  }\n\n  return {\n    type: 'rect',\n    startState: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: coordinate.isTransposed ? width + margin * 2 : 0,\n      height: coordinate.isTransposed ? 0 : height + margin * 2\n    },\n    endState: endState,\n    attrs: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: width + margin * 2,\n      height: height + margin * 2\n    }\n  };\n}\n/**\n * 获取坐标系范围的 BBox\n * @param coordinate\n * @param margin\n */\n\nexport function getCoordinateBBox(coordinate, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n\n  var start = coordinate.start,\n      end = coordinate.end;\n  var width = coordinate.getWidth();\n  var height = coordinate.getHeight();\n  var minX = Math.min(start.x, end.x);\n  var minY = Math.min(start.y, end.y);\n  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);\n}","map":{"version":3,"mappings":"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","names":["getSectorPath","isBetween","BBox","getXDimensionLength","coordinate","isPolar","isTransposed","endAngle","startAngle","getRadius","start","convert","x","y","end","Math","sqrt","pow","isFullCircle","PI","getDistanceToCenter","point","center","getCenter","isPointInCoordinate","result","type","invertPoint","invert","getAngleByPoint","atan2","getCoordinateClipCfg","margin","width","getWidth","height","getHeight","endAngle_1","center_1","radius_1","startState","path","startAngle_1","endState","ratio","diff","attrs","getCoordinateBBox","minX","min","minY","fromRange"],"sourceRoot":"","sources":["../../src/util/coordinate.ts"],"sourcesContent":["import { Coordinate } from '../dependents';\nimport { Point } from '../interface';\nimport { getSectorPath } from './graphics';\nimport { isBetween } from './helper';\nimport { BBox } from './bbox';\n\n/**\n * @ignore\n * Gets x dimension length\n * @param coordinate\n * @returns x dimension length\n */\nexport function getXDimensionLength(coordinate): number {\n  if (coordinate.isPolar && !coordinate.isTransposed) {\n    // 极坐标系下 width 为弧长\n    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();\n  }\n\n  // 直角坐标系\n  const start = coordinate.convert({ x: 0, y: 0 });\n  const end = coordinate.convert({ x: 1, y: 0 });\n  // 坐标系有可能发生 transpose 等变换，所有通过两点之间的距离进行计算\n  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n}\n\n/**\n * @ignore\n * Determines whether full circle is\n * @param coordinate\n * @returns true if full circle\n */\nexport function isFullCircle(coordinate: Coordinate): boolean {\n  if (coordinate.isPolar) {\n    const { startAngle, endAngle } = coordinate;\n    return endAngle - startAngle === Math.PI * 2;\n  }\n  return false;\n}\n\n/**\n * @ignore\n * 获取当前点到坐标系圆心的距离\n * @param coordinate 坐标系\n * @param point 当前点\n * @returns distance to center\n */\nexport function getDistanceToCenter(coordinate: Coordinate, point: Point): number {\n  const center = coordinate.getCenter() as Point;\n  return Math.sqrt((point.x - center.x) ** 2 + (point.y - center.y) ** 2);\n}\n\n/**\n * @ignore\n * 坐标点是否在坐标系中\n * @param coordinate\n * @param point\n */\nexport function isPointInCoordinate(coordinate: Coordinate, point: Point) {\n  let result = false;\n\n  if (coordinate) {\n    if (coordinate.type === 'theta') {\n      const { start, end } = coordinate;\n      result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);\n    } else {\n      const invertPoint = coordinate.invert(point);\n    \n      result = isBetween(invertPoint.x, 0, 1) && isBetween(invertPoint.y, 0, 1);\n    }\n  }\n\n  return result;\n}\n\n/**\n * @ignore\n * 获取点到圆心的连线与水平方向的夹角\n */\nexport function getAngleByPoint(coordinate: Coordinate, point: Point): number {\n  const center = coordinate.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n\n/**\n * @ignore\n * 获取同坐标系范围相同的剪切区域\n * @param coordinate\n * @returns\n */\nexport function getCoordinateClipCfg(coordinate: Coordinate, margin: number = 0) {\n  const { start, end } = coordinate;\n  const width = coordinate.getWidth();\n  const height = coordinate.getHeight();\n\n  if (coordinate.isPolar) {\n    const { startAngle, endAngle } = coordinate;\n    const center = coordinate.getCenter();\n    const radius = coordinate.getRadius();\n\n    return {\n      type: 'path',\n      startState: {\n        path: getSectorPath(center.x, center.y, radius + margin, startAngle, startAngle),\n      },\n      endState: (ratio) => {\n        const diff = (endAngle - startAngle) * ratio + startAngle;\n        const path = getSectorPath(center.x, center.y, radius + margin, startAngle, diff);\n        return {\n          path,\n        };\n      },\n      attrs: {\n        path: getSectorPath(center.x, center.y, radius + margin, startAngle, endAngle),\n      },\n    };\n  }\n\n  let endState;\n  if (coordinate.isTransposed) {\n    endState = {\n      height: height + margin * 2,\n    };\n  } else {\n    endState = {\n      width: width + margin * 2,\n    };\n  }\n\n  return {\n    type: 'rect',\n    startState: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: coordinate.isTransposed ? width + margin * 2 : 0,\n      height: coordinate.isTransposed ? 0 : height + margin * 2,\n    },\n    endState,\n    attrs: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: width + margin * 2,\n      height: height + margin * 2,\n    },\n  };\n}\n\n/**\n * 获取坐标系范围的 BBox\n * @param coordinate\n * @param margin\n */\nexport function getCoordinateBBox(coordinate: Coordinate, margin = 0) {\n  const { start, end } = coordinate;\n  const width = coordinate.getWidth();\n  const height = coordinate.getHeight();\n  const minX = Math.min(start.x, end.x);\n  const minY = Math.min(start.y, end.y);\n\n  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);\n}\n"]},"metadata":{},"sourceType":"module"}