{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { getCirclePoint } from '../util/util';\nimport CrosshairBase from './base';\n\nvar LineCrosshair =\n/** @class */\nfunction (_super) {\n  __extends(LineCrosshair, _super);\n\n  function LineCrosshair() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  LineCrosshair.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n\n    return __assign(__assign({}, cfg), {\n      type: 'circle',\n      locationType: 'circle',\n      center: null,\n      radius: 100,\n      startAngle: -Math.PI / 2,\n      endAngle: Math.PI * 3 / 2\n    });\n  };\n\n  LineCrosshair.prototype.getRotateAngle = function () {\n    var _a = this.getLocation(),\n        startAngle = _a.startAngle,\n        endAngle = _a.endAngle;\n\n    var position = this.get('text').position;\n    var tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;\n    return tangentAngle;\n  };\n\n  LineCrosshair.prototype.getTextPoint = function () {\n    var text = this.get('text');\n    var position = text.position,\n        offset = text.offset;\n\n    var _a = this.getLocation(),\n        center = _a.center,\n        radius = _a.radius,\n        startAngle = _a.startAngle,\n        endAngle = _a.endAngle;\n\n    var angle = position === 'start' ? startAngle : endAngle;\n    var tangentAngle = this.getRotateAngle() - Math.PI;\n    var point = getCirclePoint(center, radius, angle); // 这个地方其实应该求切线向量然后在乘以 offset，但是太啰嗦了，直接给出结果\n    // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];\n    // const offsetVector = vec2.scale([], tangent, offset);\n\n    var offsetX = Math.cos(tangentAngle) * offset;\n    var offsetY = Math.sin(tangentAngle) * offset;\n    return {\n      x: point.x + offsetX,\n      y: point.y + offsetY\n    };\n  };\n\n  LineCrosshair.prototype.getLinePath = function () {\n    var _a = this.getLocation(),\n        center = _a.center,\n        radius = _a.radius,\n        startAngle = _a.startAngle,\n        endAngle = _a.endAngle;\n\n    var path = null;\n\n    if (endAngle - startAngle === Math.PI * 2) {\n      // 整圆\n      var x = center.x,\n          y = center.y;\n      path = [['M', x, y - radius], ['A', radius, radius, 0, 1, 1, x, y + radius], ['A', radius, radius, 0, 1, 1, x, y - radius], ['Z']];\n    } else {\n      var startPoint = getCirclePoint(center, radius, startAngle);\n      var endPoint = getCirclePoint(center, radius, endAngle);\n      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      var sweep = startAngle > endAngle ? 0 : 1;\n      path = [['M', startPoint.x, startPoint.y], ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y]];\n    }\n\n    return path;\n  };\n\n  return LineCrosshair;\n}(CrosshairBase);\n\nexport default LineCrosshair;","map":{"version":3,"mappings":"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","names":["getCirclePoint","CrosshairBase","__extends","LineCrosshair","cfg","_super","getDefaultCfg","call","type","locationType","center","radius","startAngle","Math","PI","endAngle","getLocation","get","position","tangentAngle","text","offset","angle","getRotateAngle","point","offsetX","cos","offsetY","sin","x","y","path","startPoint","endPoint","large","abs","sweep"],"sourceRoot":"","sources":["../../src/crosshair/circle.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}