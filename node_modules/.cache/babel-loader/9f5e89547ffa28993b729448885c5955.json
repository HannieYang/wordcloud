{"ast":null,"code":"import { __assign, __extends, __spreadArrays } from \"tslib\";\nimport { Action } from '@antv/g2';\nimport { get } from '@antv/util';\nimport { findViewById } from '../../../../utils';\nimport { EDGES_VIEW_ID, NODES_VIEW_ID } from '../../constant';\n\nvar SankeyNodeDragAction =\n/** @class */\nfunction (_super) {\n  __extends(SankeyNodeDragAction, _super);\n\n  function SankeyNodeDragAction() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * 是否在拖拽中的标记\n     */\n\n\n    _this.isDragging = false;\n    return _this;\n  }\n  /**\n   * 当前操作的是否是 element\n   */\n\n\n  SankeyNodeDragAction.prototype.isNodeElement = function () {\n    var shape = get(this.context, 'event.target');\n\n    if (shape) {\n      var element = shape.get('element');\n      return element && element.getModel().data.isNode;\n    }\n\n    return false;\n  };\n\n  SankeyNodeDragAction.prototype.getNodeView = function () {\n    return findViewById(this.context.view, NODES_VIEW_ID);\n  };\n\n  SankeyNodeDragAction.prototype.getEdgeView = function () {\n    return findViewById(this.context.view, EDGES_VIEW_ID);\n  };\n  /**\n   * 获取当前操作的 index\n   * @param element\n   */\n\n\n  SankeyNodeDragAction.prototype.getCurrentDatumIdx = function (element) {\n    return this.getNodeView().geometries[0].elements.indexOf(element);\n  };\n  /**\n   * 点击下去，开始\n   */\n\n\n  SankeyNodeDragAction.prototype.start = function () {\n    // 记录开始了的状态\n    if (this.isNodeElement()) {\n      this.prevPoint = {\n        x: get(this.context, 'event.x'),\n        y: get(this.context, 'event.y')\n      };\n      var element = this.context.event.target.get('element');\n      var idx = this.getCurrentDatumIdx(element);\n\n      if (idx === -1) {\n        return;\n      }\n\n      this.currentElementIdx = idx;\n      this.context.isDragging = true;\n      this.isDragging = true; // 关闭动画并暂存配置\n\n      this.prevNodeAnimateCfg = this.getNodeView().getOptions().animate;\n      this.prevEdgeAnimateCfg = this.getEdgeView().getOptions().animate;\n      this.getNodeView().animate(false);\n      this.getEdgeView().animate(false);\n    }\n  };\n  /**\n   * 移动过程中，平移\n   */\n\n\n  SankeyNodeDragAction.prototype.translate = function () {\n    if (this.isDragging) {\n      var chart = this.context.view;\n      var currentPoint = {\n        x: get(this.context, 'event.x'),\n        y: get(this.context, 'event.y')\n      };\n      var x = currentPoint.x - this.prevPoint.x;\n      var y = currentPoint.y - this.prevPoint.y;\n      var nodeView = this.getNodeView();\n      var element = nodeView.geometries[0].elements[this.currentElementIdx]; // 修改数据\n\n      if (element && element.getModel()) {\n        var prevDatum = element.getModel().data;\n        var data = nodeView.getOptions().data;\n        var coordinate = nodeView.getCoordinate();\n        var datumGap_1 = {\n          x: x / coordinate.getWidth(),\n          y: y / coordinate.getHeight()\n        };\n\n        var nextDatum = __assign(__assign({}, prevDatum), {\n          x: prevDatum.x.map(function (x) {\n            return x += datumGap_1.x;\n          }),\n          y: prevDatum.y.map(function (y) {\n            return y += datumGap_1.y;\n          })\n        }); // 处理一下在 [0, 1] 范围\n        // 1. 更新 node 数据\n\n\n        var newData = __spreadArrays(data);\n\n        newData[this.currentElementIdx] = nextDatum;\n        nodeView.data(newData); // 2. 更新 edge 数据\n\n        var name_1 = prevDatum.name;\n        var edgeView = this.getEdgeView();\n        var edgeData = edgeView.getOptions().data;\n        edgeData.forEach(function (datum) {\n          // 2.1 以该 node 为 source 的边，修改 [x0, x1, x2, x3] 中的 x0, x1\n          if (datum.source === name_1) {\n            datum.x[0] += datumGap_1.x;\n            datum.x[1] += datumGap_1.x;\n            datum.y[0] += datumGap_1.y;\n            datum.y[1] += datumGap_1.y;\n          } // 2.2 以该 node 为 target 的边，修改 [x0, x1, x2, x3] 中的 x2, x3\n\n\n          if (datum.target === name_1) {\n            datum.x[2] += datumGap_1.x;\n            datum.x[3] += datumGap_1.x;\n            datum.y[2] += datumGap_1.y;\n            datum.y[3] += datumGap_1.y;\n          }\n        });\n        edgeView.data(edgeData); // 3. 更新最新位置\n\n        this.prevPoint = currentPoint; // node edge 都改变了，所以要从底层 render\n\n        chart.render(true);\n      }\n    }\n  };\n  /**\n   * 结论，清除状态\n   */\n\n\n  SankeyNodeDragAction.prototype.end = function () {\n    this.isDragging = false;\n    this.context.isDragging = false;\n    this.prevPoint = null;\n    this.currentElementIdx = null; // 还原动画\n\n    this.getNodeView().animate(this.prevNodeAnimateCfg);\n    this.getEdgeView().animate(this.prevEdgeAnimateCfg);\n  };\n\n  return SankeyNodeDragAction;\n}(Action);\n\nexport { SankeyNodeDragAction };","map":{"version":3,"mappings":"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","names":["Action","get","findViewById","EDGES_VIEW_ID","NODES_VIEW_ID","__extends","_this","SankeyNodeDragAction","shape","context","element","getModel","data","isNode","view","getNodeView","geometries","elements","indexOf","isNodeElement","prevPoint","x","y","event","target","idx","getCurrentDatumIdx","currentElementIdx","isDragging","prevNodeAnimateCfg","getOptions","animate","prevEdgeAnimateCfg","getEdgeView","chart","currentPoint","nodeView","prevDatum","coordinate","getCoordinate","datumGap_1","getWidth","getHeight","nextDatum","map","newData","name_1","name","edgeView","edgeData","forEach","datum","source","render"],"sourceRoot":"","sources":["../../../../../src/plots/sankey/interactions/actions/node-drag.ts"],"sourcesContent":["import { Action, Element } from '@antv/g2';\nimport { get } from '@antv/util';\nimport { Datum, Point } from '../../../../types';\nimport { findViewById } from '../../../../utils';\nimport { EDGES_VIEW_ID, NODES_VIEW_ID } from '../../constant';\n\nexport class SankeyNodeDragAction extends Action {\n  /**\n   * 是否在拖拽中的标记\n   */\n  private isDragging = false;\n\n  /**\n   * 鼠标上一次的位置的坐标点\n   */\n  private prevPoint: Point;\n  /**\n   * 之前的节点动画配置\n   */\n  private prevNodeAnimateCfg: any;\n  /**\n   * 之前的边动画配置\n   */\n  private prevEdgeAnimateCfg: any;\n  /**\n   * 当前拖拽的 element 索引\n   */\n  private currentElementIdx: number;\n\n  /**\n   * 当前操作的是否是 element\n   */\n  private isNodeElement() {\n    const shape = get(this.context, 'event.target');\n    if (shape) {\n      const element = shape.get('element');\n      return element && element.getModel().data.isNode;\n    }\n    return false;\n  }\n\n  private getNodeView() {\n    return findViewById(this.context.view, NODES_VIEW_ID);\n  }\n\n  private getEdgeView() {\n    return findViewById(this.context.view, EDGES_VIEW_ID);\n  }\n\n  /**\n   * 获取当前操作的 index\n   * @param element\n   */\n  private getCurrentDatumIdx(element: Element) {\n    return this.getNodeView().geometries[0].elements.indexOf(element);\n  }\n\n  /**\n   * 点击下去，开始\n   */\n  public start() {\n    // 记录开始了的状态\n    if (this.isNodeElement()) {\n      this.prevPoint = {\n        x: get(this.context, 'event.x'),\n        y: get(this.context, 'event.y'),\n      };\n\n      const element = this.context.event.target.get('element');\n      const idx = this.getCurrentDatumIdx(element);\n\n      if (idx === -1) {\n        return;\n      }\n\n      this.currentElementIdx = idx;\n      this.context.isDragging = true;\n      this.isDragging = true;\n\n      // 关闭动画并暂存配置\n      this.prevNodeAnimateCfg = this.getNodeView().getOptions().animate;\n      this.prevEdgeAnimateCfg = this.getEdgeView().getOptions().animate;\n      this.getNodeView().animate(false);\n      this.getEdgeView().animate(false);\n    }\n  }\n\n  /**\n   * 移动过程中，平移\n   */\n  public translate() {\n    if (this.isDragging) {\n      const chart = this.context.view;\n\n      const currentPoint = {\n        x: get(this.context, 'event.x'),\n        y: get(this.context, 'event.y'),\n      };\n\n      const x = currentPoint.x - this.prevPoint.x;\n      const y = currentPoint.y - this.prevPoint.y;\n\n      const nodeView = this.getNodeView();\n      const element = nodeView.geometries[0].elements[this.currentElementIdx];\n\n      // 修改数据\n      if (element && element.getModel()) {\n        const prevDatum: Datum = element.getModel().data;\n        const data = nodeView.getOptions().data;\n        const coordinate = nodeView.getCoordinate();\n\n        const datumGap = {\n          x: x / coordinate.getWidth(),\n          y: y / coordinate.getHeight(),\n        };\n\n        const nextDatum = {\n          ...prevDatum,\n          x: prevDatum.x.map((x: number) => (x += datumGap.x)),\n          y: prevDatum.y.map((y: number) => (y += datumGap.y)),\n        };\n        // 处理一下在 [0, 1] 范围\n\n        // 1. 更新 node 数据\n        const newData = [...data];\n        newData[this.currentElementIdx] = nextDatum;\n        nodeView.data(newData);\n\n        // 2. 更新 edge 数据\n        const name = prevDatum.name;\n        const edgeView = this.getEdgeView();\n        const edgeData = edgeView.getOptions().data;\n\n        edgeData.forEach((datum) => {\n          // 2.1 以该 node 为 source 的边，修改 [x0, x1, x2, x3] 中的 x0, x1\n          if (datum.source === name) {\n            datum.x[0] += datumGap.x;\n            datum.x[1] += datumGap.x;\n            datum.y[0] += datumGap.y;\n            datum.y[1] += datumGap.y;\n          }\n\n          // 2.2 以该 node 为 target 的边，修改 [x0, x1, x2, x3] 中的 x2, x3\n          if (datum.target === name) {\n            datum.x[2] += datumGap.x;\n            datum.x[3] += datumGap.x;\n            datum.y[2] += datumGap.y;\n            datum.y[3] += datumGap.y;\n          }\n        });\n        edgeView.data(edgeData);\n\n        // 3. 更新最新位置\n        this.prevPoint = currentPoint;\n\n        // node edge 都改变了，所以要从底层 render\n        chart.render(true);\n      }\n    }\n  }\n\n  /**\n   * 结论，清除状态\n   */\n  public end() {\n    this.isDragging = false;\n    this.context.isDragging = false;\n    this.prevPoint = null;\n    this.currentElementIdx = null;\n\n    // 还原动画\n    this.getNodeView().animate(this.prevNodeAnimateCfg);\n    this.getEdgeView().animate(this.prevEdgeAnimateCfg);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}