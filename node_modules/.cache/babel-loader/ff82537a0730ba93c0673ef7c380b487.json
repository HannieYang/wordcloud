{"ast":null,"code":"import { __values } from \"tslib\";\nimport { each, get, isNil, deepMix, groupBy } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { antiCollision } from './util';\nimport { translate } from '../../../../util/transform';\n/** 拐点偏移量, 暂不可配置 */\n\nvar INFLECTION_OFFSET = 4;\n/** 标签偏移量, distance between label and edge: offsetX */\n\nvar LABEL_OFFSET_X = 4;\n/** 标签与牵引线的偏移量 */\n\nvar LABEL_TEXT_LINE_OFFSET = 4;\n\nfunction drawLabelline(item, coordinate, inRight) {\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n\n  var radius = coordinate.getRadius();\n  var startPoint = {\n    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),\n    y: item.y\n  };\n  var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n  var p1 = {\n    x: startPoint.x,\n    y: startPoint.y\n  };\n  var p2 = {\n    x: inflectionPoint.x,\n    y: inflectionPoint.y\n  };\n  var endPoint = polarToCartesian(center.x, center.y, radius, item.angle);\n  var path = ''; // 文本被调整下去了，则添加拐点连接线\n\n  if (startPoint.y !== inflectionPoint.y) {\n    var offset = inRight ? 4 : -4;\n    p1.y = startPoint.y;\n    /** 是否在第一象限 */\n\n    if (item.angle < 0 && item.angle >= -Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第二象限 */\n\n\n    if (item.angle > 0 && item.angle < Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第三象限 */\n\n\n    if (item.angle > Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第四象限 */\n\n\n    if (item.angle < -Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n  }\n\n  path = [\"M \".concat(startPoint.x, \",\").concat(startPoint.y), \"L \".concat(p1.x, \",\").concat(p1.y), \"L \".concat(p2.x, \",\").concat(p2.y), \"L \".concat(inflectionPoint.x, \",\").concat(inflectionPoint.y), \"L \".concat(endPoint.x, \",\").concat(endPoint.y)].join(' ');\n  item.labelLine = deepMix({}, item.labelLine, {\n    path: path\n  });\n}\n/**\n * 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型\n * region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)\n */\n\n\nexport function pieSpiderLabelLayout(items, labels, shapes, region) {\n  var e_1, _a;\n  /** 坐标系 */\n\n\n  var coordinate = labels[0] && labels[0].get('coordinate');\n\n  if (!coordinate) {\n    return;\n  }\n  /** 坐标圆心 */\n\n\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n\n  var radius = coordinate.getRadius();\n  /** label shapes */\n\n  var labelsMap = {};\n\n  try {\n    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {\n      var labelShape = labels_1_1.value;\n      labelsMap[labelShape.get('id')] = labelShape;\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (labels_1_1 && !labels_1_1.done && (_a = labels_1.return)) _a.call(labels_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  var labelHeight = get(items[0], 'labelHeight', 14);\n  var labelOffset = Math.max(get(items[0], 'offset', 0), INFLECTION_OFFSET); // step 1: adjust items to spider\n\n  each(items, function (item) {\n    if (!item) return;\n    var label = get(labelsMap, [item.id]);\n    if (!label) return;\n    var inRight = item.x > center.x || item.x === center.x && item.y > center.y;\n    var offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;\n    var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n    var totalOffset = labelOffset + offsetX;\n    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);\n    item.y = inflectionPoint.y;\n  });\n  var start = coordinate.start,\n      end = coordinate.end;\n  var LEFT_HALF_KEY = 'left';\n  var RIGHT_HALF_KEY = 'right'; // step 1: separate labels\n\n  var separateLabels = groupBy(items, function (item) {\n    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;\n  }); // step2: calculate totalHeight\n\n  var totalHeight = (radius + labelOffset) * 2 + labelHeight;\n  each(separateLabels, function (half) {\n    var halfHeight = half.length * labelHeight;\n\n    if (halfHeight > totalHeight) {\n      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));\n    }\n  });\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n\n  var labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalHeight / 2,\n    maxY: center.y + totalHeight / 2\n  }; // step 3: antiCollision\n\n  each(separateLabels, function (half, key) {\n    var maxLabelsCountForOneSide = totalHeight / labelHeight;\n\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort(function (a, b) {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n      each(half, function (labelItem, idx) {\n        if (idx > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n  var startY = labelsContainerRange.minY;\n  var endY = labelsContainerRange.maxY; // step4: applyTo labels and adjust labelLines\n\n  each(separateLabels, function (half, key) {\n    var inRight = key === RIGHT_HALF_KEY;\n    each(half, function (item) {\n      var label = get(labelsMap, item && [item.id]);\n\n      if (!label) {\n        return;\n      } // out of range, hidden\n\n\n      if (item.y < startY || item.y > endY) {\n        label.set('visible', false);\n        return;\n      }\n\n      var labelContent = label.getChildByIndex(0);\n      var box = labelContent.getCanvasBBox();\n      var originalPos = {\n        x: inRight ? box.x : box.maxX,\n        y: box.y + box.height / 2\n        /** vertical-align: middle */\n\n      };\n      translate(labelContent, item.x - originalPos.x\n      /** 从 pos.x 移动到 item.x */\n      , item.y - originalPos.y); // adjust labelLines\n\n      if (item.labelLine) {\n        drawLabelline(item, coordinate, inRight);\n      }\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["each","get","isNil","deepMix","groupBy","polarToCartesian","antiCollision","translate","INFLECTION_OFFSET","LABEL_OFFSET_X","LABEL_TEXT_LINE_OFFSET","drawLabelline","item","coordinate","inRight","center","getCenter","radius","getRadius","startPoint","x","y","inflectionPoint","angle","p1","p2","endPoint","path","offset","Math","PI","max","min","concat","join","labelLine","pieSpiderLabelLayout","items","labels","shapes","region","labelsMap","labels_1_1","labelShape","labelHeight","labelOffset","label","id","offsetX","totalOffset","end","LEFT_HALF_KEY","RIGHT_HALF_KEY","separateLabels","totalHeight","half","halfHeight","length","abs","start","labelsContainerRange","minX","maxX","minY","maxY","key","maxLabelsCountForOneSide","sort","a","b","percent","labelItem","idx","set","invisible","startY","endY","labelContent","getChildByIndex","box","getCanvasBBox","originalPos","height"],"sourceRoot":"","sources":["../../../../../src/geometry/label/layout/pie/spider.ts"],"sourcesContent":["import { BBox, IGroup, IShape } from '@antv/g-base';\nimport { each, get, isNil, deepMix, groupBy } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { LabelItem, PolarLabelItem } from '../../interface';\nimport { antiCollision } from './util';\nimport { translate } from '../../../../util/transform';\nimport { Coordinate } from '@antv/coord';\n\n/** 拐点偏移量, 暂不可配置 */\nconst INFLECTION_OFFSET = 4;\n/** 标签偏移量, distance between label and edge: offsetX */\nconst LABEL_OFFSET_X = 4;\n/** 标签与牵引线的偏移量 */\nconst LABEL_TEXT_LINE_OFFSET = 4;\n\nfunction drawLabelline(item: PolarLabelItem, coordinate: Coordinate, inRight: boolean) {\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  const startPoint = {\n    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),\n    y: item.y,\n  };\n  const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n  const p1 = { x: startPoint.x, y: startPoint.y };\n  const p2 = { x: inflectionPoint.x, y: inflectionPoint.y };\n\n  const endPoint = polarToCartesian(center.x, center.y, radius, item.angle);\n  let path = '';\n\n  // 文本被调整下去了，则添加拐点连接线\n  if (startPoint.y !== inflectionPoint.y) {\n    const offset = inRight ? 4 : -4;\n    p1.y = startPoint.y;\n\n    /** 是否在第一象限 */\n    if (item.angle < 0 && item.angle >= -Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第二象限 */\n    if (item.angle > 0 && item.angle < Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第三象限 */\n    if (item.angle > Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第四象限 */\n    if (item.angle < -Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n  }\n\n  path = [\n    `M ${startPoint.x},${startPoint.y}`,\n    `L ${p1.x},${p1.y}`,\n    `L ${p2.x},${p2.y}`,\n    `L ${inflectionPoint.x},${inflectionPoint.y}`,\n    `L ${endPoint.x},${endPoint.y}`,\n  ].join(' ');\n  item.labelLine = deepMix({}, item.labelLine, { path });\n}\n\n/**\n * 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型\n * region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)\n */\nexport function pieSpiderLabelLayout(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  /** 坐标系 */\n  const coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  /** label shapes */\n  const labelsMap: Record<string /** id */, IGroup> = {};\n  for (const labelShape of labels) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  const labelHeight: number = get(items[0], 'labelHeight', 14);\n  const labelOffset: number = Math.max(get(items[0], 'offset', 0), INFLECTION_OFFSET);\n\n  // step 1: adjust items to spider\n  each(items, (item) => {\n    if (!item) return;\n    const label = get(labelsMap, [item.id]);\n    if (!label) return;\n\n    const inRight = item.x > center.x || (item.x === center.x && item.y > center.y);\n    const offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;\n    const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n\n    const totalOffset = labelOffset + offsetX;\n    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);\n    item.y = inflectionPoint.y;\n  });\n\n  const { start, end } = coordinate;\n  const LEFT_HALF_KEY = 'left';\n  const RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  const separateLabels = groupBy(items, (item) => (item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY));\n\n  // step2: calculate totalHeight\n  let totalHeight = (radius + labelOffset) * 2 + labelHeight;\n\n  each(separateLabels, (half: PolarLabelItem[]) => {\n    const halfHeight = half.length * labelHeight;\n    if (halfHeight > totalHeight) {\n      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));\n    }\n  });\n\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  const labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalHeight / 2,\n    maxY: center.y + totalHeight / 2,\n  };\n\n  // step 3: antiCollision\n  each(separateLabels, (half, key) => {\n    const maxLabelsCountForOneSide = totalHeight / labelHeight;\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort((a, b) => {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n\n      each(half, (labelItem: PolarLabelItem, idx) => {\n        if (idx > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n\n  const startY = labelsContainerRange.minY;\n  const endY = labelsContainerRange.maxY;\n\n  // step4: applyTo labels and adjust labelLines\n  each(separateLabels, (half, key) => {\n    const inRight = key === RIGHT_HALF_KEY;\n\n    each(half, (item) => {\n      const label: IGroup = get(labelsMap, item && [item.id]);\n      if (!label) {\n        return;\n      }\n      // out of range, hidden\n      if (item.y < startY || item.y > endY) {\n        label.set('visible', false);\n        return;\n      }\n\n      const labelContent = label.getChildByIndex(0);\n      const box = labelContent.getCanvasBBox();\n      const originalPos = { x: inRight ? box.x : box.maxX, y: box.y + box.height / 2 /** vertical-align: middle */ };\n\n      translate(labelContent as any, item.x - originalPos.x /** 从 pos.x 移动到 item.x */, item.y - originalPos.y);\n\n      // adjust labelLines\n      if (item.labelLine) {\n        drawLabelline(item, coordinate, inRight);\n      }\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module"}