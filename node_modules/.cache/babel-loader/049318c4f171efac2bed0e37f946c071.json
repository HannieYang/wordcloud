{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport { deepMix, each, get, isArray, isFunction, isNil, isNumber, isUndefined } from '@antv/util';\nimport { FIELD_ORIGIN } from '../../constant';\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\nimport Labels from '../../component/labels';\n\nfunction avg(arr) {\n  var sum = 0;\n  each(arr, function (value) {\n    sum += value;\n  });\n  return sum / arr.length;\n}\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\n\n\nvar GeometryLabel =\n/** @class */\nfunction () {\n  function GeometryLabel(geometry) {\n    this.geometry = geometry;\n  }\n\n  GeometryLabel.prototype.getLabelItems = function (mapppingArray) {\n    var _this = this;\n\n    var items = [];\n    var labelCfgs = this.getLabelCfgs(mapppingArray); // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n\n    each(mapppingArray, function (mappingData, index) {\n      var labelCfg = labelCfgs[index];\n\n      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n        items.push(null);\n        return;\n      }\n\n      var labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n      labelCfg.content = labelContent;\n      var total = labelContent.length;\n      each(labelContent, function (content, subIndex) {\n        if (isNil(content) || content === '') {\n          items.push(null);\n          return;\n        }\n\n        var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));\n\n        if (!item.textAlign) {\n          item.textAlign = _this.getLabelAlign(item, subIndex, total);\n        }\n\n        if (item.offset <= 0) {\n          item.labelLine = null;\n        }\n\n        items.push(item);\n      });\n    });\n    return items;\n  };\n\n  GeometryLabel.prototype.render = function (mappingArray, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var labelItems, labelsRenderer, shapes;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            labelItems = this.getLabelItems(mappingArray);\n            labelsRenderer = this.getLabelsRenderer();\n            shapes = this.getGeometryShapes(); // 渲染文本\n\n            return [4\n            /*yield*/\n            , labelsRenderer.render(labelItems, shapes, isUpdate)];\n\n          case 1:\n            // 渲染文本\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  GeometryLabel.prototype.clear = function () {\n    var labelsRenderer = this.labelsRenderer;\n\n    if (labelsRenderer) {\n      labelsRenderer.clear();\n    }\n  };\n\n  GeometryLabel.prototype.destroy = function () {\n    var labelsRenderer = this.labelsRenderer;\n\n    if (labelsRenderer) {\n      labelsRenderer.destroy();\n    }\n\n    this.labelsRenderer = null;\n  }; // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n\n\n  GeometryLabel.prototype.getCoordinate = function () {\n    return this.geometry.coordinate;\n  };\n  /**\n   * 获取 label 的默认配置\n   */\n\n\n  GeometryLabel.prototype.getDefaultLabelCfg = function (offset, position) {\n    var geometry = this.geometry;\n    var type = geometry.type,\n        theme = geometry.theme;\n\n    if (type === 'polygon' || type === 'interval' && position === 'middle' || offset < 0 && !['line', 'point', 'path'].includes(type)) {\n      // polygon 或者 (interval 且 middle) 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      return get(theme, 'innerLabels', {});\n    }\n\n    return get(theme, 'labels', {});\n  };\n  /**\n   * 获取当前 label 的最终配置\n   * @param labelCfg\n   */\n\n\n  GeometryLabel.prototype.getThemedLabelCfg = function (labelCfg) {\n    var geometry = this.geometry;\n    var defaultLabelCfg = this.getDefaultLabelCfg();\n    var type = geometry.type,\n        theme = geometry.theme;\n    var themedLabelCfg;\n\n    if (type === 'polygon' || labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type)) {\n      // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n    } else {\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n    }\n\n    return themedLabelCfg;\n  };\n  /**\n   * 设置 label 位置\n   * @param labelPointCfg\n   * @param mappingData\n   * @param index\n   * @param position\n   */\n\n\n  GeometryLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {};\n  /**\n   * @desc 获取 label offset\n   */\n\n\n  GeometryLabel.prototype.getLabelOffset = function (offset) {\n    var coordinate = this.getCoordinate();\n    var vector = this.getOffsetVector(offset);\n    return coordinate.isTransposed ? vector[0] : vector[1];\n  };\n  /**\n   * 获取每个 label 的偏移量 (矢量)\n   * @param labelCfg\n   * @param index\n   * @param total\n   * @return {Point} offsetPoint\n   */\n\n\n  GeometryLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total) {\n    var offset = labelCfg.offset;\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var dim = transposed ? 'x' : 'y';\n    var factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n\n    var offsetPoint = {\n      x: 0,\n      y: 0\n    };\n\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[dim] = offset * factor;\n    } else {\n      offsetPoint[dim] = offset * factor * -1;\n    }\n\n    return offsetPoint;\n  };\n  /**\n   * 获取每个 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   * @returns label point\n   */\n\n\n  GeometryLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n    var coordinate = this.getCoordinate();\n    var total = labelCfg.content.length;\n\n    function getDimValue(value, idx, isAvg) {\n      if (isAvg === void 0) {\n        isAvg = false;\n      }\n\n      var v = value;\n\n      if (isArray(v)) {\n        if (labelCfg.content.length === 1) {\n          if (isAvg) {\n            v = avg(v);\n          } else {\n            // 如果仅一个 label，多个 y, 取最后一个 y\n            if (v.length <= 2) {\n              v = v[value.length - 1];\n            } else {\n              v = avg(v);\n            }\n          }\n        } else {\n          v = v[idx];\n        }\n      }\n\n      return v;\n    }\n\n    var label = {\n      content: labelCfg.content[index],\n      x: 0,\n      y: 0,\n      start: {\n        x: 0,\n        y: 0\n      },\n      color: '#fff'\n    };\n    var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    var isFunnel = shape === 'funnel' || shape === 'pyramid'; // 多边形场景，多用于地图\n\n    if (this.geometry.type === 'polygon') {\n      var centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else if (this.geometry.type === 'interval' && !isFunnel) {\n      // 对直方图的label X 方向的位置居中\n      label.x = getDimValue(mappingData.x, index, true);\n      label.y = getDimValue(mappingData.y, index);\n    } else {\n      label.x = getDimValue(mappingData.x, index);\n      label.y = getDimValue(mappingData.y, index);\n    } // 处理漏斗图文本位置\n\n\n    if (isFunnel) {\n      var nextPoints = get(mappingData, 'nextPoints');\n      var points = get(mappingData, 'points');\n\n      if (nextPoints) {\n        // 非漏斗图底部\n        var point1 = coordinate.convert(points[1]);\n        var point2 = coordinate.convert(nextPoints[1]);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      } else if (shape === 'pyramid') {\n        var point1 = coordinate.convert(points[1]);\n        var point2 = coordinate.convert(points[2]);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      }\n    }\n\n    if (labelCfg.position) {\n      // 如果 label 支持 position 属性\n      this.setLabelPosition(label, mappingData, index, labelCfg.position);\n    }\n\n    var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);\n    label.start = {\n      x: label.x,\n      y: label.y\n    };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = mappingData.color;\n    return label;\n  };\n  /**\n   * 获取文本的对齐方式\n   * @param item\n   * @param index\n   * @param total\n   * @returns\n   */\n\n\n  GeometryLabel.prototype.getLabelAlign = function (item, index, total) {\n    var align = 'center';\n    var coordinate = this.getCoordinate();\n\n    if (coordinate.isTransposed) {\n      var offset = item.offset;\n\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n\n    return align;\n  };\n  /**\n   * 获取每一个 label 的唯一 id\n   * @param mappingData label 对应的图形的绘制数据\n   */\n\n\n  GeometryLabel.prototype.getLabelId = function (mappingData) {\n    var geometry = this.geometry;\n    var type = geometry.type;\n    var xScale = geometry.getXScale();\n    var yScale = geometry.getYScale();\n    var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n\n    var labelId = geometry.getElementId(mappingData);\n\n    if (type === 'line' || type === 'area') {\n      // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n      labelId += \" \".concat(origin[xScale.field]);\n    } else if (type === 'path') {\n      // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n      labelId += \" \".concat(origin[xScale.field], \"-\").concat(origin[yScale.field]);\n    }\n\n    return labelId;\n  }; // 获取 labels 组件\n\n\n  GeometryLabel.prototype.getLabelsRenderer = function () {\n    var _a = this.geometry,\n        labelsContainer = _a.labelsContainer,\n        labelOption = _a.labelOption,\n        canvasRegion = _a.canvasRegion,\n        animateOption = _a.animateOption;\n    var coordinate = this.geometry.coordinate;\n    var labelsRenderer = this.labelsRenderer;\n\n    if (!labelsRenderer) {\n      labelsRenderer = new Labels({\n        container: labelsContainer,\n        layout: get(labelOption, ['cfg', 'layout'], {\n          type: this.defaultLayout\n        })\n      });\n      this.labelsRenderer = labelsRenderer;\n    }\n\n    labelsRenderer.region = canvasRegion; // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n\n    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n    return labelsRenderer;\n  };\n\n  GeometryLabel.prototype.getLabelCfgs = function (mapppingArray) {\n    var _this = this;\n\n    var geometry = this.geometry;\n    var labelOption = geometry.labelOption,\n        scales = geometry.scales,\n        coordinate = geometry.coordinate;\n    var _a = labelOption,\n        fields = _a.fields,\n        callback = _a.callback,\n        cfg = _a.cfg;\n    var labelScales = fields.map(function (field) {\n      return scales[field];\n    });\n    var labelCfgs = [];\n    each(mapppingArray, function (mappingData, index) {\n      var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n\n      var originText = _this.getLabelText(origin, labelScales);\n\n      var callbackCfg;\n\n      if (callback) {\n        // 当同时配置了 callback 和 cfg 时，以 callback 为准\n        var originValues = fields.map(function (field) {\n          return origin[field];\n        });\n        callbackCfg = callback.apply(void 0, __spreadArray([], __read(originValues), false));\n\n        if (isNil(callbackCfg)) {\n          labelCfgs.push(null);\n          return;\n        }\n      }\n\n      var labelCfg = __assign(__assign({\n        id: _this.getLabelId(mappingData),\n        elementId: _this.geometry.getElementId(mappingData),\n        data: origin,\n        // 存储原始数据\n        mappingData: mappingData,\n        // 存储映射后的数据,\n        coordinate: coordinate\n      }, cfg), callbackCfg);\n\n      if (isFunction(labelCfg.position)) {\n        labelCfg.position = labelCfg.position(origin, mappingData, index);\n      }\n\n      var offset = _this.getLabelOffset(labelCfg.offset || 0); // defaultCfg 需要判断 innerLabels & labels\n\n\n      var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position); // labelCfg priority: defaultCfg < cfg < callbackCfg\n\n\n      labelCfg = deepMix({}, defaultLabelCfg, labelCfg); // 获取最终的 offset\n\n      labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);\n      var content = labelCfg.content;\n\n      if (isFunction(content)) {\n        labelCfg.content = content(origin, mappingData, index);\n      } else if (isUndefined(content)) {\n        // 用户未配置 content，则默认为映射的第一个字段的值\n        labelCfg.content = originText[0];\n      }\n\n      labelCfgs.push(labelCfg);\n    });\n    return labelCfgs;\n  };\n\n  GeometryLabel.prototype.getLabelText = function (origin, scales) {\n    var labelTexts = [];\n    each(scales, function (scale) {\n      var value = origin[scale.field];\n\n      if (isArray(value)) {\n        value = value.map(function (subVal) {\n          return scale.getText(subVal);\n        });\n      } else {\n        value = scale.getText(value);\n      }\n\n      if (isNil(value) || value === '') {\n        labelTexts.push(null);\n      } else {\n        labelTexts.push(value);\n      }\n    });\n    return labelTexts;\n  };\n\n  GeometryLabel.prototype.getOffsetVector = function (offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    var coordinate = this.getCoordinate();\n    var actualOffset = 0;\n\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } // 如果 x,y 翻转，则偏移 x，否则偏移 y\n\n\n    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);\n  };\n\n  GeometryLabel.prototype.getGeometryShapes = function () {\n    var geometry = this.geometry;\n    var shapes = {};\n    each(geometry.elementsMap, function (element, id) {\n      shapes[id] = element.shape;\n    }); // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n\n    each(geometry.getOffscreenGroup().getChildren(), function (child) {\n      var id = geometry.getElementId(child.get('origin').mappingData);\n      shapes[id] = child;\n    });\n    return shapes;\n  };\n\n  return GeometryLabel;\n}();\n\nexport default GeometryLabel;","map":{"version":3,"mappings":"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","names":["deepMix","each","get","isArray","isFunction","isNil","isNumber","isUndefined","FIELD_ORIGIN","getDefaultAnimateCfg","getPolygonCentroid","Labels","avg","arr","sum","value","length","geometry","GeometryLabel","mapppingArray","items","labelCfgs","getLabelCfgs","mappingData","index","labelCfg","x","y","push","labelContent","content","total","subIndex","item","_this","getLabelPoint","textAlign","getLabelAlign","offset","labelLine","mappingArray","isUpdate","labelItems","getLabelItems","labelsRenderer","getLabelsRenderer","shapes","getGeometryShapes","render","_a","clear","destroy","coordinate","position","theme","type","includes","defaultLabelCfg","getDefaultLabelCfg","themedLabelCfg","innerLabels","labels","labelPointCfg","getCoordinate","vector","getOffsetVector","isTransposed","transposed","dim","factor","offsetPoint","getDimValue","idx","isAvg","v","label","start","color","shape","isFunnel","centroid","nextPoints","points","point1","convert","point2","setLabelPosition","getLabelOffsetPoint","align","xScale","getXScale","yScale","getYScale","origin","labelId","getElementId","field","concat","labelsContainer","labelOption","canvasRegion","animateOption","container","layout","defaultLayout","region","animate","scales","fields","callback","cfg","labelScales","map","originText","getLabelText","callbackCfg","originValues","__spreadArray","id","getLabelId","elementId","data","getLabelOffset","labelTexts","scale","subVal","getText","actualOffset","applyMatrix","elementsMap","element","getOffscreenGroup","getChildren","child"],"sourceRoot":"","sources":["../../../src/geometry/label/base.ts"],"sourcesContent":["import { deepMix, each, get, isArray, isFunction, isNil, isNumber, isString, isUndefined } from '@antv/util';\n\nimport { FIELD_ORIGIN } from '../../constant';\nimport { Scale } from '../../dependents';\nimport { Datum, LabelOption, MappingDatum, Point } from '../../interface';\nimport { LabelCfg, LabelItem, LabelPointCfg, TextAlign } from './interface';\n\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\n\nimport Labels from '../../component/labels';\nimport Geometry from '../base';\nimport Element from '../element';\n\nexport type GeometryLabelConstructor = new (cfg: any) => GeometryLabel;\n\nfunction avg(arr: number[]) {\n  let sum = 0;\n  each(arr, (value: number) => {\n    sum += value;\n  });\n  return sum / arr.length;\n}\n\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\nexport default class GeometryLabel {\n  /** geometry 实例 */\n  public readonly geometry: Geometry;\n  public labelsRenderer: Labels;\n  /** 默认的布局 */\n  public defaultLayout: string;\n\n  constructor(geometry: Geometry) {\n    this.geometry = geometry;\n  }\n\n  public getLabelItems(mapppingArray: MappingDatum[]): LabelItem[] {\n    const items = [];\n    const labelCfgs = this.getLabelCfgs(mapppingArray);\n    // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const labelCfg = labelCfgs[index];\n      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n        items.push(null);\n        return;\n      }\n\n      const labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n      labelCfg.content = labelContent;\n      const total = labelContent.length;\n      each(labelContent, (content, subIndex) => {\n        if (isNil(content) || content === '') {\n          items.push(null);\n          return;\n        }\n\n        const item = {\n          ...labelCfg,\n          ...this.getLabelPoint(labelCfg, mappingData, subIndex),\n        };\n        if (!item.textAlign) {\n          item.textAlign = this.getLabelAlign(item, subIndex, total);\n        }\n\n        if (item.offset <= 0) {\n          item.labelLine = null;\n        }\n\n        items.push(item);\n      });\n    });\n    return items;\n  }\n\n  public async render(mappingArray: MappingDatum[], isUpdate: boolean = false) {\n    const labelItems = this.getLabelItems(mappingArray);\n    const labelsRenderer = this.getLabelsRenderer();\n    const shapes = this.getGeometryShapes();\n    // 渲染文本\n    await labelsRenderer.render(labelItems, shapes, isUpdate);\n  }\n\n  public clear() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.clear();\n    }\n  }\n\n  public destroy() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.destroy();\n    }\n    this.labelsRenderer = null;\n  }\n\n  // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n  public getCoordinate() {\n    return this.geometry.coordinate;\n  }\n\n  /**\n   * 获取 label 的默认配置\n   */\n  protected getDefaultLabelCfg(offset?: number, position?: string) {\n    const geometry = this.geometry;\n    const { type, theme } = geometry;\n\n    if (\n      type === 'polygon' ||\n      (type === 'interval' && position === 'middle') ||\n      (offset < 0 && !['line', 'point', 'path'].includes(type))\n    ) {\n      // polygon 或者 (interval 且 middle) 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      return get(theme, 'innerLabels', {});\n    }\n\n    return get(theme, 'labels', {});\n  }\n\n  /**\n   * 获取当前 label 的最终配置\n   * @param labelCfg\n   */\n  protected getThemedLabelCfg(labelCfg: LabelCfg) {\n    const geometry = this.geometry;\n    const defaultLabelCfg = this.getDefaultLabelCfg();\n    const { type, theme } = geometry;\n    let themedLabelCfg;\n\n    if (type === 'polygon' || (labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type))) {\n      // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n    } else {\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n    }\n\n    return themedLabelCfg;\n  }\n\n  /**\n   * 设置 label 位置\n   * @param labelPointCfg\n   * @param mappingData\n   * @param index\n   * @param position\n   */\n  protected setLabelPosition(\n    labelPointCfg: LabelPointCfg,\n    mappingData: MappingDatum,\n    index: number,\n    position: string\n  ) {}\n\n  /**\n   * @desc 获取 label offset\n   */\n  protected getLabelOffset(offset: number | string): number {\n    const coordinate = this.getCoordinate();\n    const vector = this.getOffsetVector(offset);\n    return coordinate.isTransposed ? vector[0] : vector[1];\n  }\n\n  /**\n   * 获取每个 label 的偏移量 (矢量)\n   * @param labelCfg\n   * @param index\n   * @param total\n   * @return {Point} offsetPoint\n   */\n  protected getLabelOffsetPoint(labelCfg: LabelCfg, index: number, total: number): Point {\n    const offset = labelCfg.offset;\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const dim = transposed ? 'x' : 'y';\n    const factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n    const offsetPoint = {\n      x: 0,\n      y: 0,\n    };\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[dim] = offset * factor;\n    } else {\n      offsetPoint[dim] = offset * factor * -1;\n    }\n    return offsetPoint;\n  }\n\n  /**\n   * 获取每个 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   * @returns label point\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    const coordinate = this.getCoordinate();\n    const total = labelCfg.content.length;\n\n    function getDimValue(value: number | number[], idx: number, isAvg = false) {\n      let v = value;\n      if (isArray(v)) {\n        if (labelCfg.content.length === 1) {\n          if (isAvg) {\n            v = avg(v);\n          } else {\n            // 如果仅一个 label，多个 y, 取最后一个 y\n            if (v.length <= 2) {\n              v = v[(value as number[]).length - 1];\n            } else {\n              v = avg(v);\n            }\n          }\n        } else {\n          v = v[idx];\n        }\n      }\n      return v;\n    }\n\n    const label = {\n      content: labelCfg.content[index],\n      x: 0,\n      y: 0,\n      start: { x: 0, y: 0 },\n      color: '#fff',\n    };\n    const shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    const isFunnel = shape === 'funnel' || shape === 'pyramid';\n\n    // 多边形场景，多用于地图\n    if (this.geometry.type === 'polygon') {\n      const centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else if (this.geometry.type === 'interval' && !isFunnel) {\n      // 对直方图的label X 方向的位置居中\n      label.x = getDimValue(mappingData.x, index, true);\n      label.y = getDimValue(mappingData.y, index);\n    } else {\n      label.x = getDimValue(mappingData.x, index);\n      label.y = getDimValue(mappingData.y, index);\n    }\n\n    // 处理漏斗图文本位置\n    if (isFunnel) {\n      const nextPoints = get(mappingData, 'nextPoints');\n      const points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(nextPoints[1] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      } else if (shape === 'pyramid') {\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(points[2] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      }\n    }\n\n    if (labelCfg.position) {\n      // 如果 label 支持 position 属性\n      this.setLabelPosition(label, mappingData, index, labelCfg.position);\n    }\n    const offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);\n    label.start = { x: label.x, y: label.y };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = mappingData.color;\n    return label;\n  }\n\n  /**\n   * 获取文本的对齐方式\n   * @param item\n   * @param index\n   * @param total\n   * @returns\n   */\n  protected getLabelAlign(item: LabelItem, index: number, total: number): TextAlign {\n    let align: TextAlign = 'center';\n    const coordinate = this.getCoordinate();\n    if (coordinate.isTransposed) {\n      const offset = item.offset;\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n    return align;\n  }\n\n  /**\n   * 获取每一个 label 的唯一 id\n   * @param mappingData label 对应的图形的绘制数据\n   */\n  protected getLabelId(mappingData: MappingDatum) {\n    const geometry = this.geometry;\n    const type = geometry.type;\n    const xScale = geometry.getXScale();\n    const yScale = geometry.getYScale();\n    const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n\n    let labelId = geometry.getElementId(mappingData);\n    if (type === 'line' || type === 'area') {\n      // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n      labelId += ` ${origin[xScale.field]}`;\n    } else if (type === 'path') {\n      // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n      labelId += ` ${origin[xScale.field]}-${origin[yScale.field]}`;\n    }\n\n    return labelId;\n  }\n\n  // 获取 labels 组件\n  private getLabelsRenderer() {\n    const { labelsContainer, labelOption, canvasRegion, animateOption } = this.geometry;\n    const coordinate = this.geometry.coordinate;\n\n    let labelsRenderer = this.labelsRenderer;\n    if (!labelsRenderer) {\n      labelsRenderer = new Labels({\n        container: labelsContainer,\n        layout: get(labelOption, ['cfg', 'layout'], {\n          type: this.defaultLayout,\n        }),\n      });\n      this.labelsRenderer = labelsRenderer;\n    }\n    labelsRenderer.region = canvasRegion;\n    // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n\n    return labelsRenderer;\n  }\n\n  private getLabelCfgs(mapppingArray: MappingDatum[]): LabelCfg[] {\n    const geometry = this.geometry;\n    const { labelOption, scales, coordinate } = geometry;\n    const { fields, callback, cfg } = labelOption as LabelOption;\n    const labelScales = fields.map((field: string) => {\n      return scales[field];\n    });\n\n    const labelCfgs: LabelCfg[] = [];\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n      const originText = this.getLabelText(origin, labelScales);\n      let callbackCfg;\n      if (callback) {\n        // 当同时配置了 callback 和 cfg 时，以 callback 为准\n        const originValues = fields.map((field: string) => origin[field]);\n        callbackCfg = callback(...originValues);\n        if (isNil(callbackCfg)) {\n          labelCfgs.push(null);\n          return;\n        }\n      }\n\n      let labelCfg = {\n        id: this.getLabelId(mappingData), // 进行 ID 标记\n        elementId: this.geometry.getElementId(mappingData), // label 对应 Element 的 ID\n        data: origin, // 存储原始数据\n        mappingData, // 存储映射后的数据,\n        coordinate, // 坐标系\n        ...cfg,\n        ...callbackCfg,\n      };\n\n      if (isFunction(labelCfg.position)) {\n        labelCfg.position = labelCfg.position(origin, mappingData, index);\n      }\n\n      const offset = this.getLabelOffset(labelCfg.offset || 0);\n      // defaultCfg 需要判断 innerLabels & labels\n      const defaultLabelCfg = this.getDefaultLabelCfg(offset, labelCfg.position);\n      // labelCfg priority: defaultCfg < cfg < callbackCfg\n      labelCfg = deepMix({}, defaultLabelCfg, labelCfg);\n      // 获取最终的 offset\n      labelCfg.offset = this.getLabelOffset(labelCfg.offset || 0);\n\n      const content = labelCfg.content;\n      if (isFunction(content)) {\n        labelCfg.content = content(origin, mappingData, index);\n      } else if (isUndefined(content)) {\n        // 用户未配置 content，则默认为映射的第一个字段的值\n        labelCfg.content = originText[0];\n      }\n\n      labelCfgs.push(labelCfg);\n    });\n\n    return labelCfgs;\n  }\n\n  private getLabelText(origin: Datum, scales: Scale[]) {\n    const labelTexts = [];\n    each(scales, (scale: Scale) => {\n      let value = origin[scale.field];\n      if (isArray(value)) {\n        value = value.map((subVal) => {\n          return scale.getText(subVal);\n        });\n      } else {\n        value = scale.getText(value);\n      }\n\n      if (isNil(value) || value === '') {\n        labelTexts.push(null);\n      } else {\n        labelTexts.push(value);\n      }\n    });\n    return labelTexts;\n  }\n\n  private getOffsetVector(offset: number | string = 0) {\n    const coordinate = this.getCoordinate();\n    let actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    }\n    // 如果 x,y 翻转，则偏移 x，否则偏移 y\n    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);\n  }\n\n  private getGeometryShapes() {\n    const geometry = this.geometry;\n    const shapes = {};\n    each(geometry.elementsMap, (element: Element, id: string) => {\n      shapes[id] = element.shape;\n    });\n    // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n    each(geometry.getOffscreenGroup().getChildren(), (child) => {\n      const id = geometry.getElementId(child.get('origin').mappingData);\n      shapes[id] = child;\n    });\n\n    return shapes;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}