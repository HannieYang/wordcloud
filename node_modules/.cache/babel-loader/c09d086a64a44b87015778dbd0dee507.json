{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { pack } from '../../utils/hierarchy/pack';\nimport { deepAssign, pick } from '../../utils';\nimport { HIERARCHY_DATA_TRANSFORM_PARAMS } from '../../interactions/actions/drill-down';\nimport { resolveAllPadding } from '../../utils/padding';\n/**\n * circle-packing 数据转换\n * @param options\n */\n\nexport function transformData(options) {\n  var data = options.data,\n      hierarchyConfig = options.hierarchyConfig,\n      _a = options.rawFields,\n      rawFields = _a === void 0 ? [] : _a,\n      enableDrillDown = options.enableDrillDown;\n  var nodes = pack(data, __assign(__assign({}, hierarchyConfig), {\n    field: 'value',\n    as: ['x', 'y', 'r']\n  }));\n  var result = [];\n  nodes.forEach(function (node) {\n    var _a;\n\n    var path = node.data.name;\n\n    var ancestorNode = __assign({}, node);\n\n    while (ancestorNode.depth > 1) {\n      path = ((_a = ancestorNode.parent.data) === null || _a === void 0 ? void 0 : _a.name) + \" / \" + path;\n      ancestorNode = ancestorNode.parent;\n    } // 开启下钻，仅加载 depth <= 2 的数据 (加载两层)\n\n\n    if (enableDrillDown && node.depth > 2) {\n      return null;\n    }\n\n    var nodeInfo = deepAssign({}, node.data, __assign(__assign(__assign({}, pick(node.data, rawFields)), {\n      path: path\n    }), node));\n    nodeInfo.ext = hierarchyConfig;\n    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = {\n      hierarchyConfig: hierarchyConfig,\n      rawFields: rawFields,\n      enableDrillDown: enableDrillDown\n    };\n    result.push(nodeInfo);\n  });\n  return result;\n}\n/**\n * 根据传入的 padding 和 现有的 画布大小， 输出针对圆形视图布局需要的 finalPadding 以及 finalSize\n * @param params\n */\n\nexport function resolvePaddingForCircle(padding, appendPadding, containerSize) {\n  var tempPadding = resolveAllPadding([padding, appendPadding]);\n  var top = tempPadding[0],\n      right = tempPadding[1],\n      bottom = tempPadding[2],\n      left = tempPadding[3]; // 没设定，默认是 [0, 0, 0, 0]\n\n  var width = containerSize.width,\n      height = containerSize.height; // 有了 tempPadding 介入以后，计算出coordinate范围宽高的最小值 minSize = circle-packing的直径\n\n  var wSize = width - (left + right);\n  var hSize = height - (top + bottom);\n  var minSize = Math.min(wSize, hSize); // circle-packing的直径\n  // 得到居中后各方向剩余的 padding\n\n  var restWidthPadding = (wSize - minSize) / 2;\n  var restHeightPadding = (hSize - minSize) / 2;\n  var finalTop = top + restHeightPadding;\n  var finalRight = right + restWidthPadding;\n  var finalBottom = bottom + restHeightPadding;\n  var finalLeft = left + restWidthPadding;\n  var finalPadding = [finalTop, finalRight, finalBottom, finalLeft];\n  var finalSize = minSize < 0 ? 0 : minSize; // 防止为负数\n\n  return {\n    finalPadding: finalPadding,\n    finalSize: finalSize\n  };\n}","map":{"version":3,"mappings":"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","names":["pack","deepAssign","pick","HIERARCHY_DATA_TRANSFORM_PARAMS","resolveAllPadding","transformData","options","hierarchyConfig","_a","rawFields","enableDrillDown","nodes","data","__assign","field","as","result","forEach","node","path","name","ancestorNode","depth","parent","nodeInfo","ext","push","resolvePaddingForCircle","padding","appendPadding","containerSize","tempPadding","right","bottom","left","height","wSize","width","hSize","top","minSize","Math","min","restWidthPadding","restHeightPadding","finalTop","finalRight","finalBottom","finalLeft","finalPadding","finalSize"],"sourceRoot":"","sources":["../../../src/plots/circle-packing/utils.ts"],"sourcesContent":["import { Types } from '@antv/g2';\nimport { pack } from '../../utils/hierarchy/pack';\nimport { deepAssign, pick } from '../../utils';\nimport { HIERARCHY_DATA_TRANSFORM_PARAMS } from '../../interactions/actions/drill-down';\nimport { resolveAllPadding } from '../../utils/padding';\nimport { CirclePackingOptions } from './types';\n\ninterface TransformDataOptions {\n  data: CirclePackingOptions['data'];\n  rawFields: CirclePackingOptions['rawFields'];\n  enableDrillDown: boolean;\n  hierarchyConfig: CirclePackingOptions['hierarchyConfig'];\n}\n\n/**\n * circle-packing 数据转换\n * @param options\n */\nexport function transformData(options: TransformDataOptions) {\n  const { data, hierarchyConfig, rawFields = [], enableDrillDown } = options;\n\n  const nodes = pack(data, {\n    ...hierarchyConfig,\n    field: 'value',\n    as: ['x', 'y', 'r'],\n  });\n\n  const result = [];\n  nodes.forEach((node) => {\n    let path = node.data.name;\n    let ancestorNode = { ...node };\n    while (ancestorNode.depth > 1) {\n      path = `${ancestorNode.parent.data?.name} / ${path}`;\n      ancestorNode = ancestorNode.parent;\n    }\n\n    // 开启下钻，仅加载 depth <= 2 的数据 (加载两层)\n    if (enableDrillDown && node.depth > 2) {\n      return null;\n    }\n\n    const nodeInfo = deepAssign({}, node.data, {\n      ...pick(node.data, rawFields),\n      path,\n      // 以下字段，必备: x, y, r, name, depth, height\n      ...node,\n    });\n\n    nodeInfo.ext = hierarchyConfig;\n    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, rawFields, enableDrillDown };\n\n    result.push(nodeInfo);\n  });\n\n  return result;\n}\n\n/**\n * 根据传入的 padding 和 现有的 画布大小， 输出针对圆形视图布局需要的 finalPadding 以及 finalSize\n * @param params\n */\nexport function resolvePaddingForCircle(\n  padding: Types.ViewPadding,\n  appendPadding: Types.ViewAppendPadding,\n  containerSize: { width: number; height: number }\n) {\n  const tempPadding = resolveAllPadding([padding, appendPadding]);\n  const [top, right, bottom, left] = tempPadding; // 没设定，默认是 [0, 0, 0, 0]\n  const { width, height } = containerSize;\n\n  // 有了 tempPadding 介入以后，计算出coordinate范围宽高的最小值 minSize = circle-packing的直径\n  const wSize = width - (left + right);\n  const hSize = height - (top + bottom);\n  const minSize = Math.min(wSize, hSize); // circle-packing的直径\n\n  // 得到居中后各方向剩余的 padding\n  const restWidthPadding = (wSize - minSize) / 2;\n  const restHeightPadding = (hSize - minSize) / 2;\n\n  const finalTop = top + restHeightPadding;\n  const finalRight = right + restWidthPadding;\n  const finalBottom = bottom + restHeightPadding;\n  const finalLeft = left + restWidthPadding;\n\n  const finalPadding = [finalTop, finalRight, finalBottom, finalLeft];\n  const finalSize = minSize < 0 ? 0 : minSize; // 防止为负数\n\n  return { finalPadding, finalSize };\n}\n"]},"metadata":{},"sourceType":"module"}