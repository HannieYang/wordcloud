{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { __assign, __read, __spreadArray, __values } from \"tslib\";\nimport { contains, filter, find, isArray, isEmpty, isFunction, isNil, isNumberEqual, isObject, memoize, get, values } from '@antv/util';\nimport { FIELD_ORIGIN, GROUP_ATTRS } from '../constant';\nimport { getName, inferScaleType } from './scale';\n\nfunction snapEqual(v1, v2, scale) {\n  var value1 = scale.translate(v1);\n  var value2 = scale.translate(v2);\n  return isNumberEqual(value1, value2);\n}\n\nfunction getXValueByPoint(point, geometry) {\n  var coordinate = geometry.coordinate;\n  var xScale = geometry.getXScale();\n  var range = xScale.range;\n  var rangeMax = range[range.length - 1];\n  var rangeMin = range[0];\n  var invertPoint = coordinate.invert(point);\n  var xValue = invertPoint.x;\n\n  if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {\n    xValue = rangeMin; // 极坐标下，scale 的 range 被做过特殊处理\n  }\n\n  return xScale.translate(xScale.invert(xValue));\n}\n\nfunction filterYValue(data, point, geometry) {\n  var coordinate = geometry.coordinate;\n  var yScale = geometry.getYScale();\n  var yField = yScale.field;\n  var invertPoint = coordinate.invert(point);\n  var yValue = yScale.invert(invertPoint.y);\n  var result = find(data, function (obj) {\n    var originData = obj[FIELD_ORIGIN];\n    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;\n  });\n  return result || data[data.length - 1];\n}\n\nvar getXDistance = memoize(function (scale) {\n  if (scale.isCategory) {\n    return 1;\n  }\n\n  var scaleValues = scale.values; // values 是无序的\n\n  var length = scaleValues.length;\n  var min = scale.translate(scaleValues[0]);\n  var max = min;\n\n  for (var index = 0; index < length; index++) {\n    var value = scaleValues[index]; // 时间类型需要 translate\n\n    var numericValue = scale.translate(value);\n\n    if (numericValue < min) {\n      min = numericValue;\n    }\n\n    if (numericValue > max) {\n      max = numericValue;\n    }\n  }\n\n  return (max - min) / (length - 1);\n});\n/**\n * 获得 tooltip 的 title\n * @param originData\n * @param geometry\n * @param title\n */\n\nfunction getTooltipTitle(originData, geometry, title) {\n  var positionAttr = geometry.getAttribute('position');\n  var fields = positionAttr.getFields();\n  var scales = geometry.scales;\n  var titleField = isFunction(title) || !title ? fields[0] : title;\n  var titleScale = scales[titleField]; // 如果创建了该字段对应的 scale，则通过 scale.getText() 方式取值，因为用户可能对数据进行了格式化\n  // 如果没有对应的 scale，则从原始数据中取值，如果原始数据中仍不存在，则直接放回 title 值\n\n  var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;\n  return isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;\n}\n\nfunction getAttributesForLegend(geometry) {\n  var attributes = values(geometry.attributes);\n  return filter(attributes, function (attribute) {\n    return contains(GROUP_ATTRS, attribute.type);\n  });\n}\n\nfunction getTooltipValueScale(geometry) {\n  var e_1, _a;\n\n  var attributes = getAttributesForLegend(geometry);\n  var scale;\n\n  try {\n    for (var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {\n      var attribute = attributes_1_1.value;\n      var tmpScale = attribute.getScale(attribute.type);\n\n      if (tmpScale && tmpScale.isLinear) {\n        var tmpScaleDef = get(geometry.scaleDefs, tmpScale.field);\n        var inferedScaleType = inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry.type);\n\n        if (inferedScaleType !== 'cat') {\n          // 如果指定字段是非 position 的，同时是连续的\n          scale = tmpScale;\n          break;\n        }\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (attributes_1_1 && !attributes_1_1.done && (_a = attributes_1.return)) _a.call(attributes_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  var xScale = geometry.getXScale();\n  var yScale = geometry.getYScale();\n  return scale || yScale || xScale;\n}\n\nfunction getTooltipValue(originData, valueScale) {\n  var field = valueScale.field;\n  var value = originData[field];\n\n  if (isArray(value)) {\n    var texts = value.map(function (eachValue) {\n      return valueScale.getText(eachValue);\n    });\n    return texts.join('-');\n  }\n\n  return valueScale.getText(value);\n} // 根据原始数据获取 tooltip item 中 name 值\n\n\nfunction getTooltipName(originData, geometry) {\n  var nameScale;\n  var groupScales = geometry.getGroupScales();\n\n  if (groupScales.length) {\n    // 如果存在分组类型，取第一个分组类型\n    nameScale = groupScales[0];\n  }\n\n  if (nameScale) {\n    var field = nameScale.field;\n    return nameScale.getText(originData[field]);\n  }\n\n  var valueScale = getTooltipValueScale(geometry);\n  return getName(valueScale);\n}\n/**\n * @ignore\n * Finds data from geometry by point\n * @param point canvas point\n * @param data an item of geometry.dataArray\n * @param geometry\n * @returns\n */\n\n\nexport function findDataByPoint(point, data, geometry) {\n  if (data.length === 0) {\n    return null;\n  }\n\n  var geometryType = geometry.type;\n  var xScale = geometry.getXScale();\n  var yScale = geometry.getYScale();\n  var xField = xScale.field;\n  var yField = yScale.field;\n  var rst = null; // 热力图采用最小逼近策略查找 point 击中的数据\n\n  if (geometryType === 'heatmap' || geometryType === 'point') {\n    // 将 point 画布坐标转换为原始数据值\n    var coordinate = geometry.coordinate;\n    var invertPoint = coordinate.invert(point); // 转换成归一化的数据\n\n    var x = xScale.invert(invertPoint.x); // 转换为原始值\n\n    var y = yScale.invert(invertPoint.y); // 转换为原始值\n\n    var min = Infinity;\n\n    for (var index = 0; index < data.length; index++) {\n      var obj = data[index];\n      var originData = obj[FIELD_ORIGIN];\n      var range = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);\n\n      if (range < min) {\n        min = range;\n        rst = obj;\n      }\n    }\n\n    return rst;\n  } // 其他 Geometry 类型按照 x 字段数据进行查找\n\n\n  var first = data[0];\n  var last = data[data.length - 1];\n  var xValue = getXValueByPoint(point, geometry);\n  var firstXValue = first[FIELD_ORIGIN][xField];\n  var firstYValue = first[FIELD_ORIGIN][yField];\n  var lastXValue = last[FIELD_ORIGIN][xField];\n  var isYArray = yScale.isLinear && isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况\n  // 如果 x 的值是数组\n\n  if (isArray(firstXValue)) {\n    for (var index = 0; index < data.length; index++) {\n      var record = data[index];\n      var originData = record[FIELD_ORIGIN]; // xValue 在 originData[xField] 的数值区间内\n\n      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {\n        if (isYArray) {\n          // 层叠直方图场景，x 和 y 都是数组区间\n          if (!isArray(rst)) {\n            rst = [];\n          }\n\n          rst.push(record);\n        } else {\n          rst = record;\n          break;\n        }\n      }\n    }\n\n    if (isArray(rst)) {\n      rst = filterYValue(rst, point, geometry);\n    }\n  } else {\n    var next = void 0;\n\n    if (!xScale.isLinear && xScale.type !== 'timeCat') {\n      // x 轴对应的数据为非线性以及非时间类型的数据采用遍历查找\n      for (var index = 0; index < data.length; index++) {\n        var record = data[index];\n        var originData = record[FIELD_ORIGIN];\n\n        if (snapEqual(originData[xField], xValue, xScale)) {\n          if (isYArray) {\n            if (!isArray(rst)) {\n              rst = [];\n            }\n\n            rst.push(record);\n          } else {\n            rst = record;\n            break;\n          }\n        } else if (xScale.translate(originData[xField]) <= xValue) {\n          last = record;\n          next = data[index + 1];\n        }\n      }\n\n      if (isArray(rst)) {\n        rst = filterYValue(rst, point, geometry);\n      }\n    } else {\n      // x 轴对应的数据为线性以及时间类型，进行二分查找，性能更好\n      if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {\n        // 不在数据范围内\n        return null;\n      }\n\n      var firstIdx = 0;\n      var lastIdx = data.length - 1;\n      var middleIdx = void 0;\n\n      while (firstIdx <= lastIdx) {\n        middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n        var item = data[middleIdx][FIELD_ORIGIN][xField];\n\n        if (snapEqual(item, xValue, xScale)) {\n          return data[middleIdx];\n        }\n\n        if (xScale.translate(item) <= xScale.translate(xValue)) {\n          firstIdx = middleIdx + 1;\n          last = data[middleIdx];\n          next = data[middleIdx + 1];\n        } else {\n          if (lastIdx === 0) {\n            last = data[0];\n          }\n\n          lastIdx = middleIdx - 1;\n        }\n      }\n    }\n\n    if (last && next) {\n      // 计算最逼近的\n      if (Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {\n        last = next;\n      }\n    }\n  }\n\n  var distance = getXDistance(geometry.getXScale()); // 每个分类间的平均间距\n\n  if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {\n    rst = last;\n  }\n\n  return rst;\n}\n/**\n * @ignore\n * Gets tooltip items\n * @param data\n * @param geometry\n * @param [title]\n * @returns\n */\n\nexport function getTooltipItems(data, geometry, title, showNil) {\n  var e_2, _a;\n\n  if (title === void 0) {\n    title = '';\n  }\n\n  if (showNil === void 0) {\n    showNil = false;\n  }\n\n  var originData = data[FIELD_ORIGIN];\n  var tooltipTitle = getTooltipTitle(originData, geometry, title);\n  var tooltipOption = geometry.tooltipOption;\n  var defaultColor = geometry.theme.defaultColor;\n  var items = [];\n  var name;\n  var value;\n\n  function addItem(itemName, itemValue) {\n    if (showNil || !isNil(itemValue) && itemValue !== '') {\n      // 值为 null的时候，忽视\n      var item = {\n        title: tooltipTitle,\n        data: originData,\n        mappingData: data,\n        name: itemName,\n        value: itemValue,\n        color: data.color || defaultColor,\n        marker: true\n      };\n      items.push(item);\n    }\n  }\n\n  if (isObject(tooltipOption)) {\n    var fields = tooltipOption.fields,\n        callback = tooltipOption.callback;\n\n    if (callback) {\n      // 用户定义了回调函数\n      var callbackParams = fields.map(function (field) {\n        return data[FIELD_ORIGIN][field];\n      });\n      var cfg = callback.apply(void 0, __spreadArray([], __read(callbackParams), false));\n\n      var itemCfg = __assign({\n        data: data[FIELD_ORIGIN],\n        mappingData: data,\n        title: tooltipTitle,\n        color: data.color || defaultColor,\n        marker: true\n      }, cfg);\n\n      items.push(itemCfg);\n    } else {\n      var scales = geometry.scales;\n\n      try {\n        for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {\n          var field = fields_1_1.value;\n\n          if (!isNil(originData[field])) {\n            // 字段数据为null, undefined 时不显示\n            var scale = scales[field];\n            name = getName(scale);\n            value = scale.getText(originData[field]);\n            addItem(name, value);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  } else {\n    var valueScale = getTooltipValueScale(geometry); // 字段数据为null ,undefined时不显示\n\n    value = getTooltipValue(originData, valueScale);\n    name = getTooltipName(originData, geometry);\n    addItem(name, value);\n  }\n\n  return items;\n}\n\nfunction getTooltipItemsByFindData(geometry, point, title, tooltipCfg) {\n  var e_3, _a;\n\n  var showNil = tooltipCfg.showNil;\n  var result = [];\n  var dataArray = geometry.dataArray;\n\n  if (!isEmpty(dataArray)) {\n    geometry.sort(dataArray); // 先进行排序，便于 tooltip 查找\n\n    try {\n      for (var dataArray_1 = __values(dataArray), dataArray_1_1 = dataArray_1.next(); !dataArray_1_1.done; dataArray_1_1 = dataArray_1.next()) {\n        var data = dataArray_1_1.value;\n        var record = findDataByPoint(point, data, geometry);\n\n        if (record) {\n          var elementId = geometry.getElementId(record);\n          var element = geometry.elementsMap[elementId];\n\n          if (geometry.type === 'heatmap' || element.visible) {\n            // Heatmap 没有 Element\n            // 如果图形元素隐藏了，怎不再 tooltip 上展示相关数据\n            var items = getTooltipItems(record, geometry, title, showNil);\n\n            if (items.length) {\n              result.push(items);\n            }\n          }\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (dataArray_1_1 && !dataArray_1_1.done && (_a = dataArray_1.return)) _a.call(dataArray_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getTooltipItemsByHitShape(geometry, point, title, tooltipCfg) {\n  var showNil = tooltipCfg.showNil;\n  var result = [];\n  var container = geometry.container;\n  var shape = container.getShape(point.x, point.y);\n\n  if (shape && shape.get('visible') && shape.get('origin')) {\n    var mappingData = shape.get('origin').mappingData;\n    var items = getTooltipItems(mappingData, geometry, title, showNil);\n\n    if (items.length) {\n      result.push(items);\n    }\n  }\n\n  return result;\n}\n/**\n * 不进行递归查找\n */\n\n\nexport function findItemsFromView(view, point, tooltipCfg) {\n  var e_4, _a;\n\n  var result = []; // 先从 view 本身查找\n\n  var geometries = view.geometries;\n  var shared = tooltipCfg.shared,\n      title = tooltipCfg.title,\n      reversed = tooltipCfg.reversed;\n\n  try {\n    for (var geometries_1 = __values(geometries), geometries_1_1 = geometries_1.next(); !geometries_1_1.done; geometries_1_1 = geometries_1.next()) {\n      var geometry = geometries_1_1.value;\n\n      if (geometry.visible && geometry.tooltipOption !== false) {\n        // geometry 可见同时未关闭 tooltip\n        var geometryType = geometry.type;\n        var tooltipItems = void 0;\n\n        if (['point', 'edge', 'polygon'].includes(geometryType)) {\n          // 始终通过图形拾取\n          tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n        } else if (['area', 'line', 'path', 'heatmap'].includes(geometryType)) {\n          // 如果是 'area', 'line', 'path'，始终通过数据查找方法查找 tooltip\n          tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n        } else {\n          if (shared !== false) {\n            tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n          } else {\n            tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n          }\n        }\n\n        if (tooltipItems.length) {\n          if (reversed) {\n            tooltipItems.reverse();\n          } // geometry 有可能会有多个 item，因为用户可以设置 geometry.tooltip('x*y*z')\n\n\n          result.push(tooltipItems);\n        }\n      }\n    }\n  } catch (e_4_1) {\n    e_4 = {\n      error: e_4_1\n    };\n  } finally {\n    try {\n      if (geometries_1_1 && !geometries_1_1.done && (_a = geometries_1.return)) _a.call(geometries_1);\n    } finally {\n      if (e_4) throw e_4.error;\n    }\n  }\n\n  return result;\n}\nexport function findItemsFromViewRecurisive(view, point, tooltipCfg) {\n  var e_5, _a;\n\n  var result = findItemsFromView(view, point, tooltipCfg);\n\n  try {\n    // 递归查找，并合并结果\n    for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var childView = _c.value;\n      result = result.concat(findItemsFromView(childView, point, tooltipCfg));\n    }\n  } catch (e_5_1) {\n    e_5 = {\n      error: e_5_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_5) throw e_5.error;\n    }\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"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","names":["contains","filter","find","isArray","isEmpty","isFunction","isNil","isNumberEqual","isObject","memoize","get","values","FIELD_ORIGIN","GROUP_ATTRS","getName","inferScaleType","snapEqual","v1","v2","scale","value1","translate","value2","getXValueByPoint","point","geometry","coordinate","xScale","getXScale","range","rangeMax","length","rangeMin","invertPoint","invert","xValue","x","isPolar","filterYValue","data","yScale","getYScale","yField","field","yValue","y","result","obj","originData","getXDistance","isCategory","scaleValues","min","max","index","value","numericValue","getTooltipTitle","title","positionAttr","getAttribute","fields","getFields","scales","titleField","titleScale","tooltipTitle","getText","getAttributesForLegend","attributes","attribute","type","getTooltipValueScale","attributes_1_1","tmpScale","getScale","isLinear","tmpScaleDef","scaleDefs","inferedScaleType","getTooltipValue","valueScale","texts","map","eachValue","join","getTooltipName","nameScale","groupScales","getGroupScales","findDataByPoint","geometryType","xField","rst","Infinity","Math","first","last","firstXValue","firstYValue","lastXValue","isYArray","record","push","next","firstIdx","lastIdx","middleIdx","floor","item","abs","distance","getTooltipItems","showNil","tooltipOption","theme","defaultColor","items","name","addItem","itemName","itemValue","mappingData","color","marker","callback","callbackParams","cfg","__spreadArray","itemCfg","fields_1_1","getTooltipItemsByFindData","tooltipCfg","dataArray","sort","dataArray_1_1","elementId","getElementId","element","elementsMap","visible","getTooltipItemsByHitShape","container","shape","getShape","findItemsFromView","view","geometries","reversed","geometries_1_1","tooltipItems","includes","shared","reverse","findItemsFromViewRecurisive","views","_c","childView","concat"],"sourceRoot":"","sources":["../../src/util/tooltip.ts"],"sourcesContent":["import {\n  contains,\n  filter,\n  find,\n  isArray,\n  isEmpty,\n  isFunction,\n  isNil,\n  isNumberEqual,\n  isObject,\n  memoize,\n  get,\n  values,\n} from '@antv/util';\nimport { View } from '../chart';\nimport { FIELD_ORIGIN, GROUP_ATTRS } from '../constant';\nimport { Attribute, Scale } from '../dependents';\nimport Geometry from '../geometry/base';\nimport { Data, Datum, MappingDatum, Point, TooltipCfg, TooltipTitle } from '../interface';\nimport { getName, inferScaleType } from './scale';\n\nfunction snapEqual(v1: any, v2: any, scale: Scale) {\n  const value1 = scale.translate(v1);\n  const value2 = scale.translate(v2);\n\n  return isNumberEqual(value1, value2);\n}\n\nfunction getXValueByPoint(point: Point, geometry: Geometry): number {\n  const coordinate = geometry.coordinate;\n  const xScale = geometry.getXScale();\n  const range = xScale.range;\n  const rangeMax = range[range.length - 1];\n  const rangeMin = range[0];\n\n  const invertPoint = coordinate.invert(point);\n\n  let xValue = invertPoint.x;\n  if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {\n    xValue = rangeMin; // 极坐标下，scale 的 range 被做过特殊处理\n  }\n  return xScale.translate(xScale.invert(xValue));\n}\n\nfunction filterYValue(data: Data, point: Point, geometry: Geometry) {\n  const coordinate = geometry.coordinate;\n  const yScale = geometry.getYScale();\n  const yField = yScale.field;\n  const invertPoint = coordinate.invert(point);\n  const yValue = yScale.invert(invertPoint.y);\n\n  const result = find(data, (obj: Datum) => {\n    const originData = obj[FIELD_ORIGIN];\n    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;\n  });\n  return result || data[data.length - 1];\n}\n\nconst getXDistance = memoize((scale: Scale) => {\n  if (scale.isCategory) {\n    return 1;\n  }\n  const scaleValues = scale.values; // values 是无序的\n  const length = scaleValues.length;\n  let min = scale.translate(scaleValues[0]);\n  let max = min;\n\n  for (let index = 0; index < length; index++) {\n    const value = scaleValues[index];\n    // 时间类型需要 translate\n    const numericValue = scale.translate(value);\n    if (numericValue < min) {\n      min = numericValue;\n    }\n    if (numericValue > max) {\n      max = numericValue;\n    }\n  }\n  return (max - min) / (length - 1);\n});\n\n/**\n * 获得 tooltip 的 title\n * @param originData\n * @param geometry\n * @param title\n */\nfunction getTooltipTitle(originData: Datum, geometry: Geometry, title: TooltipTitle): string {\n  const positionAttr = geometry.getAttribute('position');\n  const fields = positionAttr.getFields();\n  const scales = geometry.scales;\n\n  const titleField = isFunction(title) || !title ? fields[0] : title;\n  const titleScale = scales[titleField];\n\n  // 如果创建了该字段对应的 scale，则通过 scale.getText() 方式取值，因为用户可能对数据进行了格式化\n  // 如果没有对应的 scale，则从原始数据中取值，如果原始数据中仍不存在，则直接放回 title 值\n  const tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;\n\n  return isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;\n}\n\nfunction getAttributesForLegend(geometry: Geometry) {\n  const attributes = values(geometry.attributes);\n  return filter(attributes, (attribute: Attribute) => contains(GROUP_ATTRS, attribute.type));\n}\n\nfunction getTooltipValueScale(geometry: Geometry) {\n  const attributes = getAttributesForLegend(geometry);\n  let scale;\n  for (const attribute of attributes) {\n    const tmpScale = attribute.getScale(attribute.type);\n    if (tmpScale && tmpScale.isLinear) {\n      const tmpScaleDef = get(geometry.scaleDefs, tmpScale.field);\n      const inferedScaleType = inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry.type);\n      if (inferedScaleType !== 'cat') {\n        // 如果指定字段是非 position 的，同时是连续的\n        scale = tmpScale;\n        break;\n      }\n    }\n  }\n\n  const xScale = geometry.getXScale();\n  const yScale = geometry.getYScale();\n\n  return scale || yScale || xScale;\n}\n\nfunction getTooltipValue(originData: Datum, valueScale: Scale) {\n  const field = valueScale.field;\n  const value = originData[field];\n\n  if (isArray(value)) {\n    const texts = value.map((eachValue) => {\n      return valueScale.getText(eachValue);\n    });\n    return texts.join('-');\n  }\n  return valueScale.getText(value);\n}\n\n// 根据原始数据获取 tooltip item 中 name 值\nfunction getTooltipName(originData: Datum, geometry: Geometry) {\n  let nameScale: Scale;\n  const groupScales = geometry.getGroupScales();\n  if (groupScales.length) {\n    // 如果存在分组类型，取第一个分组类型\n    nameScale = groupScales[0];\n  }\n  if (nameScale) {\n    const field = nameScale.field;\n    return nameScale.getText(originData[field]);\n  }\n\n  const valueScale = getTooltipValueScale(geometry);\n  return getName(valueScale);\n}\n\n/**\n * @ignore\n * Finds data from geometry by point\n * @param point canvas point\n * @param data an item of geometry.dataArray\n * @param geometry\n * @returns\n */\nexport function findDataByPoint(point: Point, data: MappingDatum[], geometry: Geometry) {\n  if (data.length === 0) {\n    return null;\n  }\n\n  const geometryType = geometry.type;\n  const xScale = geometry.getXScale();\n  const yScale = geometry.getYScale();\n\n  const xField = xScale.field;\n  const yField = yScale.field;\n\n  let rst = null;\n\n  // 热力图采用最小逼近策略查找 point 击中的数据\n  if (geometryType === 'heatmap' || geometryType === 'point') {\n    // 将 point 画布坐标转换为原始数据值\n    const coordinate = geometry.coordinate;\n    const invertPoint = coordinate.invert(point); // 转换成归一化的数据\n    const x = xScale.invert(invertPoint.x); // 转换为原始值\n    const y = yScale.invert(invertPoint.y); // 转换为原始值\n\n    let min = Infinity;\n    for (let index = 0; index < data.length; index++) {\n      const obj = data[index];\n      const originData = obj[FIELD_ORIGIN];\n      const range = (originData[xField] - x) ** 2 + (originData[yField] - y) ** 2;\n      if (range < min) {\n        min = range;\n        rst = obj;\n      }\n    }\n\n    return rst;\n  }\n\n  // 其他 Geometry 类型按照 x 字段数据进行查找\n  const first = data[0];\n  let last = data[data.length - 1];\n  const xValue = getXValueByPoint(point, geometry);\n  const firstXValue = first[FIELD_ORIGIN][xField];\n  const firstYValue = first[FIELD_ORIGIN][yField];\n  const lastXValue = last[FIELD_ORIGIN][xField];\n  const isYArray = yScale.isLinear && isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况\n\n  // 如果 x 的值是数组\n  if (isArray(firstXValue)) {\n    for (let index = 0; index < data.length; index++) {\n      const record = data[index];\n      const originData = record[FIELD_ORIGIN];\n      // xValue 在 originData[xField] 的数值区间内\n      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {\n        if (isYArray) {\n          // 层叠直方图场景，x 和 y 都是数组区间\n          if (!isArray(rst)) {\n            rst = [];\n          }\n          rst.push(record);\n        } else {\n          rst = record;\n          break;\n        }\n      }\n    }\n    if (isArray(rst)) {\n      rst = filterYValue(rst, point, geometry);\n    }\n  } else {\n    let next;\n    if (!xScale.isLinear && xScale.type !== 'timeCat') {\n      // x 轴对应的数据为非线性以及非时间类型的数据采用遍历查找\n      for (let index = 0; index < data.length; index++) {\n        const record = data[index];\n        const originData = record[FIELD_ORIGIN];\n        if (snapEqual(originData[xField], xValue, xScale)) {\n          if (isYArray) {\n            if (!isArray(rst)) {\n              rst = [];\n            }\n            rst.push(record);\n          } else {\n            rst = record;\n            break;\n          }\n        } else if (xScale.translate(originData[xField]) <= xValue) {\n          last = record;\n          next = data[index + 1];\n        }\n      }\n\n      if (isArray(rst)) {\n        rst = filterYValue(rst, point, geometry);\n      }\n    } else {\n      // x 轴对应的数据为线性以及时间类型，进行二分查找，性能更好\n      if (\n        (xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) &&\n        (xValue > xScale.max || xValue < xScale.min)\n      ) {\n        // 不在数据范围内\n        return null;\n      }\n\n      let firstIdx = 0;\n      let lastIdx = data.length - 1;\n      let middleIdx;\n      while (firstIdx <= lastIdx) {\n        middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n        const item = data[middleIdx][FIELD_ORIGIN][xField];\n        if (snapEqual(item, xValue, xScale)) {\n          return data[middleIdx];\n        }\n\n        if (xScale.translate(item) <= xScale.translate(xValue)) {\n          firstIdx = middleIdx + 1;\n          last = data[middleIdx];\n          next = data[middleIdx + 1];\n        } else {\n          if (lastIdx === 0) {\n            last = data[0];\n          }\n          lastIdx = middleIdx - 1;\n        }\n      }\n    }\n\n    if (last && next) {\n      // 计算最逼近的\n      if (\n        Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) >\n        Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)\n      ) {\n        last = next;\n      }\n    }\n  }\n\n  const distance = getXDistance(geometry.getXScale()); // 每个分类间的平均间距\n  if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {\n    rst = last;\n  }\n\n  return rst;\n}\n\n/**\n * @ignore\n * Gets tooltip items\n * @param data\n * @param geometry\n * @param [title]\n * @returns\n */\nexport function getTooltipItems(\n  data: MappingDatum,\n  geometry: Geometry,\n  title: TooltipTitle = '',\n  showNil: boolean = false\n) {\n  const originData = data[FIELD_ORIGIN];\n  const tooltipTitle = getTooltipTitle(originData, geometry, title);\n  const tooltipOption = geometry.tooltipOption;\n  const { defaultColor } = geometry.theme;\n  const items = [];\n  let name;\n  let value;\n\n  function addItem(itemName, itemValue) {\n    if (showNil || (!isNil(itemValue) && itemValue !== '')) {\n      // 值为 null的时候，忽视\n      const item = {\n        title: tooltipTitle,\n        data: originData, // 原始数据\n        mappingData: data, // 映射后的数据\n        name: itemName,\n        value: itemValue,\n        color: data.color || defaultColor,\n        marker: true,\n      };\n\n      items.push(item);\n    }\n  }\n\n  if (isObject(tooltipOption)) {\n    const { fields, callback } = tooltipOption;\n    if (callback) {\n      // 用户定义了回调函数\n      const callbackParams = fields.map((field: string) => {\n        return data[FIELD_ORIGIN][field];\n      });\n      const cfg = callback(...callbackParams);\n      const itemCfg = {\n        data: data[FIELD_ORIGIN], // 原始数据\n        mappingData: data, // 映射后的数据\n        title: tooltipTitle,\n        color: data.color || defaultColor,\n        marker: true, // 默认展示 marker\n        ...cfg,\n      };\n\n      items.push(itemCfg);\n    } else {\n      const scales = geometry.scales;\n      for (const field of fields) {\n        if (!isNil(originData[field])) {\n          // 字段数据为null, undefined 时不显示\n          const scale = scales[field];\n          name = getName(scale);\n          value = scale.getText(originData[field]);\n          addItem(name, value);\n        }\n      }\n    }\n  } else {\n    const valueScale = getTooltipValueScale(geometry);\n    // 字段数据为null ,undefined时不显示\n    value = getTooltipValue(originData, valueScale);\n    name = getTooltipName(originData, geometry);\n    addItem(name, value);\n  }\n  return items;\n}\n\nfunction getTooltipItemsByFindData(geometry: Geometry, point, title, tooltipCfg: TooltipCfg) {\n  const { showNil } = tooltipCfg;\n  const result = [];\n  const dataArray = geometry.dataArray;\n  if (!isEmpty(dataArray)) {\n    geometry.sort(dataArray); // 先进行排序，便于 tooltip 查找\n    for (const data of dataArray) {\n      const record = findDataByPoint(point, data, geometry);\n      if (record) {\n        const elementId = geometry.getElementId(record);\n        const element = geometry.elementsMap[elementId];\n        if (geometry.type === 'heatmap' || element.visible) {\n          // Heatmap 没有 Element\n          // 如果图形元素隐藏了，怎不再 tooltip 上展示相关数据\n          const items = getTooltipItems(record, geometry, title, showNil);\n          if (items.length) {\n            result.push(items);\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getTooltipItemsByHitShape(geometry, point, title, tooltipCfg: TooltipCfg) {\n  const { showNil } = tooltipCfg;\n  const result = [];\n  const container = geometry.container;\n  const shape = container.getShape(point.x, point.y);\n  if (shape && shape.get('visible') && shape.get('origin')) {\n    const mappingData = shape.get('origin').mappingData;\n    const items = getTooltipItems(mappingData, geometry, title, showNil);\n    if (items.length) {\n      result.push(items);\n    }\n  }\n\n  return result;\n}\n\n/**\n * 不进行递归查找\n */\nexport function findItemsFromView(view: View, point: Point, tooltipCfg: TooltipCfg) {\n  const result = [];\n  // 先从 view 本身查找\n  const geometries = view.geometries;\n  const { shared, title, reversed } = tooltipCfg;\n  for (const geometry of geometries) {\n    if (geometry.visible && geometry.tooltipOption !== false) {\n      // geometry 可见同时未关闭 tooltip\n      const geometryType = geometry.type;\n      let tooltipItems;\n      if (['point', 'edge', 'polygon'].includes(geometryType)) {\n        // 始终通过图形拾取\n        tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n      } else if (['area', 'line', 'path', 'heatmap'].includes(geometryType)) {\n        // 如果是 'area', 'line', 'path'，始终通过数据查找方法查找 tooltip\n        tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n      } else {\n        if (shared !== false) {\n          tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n        } else {\n          tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n        }\n      }\n      if (tooltipItems.length) {\n        if (reversed) {\n          tooltipItems.reverse();\n        }\n        // geometry 有可能会有多个 item，因为用户可以设置 geometry.tooltip('x*y*z')\n        result.push(tooltipItems);\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function findItemsFromViewRecurisive(view: View, point: Point, tooltipCfg: TooltipCfg) {\n  let result = findItemsFromView(view, point, tooltipCfg);\n\n  // 递归查找，并合并结果\n  for (const childView of view.views) {\n    result = result.concat(findItemsFromView(childView, point, tooltipCfg));\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}