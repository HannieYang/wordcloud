{"ast":null,"code":"import { isArray } from '@antv/util';\nimport { getSplinePath } from './path';\n\nfunction isValueEmpty(value) {\n  if (value) {\n    return false;\n  }\n\n  return value === null || value === undefined || isNaN(value);\n}\n\nfunction isYNil(point) {\n  if (isArray(point)) {\n    // 特殊处理 area 的关键点数据，其关键点结构为 [{x: 0, y: 1}, {x: 0, y: 2}]\n    return isValueEmpty(point[1].y);\n  }\n\n  var value = point.y;\n  return isArray(value) ? isValueEmpty(value[0]) : isValueEmpty(value);\n}\n/**\n * @ignore\n * 分割数据，用于处理在一组点数据中，y 对应的数值存在 null/undefined/NaN 的情况\n * 应用于折线图、区域图以及路径图\n *\n * ```typescript\n * // return [[{x: 1, y: 2}, {x: 3, y: 3}]]\n * getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], true);\n * // return [[{x: 1, y: 2}], [{x: 3, y: 3}]]\n * getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], false);\n * // return [[[{ x: 1, y: 10 }, { x: 2, y: 2 }], [{ x: 9, y: 34 }, { x: 1, y: 1 }]]]\n * getPathPoints([\n *   [{ x: 1, y: 10 }, { x: 2, y: 2 }],\n *   [{ x: 4, y: 2 }, { x: 8, y: NaN }],\n *   [{ x: 9, y: 34 }, { x: 1, y: 1 }],\n * ], true);\n * ```\n *\n * @param points 要进行处理点集合\n * @param connectNulls 是否连接空值数据\n * @param showSinglePoint 是否展示孤立点\n * @returns 返回处理后的点集合\n */\n\n\nexport function getPathPoints(points, connectNulls, showSinglePoint) {\n  if (connectNulls === void 0) {\n    connectNulls = false;\n  }\n\n  if (showSinglePoint === void 0) {\n    showSinglePoint = true;\n  }\n\n  if (!points.length || points.length === 1 && !showSinglePoint) {\n    // 空或者只有一个点并配置不展示时\n    return [];\n  }\n\n  if (connectNulls) {\n    // 即 y 值为空的场景\n    var filtered = [];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var point = points[i];\n\n      if (!isYNil(point)) {\n        filtered.push(point);\n      }\n    }\n\n    return [filtered];\n  }\n\n  var result = [];\n  var tmp = [];\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isYNil(point)) {\n      if (tmp.length) {\n        if (!(tmp.length === 1 && !showSinglePoint)) {\n          // 如果前段数据只有一个字段并且不需要展示时则不加入\n          result.push(tmp);\n        }\n\n        tmp = [];\n      }\n    } else {\n      tmp.push(point);\n    }\n  }\n\n  if (tmp.length) {\n    result.push(tmp);\n  }\n\n  return result;\n}\n/**\n * 获取小提琴图的边界 path\n * @param points\n * @returns\n */\n\nexport function getViolinPath(points) {\n  var path = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n\n    if (point) {\n      var action = i === 0 ? 'M' : 'L';\n      path.push([action, point.x, point.y]);\n    }\n  }\n\n  var first = points[0];\n\n  if (first) {\n    path.push(['L', first.x, first.y]);\n    path.push(['z']);\n  }\n\n  return path;\n}\n/**\n * 获取小提琴图 平滑的边界 path\n * @param points\n * @returns\n */\n\nexport function getSmoothViolinPath(points) {\n  var half = points.length / 2;\n  var leftPoints = [];\n  var rightPoints = [];\n\n  for (var i = 0; i < points.length; i++) {\n    if (i < half) {\n      leftPoints.push(points[i]);\n    } else {\n      rightPoints.push(points[i]);\n    }\n  }\n\n  var leftPath = getSplinePath(leftPoints, false);\n  var rightPath = getSplinePath(rightPoints, false);\n\n  if (rightPoints.length) {\n    leftPath.push(['L', rightPoints[0].x, rightPoints[0].y]);\n  }\n\n  rightPath.shift();\n  var path = leftPath.concat(rightPath);\n\n  if (leftPoints.length) {\n    path.push(['L', leftPoints[0].x, leftPoints[0].y]);\n  }\n\n  path.push(['z']);\n  return path;\n}","map":{"version":3,"mappings":"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","names":["isArray","getSplinePath","isValueEmpty","value","undefined","isNaN","isYNil","point","y","getPathPoints","points","connectNulls","showSinglePoint","length","filtered","i","len","push","result","tmp","getViolinPath","path","action","x","first","getSmoothViolinPath","half","leftPoints","rightPoints","leftPath","rightPath","shift","concat"],"sourceRoot":"","sources":["../../../../src/geometry/shape/util/get-path-points.ts"],"sourcesContent":["import { isArray } from '@antv/util';\nimport { PathCommand } from '../../../dependents';\nimport { Point, RangePoint, ShapeVertices } from '../../../interface';\nimport { getSplinePath } from './path';\n\nfunction isValueEmpty(value) {\n  if (value) {\n    return false;\n  }\n  return value === null || value === undefined || isNaN(value);\n}\n\nfunction isYNil(point: Point[] | RangePoint) {\n  if (isArray(point)) {\n    // 特殊处理 area 的关键点数据，其关键点结构为 [{x: 0, y: 1}, {x: 0, y: 2}]\n    return isValueEmpty(point[1].y);\n  }\n  const value = point.y;\n  return isArray(value) ? isValueEmpty(value[0]) : isValueEmpty(value);\n}\n\n/**\n * @ignore\n * 分割数据，用于处理在一组点数据中，y 对应的数值存在 null/undefined/NaN 的情况\n * 应用于折线图、区域图以及路径图\n *\n * ```typescript\n * // return [[{x: 1, y: 2}, {x: 3, y: 3}]]\n * getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], true);\n * // return [[{x: 1, y: 2}], [{x: 3, y: 3}]]\n * getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], false);\n * // return [[[{ x: 1, y: 10 }, { x: 2, y: 2 }], [{ x: 9, y: 34 }, { x: 1, y: 1 }]]]\n * getPathPoints([\n *   [{ x: 1, y: 10 }, { x: 2, y: 2 }],\n *   [{ x: 4, y: 2 }, { x: 8, y: NaN }],\n *   [{ x: 9, y: 34 }, { x: 1, y: 1 }],\n * ], true);\n * ```\n *\n * @param points 要进行处理点集合\n * @param connectNulls 是否连接空值数据\n * @param showSinglePoint 是否展示孤立点\n * @returns 返回处理后的点集合\n */\nexport function getPathPoints(points: ShapeVertices, connectNulls: boolean = false, showSinglePoint: boolean = true) {\n  if (!points.length || (points.length === 1 && !showSinglePoint)) {\n    // 空或者只有一个点并配置不展示时\n    return [];\n  }\n\n  if (connectNulls) {\n    // 即 y 值为空的场景\n    const filtered = [];\n    for (let i = 0, len = points.length; i < len; i++) {\n      const point = points[i];\n      if (!isYNil(point)) {\n        filtered.push(point);\n      }\n    }\n    return [filtered];\n  }\n\n  const result = [];\n  let tmp = [];\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (isYNil(point)) {\n      if (tmp.length) {\n        if (!(tmp.length === 1 && !showSinglePoint)) {\n          // 如果前段数据只有一个字段并且不需要展示时则不加入\n          result.push(tmp);\n        }\n        tmp = [];\n      }\n    } else {\n      tmp.push(point);\n    }\n  }\n\n  if (tmp.length) {\n    result.push(tmp);\n  }\n  return result;\n}\n\n/**\n * 获取小提琴图的边界 path\n * @param points\n * @returns\n */\nexport function getViolinPath(points: ShapeVertices): PathCommand[] {\n  const path = [];\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i] as Point;\n    if (point) {\n      const action = i === 0 ? 'M' : 'L';\n      path.push([action, point.x, point.y]);\n    }\n  }\n  const first = points[0] as Point;\n  if (first) {\n    path.push(['L', first.x, first.y]);\n    path.push(['z']);\n  }\n  return path;\n}\n\n/**\n * 获取小提琴图 平滑的边界 path\n * @param points\n * @returns\n */\nexport function getSmoothViolinPath(points: ShapeVertices): PathCommand[] {\n  const half = points.length / 2;\n  const leftPoints = [];\n  const rightPoints = [];\n  for (let i = 0; i < points.length; i++) {\n    if (i < half) {\n      leftPoints.push(points[i]);\n    } else {\n      rightPoints.push(points[i]);\n    }\n  }\n  const leftPath = getSplinePath(leftPoints, false);\n  const rightPath = getSplinePath(rightPoints, false);\n  if (rightPoints.length) {\n    leftPath.push(['L', rightPoints[0].x, rightPoints[0].y]);\n  }\n  rightPath.shift();\n  const path = leftPath.concat(rightPath);\n  if (leftPoints.length) {\n    path.push(['L', leftPoints[0].x, leftPoints[0].y]);\n  }\n  path.push(['z']);\n  return path;\n}\n"]},"metadata":{},"sourceType":"module"}