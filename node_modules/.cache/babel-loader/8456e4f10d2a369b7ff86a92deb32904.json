{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/*\n * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)\n * graph data required (nodes, edges)\n */\nimport { assign, forIn, isFunction } from '@antv/util';\nvar DEFAULT_OPTIONS = {\n  y: 0,\n  nodeWidthRatio: 0.05,\n  weight: false,\n  nodePaddingRatio: 0.1,\n  id: function (node) {\n    return node.id;\n  },\n  source: function (edge) {\n    return edge.source;\n  },\n  target: function (edge) {\n    return edge.target;\n  },\n  sourceWeight: function (edge) {\n    return edge.value || 1;\n  },\n  targetWeight: function (edge) {\n    return edge.value || 1;\n  },\n  sortBy: null\n};\n/**\n * 处理节点的value、edges\n * @param nodeById\n * @param edges\n * @param options\n */\n\nfunction processGraph(nodeById, edges, options) {\n  forIn(nodeById, function (node, id) {\n    // in edges, out edges\n    node.inEdges = edges.filter(function (edge) {\n      return \"\" + options.target(edge) === \"\" + id;\n    });\n    node.outEdges = edges.filter(function (edge) {\n      return \"\" + options.source(edge) === \"\" + id;\n    }); // frequency\n\n    node.edges = node.outEdges.concat(node.inEdges);\n    node.frequency = node.edges.length; // weight\n\n    node.value = 0;\n    node.inEdges.forEach(function (edge) {\n      node.value += options.targetWeight(edge);\n    });\n    node.outEdges.forEach(function (edge) {\n      node.value += options.sourceWeight(edge);\n    });\n  });\n}\n/**\n * 节点排序\n * @param nodes\n * @param options\n */\n\n\nfunction sortNodes(nodes, options) {\n  var sortMethods = {\n    weight: function (a, b) {\n      return b.value - a.value;\n    },\n    frequency: function (a, b) {\n      return b.frequency - a.frequency;\n    },\n    id: function (a, b) {\n      return (\"\" + options.id(a)).localeCompare(\"\" + options.id(b));\n    }\n  };\n  var method = sortMethods[options.sortBy];\n\n  if (!method && isFunction(options.sortBy)) {\n    method = options.sortBy;\n  }\n\n  if (method) {\n    nodes.sort(method);\n  }\n}\n\nfunction layoutNodes(nodes, options) {\n  var len = nodes.length;\n\n  if (!len) {\n    throw new TypeError(\"Invalid nodes: it's empty!\");\n  }\n\n  if (options.weight) {\n    var nodePaddingRatio_1 = options.nodePaddingRatio;\n\n    if (nodePaddingRatio_1 < 0 || nodePaddingRatio_1 >= 1) {\n      throw new TypeError('Invalid nodePaddingRatio: it must be in range [0, 1)!');\n    }\n\n    var margin_1 = nodePaddingRatio_1 / (2 * len);\n    var nodeWidthRatio_1 = options.nodeWidthRatio;\n\n    if (nodeWidthRatio_1 <= 0 || nodeWidthRatio_1 >= 1) {\n      throw new TypeError('Invalid nodeWidthRatio: it must be in range (0, 1)!');\n    }\n\n    var totalValue_1 = 0;\n    nodes.forEach(function (node) {\n      totalValue_1 += node.value;\n    });\n    nodes.forEach(function (node) {\n      node.weight = node.value / totalValue_1;\n      node.width = node.weight * (1 - nodePaddingRatio_1);\n      node.height = nodeWidthRatio_1;\n    });\n    nodes.forEach(function (node, index) {\n      // x\n      var deltaX = 0;\n\n      for (var i = index - 1; i >= 0; i--) {\n        deltaX += nodes[i].width + 2 * margin_1;\n      }\n\n      var minX = node.minX = margin_1 + deltaX;\n      var maxX = node.maxX = node.minX + node.width;\n      var minY = node.minY = options.y - nodeWidthRatio_1 / 2;\n      var maxY = node.maxY = minY + nodeWidthRatio_1;\n      node.x = [minX, maxX, maxX, minX];\n      node.y = [minY, minY, maxY, maxY];\n      /* points\n       * 3---2\n       * |   |\n       * 0---1\n       */\n      // node.x = minX + 0.5 * node.width;\n      // node.y = options.y;\n    });\n  } else {\n    var deltaX_1 = 1 / len;\n    nodes.forEach(function (node, index) {\n      node.x = (index + 0.5) * deltaX_1;\n      node.y = options.y;\n    });\n  }\n\n  return nodes;\n}\n\nfunction locatingEdges(nodeById, edges, options) {\n  if (options.weight) {\n    var valueById_1 = {};\n    forIn(nodeById, function (node, id) {\n      valueById_1[id] = node.value;\n    });\n    edges.forEach(function (edge) {\n      var sId = options.source(edge);\n      var tId = options.target(edge);\n      var sNode = nodeById[sId];\n      var tNode = nodeById[tId];\n\n      if (sNode && tNode) {\n        var sValue = valueById_1[sId];\n        var currentSValue = options.sourceWeight(edge);\n        var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;\n        var sEnd = sStart + currentSValue / sNode.value * sNode.width;\n        valueById_1[sId] -= currentSValue;\n        var tValue = valueById_1[tId];\n        var currentTValue = options.targetWeight(edge);\n        var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;\n        var tEnd = tStart + currentTValue / tNode.value * tNode.width;\n        valueById_1[tId] -= currentTValue;\n        var y = options.y;\n        edge.x = [sStart, sEnd, tStart, tEnd];\n        edge.y = [y, y, y, y]; // 将edge的source与target的id换为 sourceNode与targetNode\n\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  } else {\n    edges.forEach(function (edge) {\n      var sNode = nodeById[options.source(edge)];\n      var tNode = nodeById[options.target(edge)];\n\n      if (sNode && tNode) {\n        edge.x = [sNode.x, tNode.x];\n        edge.y = [sNode.y, tNode.y]; // 将edge的source与target的id换为 sourceNode与targetNode\n\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  }\n\n  return edges;\n}\n\nexport function getDefaultOptions(options) {\n  return assign({}, DEFAULT_OPTIONS, options);\n}\nexport function chordLayout(chordLayoutOptions, chordLayoutInputData) {\n  var options = getDefaultOptions(chordLayoutOptions);\n  var nodeById = {};\n  var nodes = chordLayoutInputData.nodes;\n  var links = chordLayoutInputData.links;\n  nodes.forEach(function (node) {\n    var id = options.id(node);\n    nodeById[id] = node;\n  });\n  processGraph(nodeById, links, options);\n  sortNodes(nodes, options);\n  var outputNodes = layoutNodes(nodes, options);\n  var outputLinks = locatingEdges(nodeById, links, options);\n  return {\n    nodes: outputNodes,\n    links: outputLinks\n  };\n}","map":{"version":3,"mappings":"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","names":["assign","forIn","isFunction","DEFAULT_OPTIONS","y","nodeWidthRatio","weight","nodePaddingRatio","id","node","source","edge","target","sourceWeight","value","targetWeight","sortBy","processGraph","nodeById","edges","options","inEdges","filter","outEdges","concat","frequency","length","forEach","sortNodes","nodes","sortMethods","a","b","localeCompare","method","sort","layoutNodes","len","TypeError","nodePaddingRatio_1","margin_1","nodeWidthRatio_1","totalValue_1","width","height","index","deltaX","i","minX","maxX","minY","maxY","x","deltaX_1","locatingEdges","valueById_1","sId","tId","sNode","tNode","sValue","currentSValue","sStart","sEnd","tValue","currentTValue","tStart","tEnd","getDefaultOptions","chordLayout","chordLayoutOptions","chordLayoutInputData","links","outputNodes","outputLinks"],"sourceRoot":"","sources":["../../../src/utils/transform/chord.ts"],"sourcesContent":["/*\n * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)\n * graph data required (nodes, edges)\n */\nimport { assign, forIn, isFunction } from '@antv/util';\nimport { NodeLinkData } from '../../types/relation-data';\n\nconst DEFAULT_OPTIONS: ChordLayoutOptions = {\n  y: 0,\n  nodeWidthRatio: 0.05, // width of the node, (0, 1)\n  weight: false,\n  nodePaddingRatio: 0.1, // margin ratio, [0, 1)\n  id: (node) => node.id,\n  source: (edge) => edge.source,\n  target: (edge) => edge.target,\n  sourceWeight: (edge) => edge.value || 1,\n  targetWeight: (edge) => edge.value || 1,\n  sortBy: null, // optional, id | weight | frequency | {function}\n};\n\nexport type ChordLayoutOptions = {\n  weight?: boolean;\n  y?: number;\n  nodeWidthRatio?: number; // 节点的宽度比例，对应于极坐标系的厚度，(0, 1)\n  nodePaddingRatio?: number; // 节点之间的间距的比例，[0, 1)\n  id?(node: any): any;\n  source?(edge: any): any;\n  target?(edge: any): any;\n  sourceWeight?(edge: any): number;\n  targetWeight?(edge: any): number;\n  sortBy?: 'id' | 'weight' | 'frequency' | null | ((a: any, b: any) => number);\n};\n\ntype OutputNode = {\n  readonly id: number;\n  readonly name: string;\n  // readonly depth: number;\n  readonly value: number;\n\n  // 用于绘制 polygon\n  x: number[];\n  y: number[];\n};\n\ntype OutputLink = {\n  readonly source: OutputNode;\n  readonly target: OutputNode;\n  readonly value: number;\n\n  // 用于绘制 edge\n  x?: number[];\n  y?: number[];\n};\n\ntype ChordLayoutOutputData = {\n  readonly nodes: OutputNode[];\n  readonly links: OutputLink[];\n};\n\n/**\n * 处理节点的value、edges\n * @param nodeById\n * @param edges\n * @param options\n */\nfunction processGraph(nodeById, edges, options) {\n  forIn(nodeById, (node, id) => {\n    // in edges, out edges\n    node.inEdges = edges.filter((edge) => `${options.target(edge)}` === `${id}`);\n    node.outEdges = edges.filter((edge) => `${options.source(edge)}` === `${id}`);\n    // frequency\n    node.edges = node.outEdges.concat(node.inEdges);\n    node.frequency = node.edges.length;\n    // weight\n    node.value = 0;\n    node.inEdges.forEach((edge) => {\n      node.value += options.targetWeight(edge);\n    });\n    node.outEdges.forEach((edge) => {\n      node.value += options.sourceWeight(edge);\n    });\n  });\n}\n\n/**\n * 节点排序\n * @param nodes\n * @param options\n */\nfunction sortNodes(nodes, options) {\n  const sortMethods = {\n    weight: (a, b) => b.value - a.value,\n    frequency: (a, b) => b.frequency - a.frequency,\n    id: (a, b) => `${options.id(a)}`.localeCompare(`${options.id(b)}`),\n  };\n  let method = sortMethods[options.sortBy];\n  if (!method && isFunction(options.sortBy)) {\n    method = options.sortBy;\n  }\n  if (method) {\n    nodes.sort(method);\n  }\n}\n\nfunction layoutNodes(nodes, options): OutputNode[] {\n  const len = nodes.length;\n  if (!len) {\n    throw new TypeError(\"Invalid nodes: it's empty!\");\n  }\n  if (options.weight) {\n    const nodePaddingRatio = options.nodePaddingRatio;\n    if (nodePaddingRatio < 0 || nodePaddingRatio >= 1) {\n      throw new TypeError('Invalid nodePaddingRatio: it must be in range [0, 1)!');\n    }\n    const margin = nodePaddingRatio / (2 * len);\n    const nodeWidthRatio = options.nodeWidthRatio;\n    if (nodeWidthRatio <= 0 || nodeWidthRatio >= 1) {\n      throw new TypeError('Invalid nodeWidthRatio: it must be in range (0, 1)!');\n    }\n    let totalValue = 0;\n    nodes.forEach((node) => {\n      totalValue += node.value;\n    });\n    nodes.forEach((node) => {\n      node.weight = node.value / totalValue;\n      node.width = node.weight * (1 - nodePaddingRatio);\n      node.height = nodeWidthRatio;\n    });\n    nodes.forEach((node, index) => {\n      // x\n      let deltaX = 0;\n      for (let i = index - 1; i >= 0; i--) {\n        deltaX += nodes[i].width + 2 * margin;\n      }\n      const minX = (node.minX = margin + deltaX);\n      const maxX = (node.maxX = node.minX + node.width);\n      const minY = (node.minY = options.y - nodeWidthRatio / 2);\n      const maxY = (node.maxY = minY + nodeWidthRatio);\n      node.x = [minX, maxX, maxX, minX];\n      node.y = [minY, minY, maxY, maxY];\n      /* points\n       * 3---2\n       * |   |\n       * 0---1\n       */\n      // node.x = minX + 0.5 * node.width;\n      // node.y = options.y;\n    });\n  } else {\n    const deltaX = 1 / len;\n    nodes.forEach((node, index) => {\n      node.x = (index + 0.5) * deltaX;\n      node.y = options.y;\n    });\n  }\n  return nodes;\n}\n\nfunction locatingEdges(nodeById, edges, options): OutputLink[] {\n  if (options.weight) {\n    const valueById = {};\n    forIn(nodeById, (node, id) => {\n      valueById[id] = node.value;\n    });\n    edges.forEach((edge) => {\n      const sId = options.source(edge);\n      const tId = options.target(edge);\n      const sNode = nodeById[sId];\n      const tNode = nodeById[tId];\n      if (sNode && tNode) {\n        const sValue = valueById[sId];\n        const currentSValue = options.sourceWeight(edge);\n        const sStart = sNode.minX + ((sNode.value - sValue) / sNode.value) * sNode.width;\n        const sEnd = sStart + (currentSValue / sNode.value) * sNode.width;\n        valueById[sId] -= currentSValue;\n\n        const tValue = valueById[tId];\n        const currentTValue = options.targetWeight(edge);\n        const tStart = tNode.minX + ((tNode.value - tValue) / tNode.value) * tNode.width;\n        const tEnd = tStart + (currentTValue / tNode.value) * tNode.width;\n        valueById[tId] -= currentTValue;\n\n        const y = options.y;\n        edge.x = [sStart, sEnd, tStart, tEnd];\n        edge.y = [y, y, y, y];\n        // 将edge的source与target的id换为 sourceNode与targetNode\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  } else {\n    edges.forEach((edge) => {\n      const sNode = nodeById[options.source(edge)];\n      const tNode = nodeById[options.target(edge)];\n      if (sNode && tNode) {\n        edge.x = [sNode.x, tNode.x];\n        edge.y = [sNode.y, tNode.y];\n        // 将edge的source与target的id换为 sourceNode与targetNode\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  }\n  return edges;\n}\n\nexport function getDefaultOptions(options: ChordLayoutOptions): ChordLayoutOptions {\n  return assign({}, DEFAULT_OPTIONS, options);\n}\n\nexport function chordLayout(\n  chordLayoutOptions: ChordLayoutOptions,\n  chordLayoutInputData: NodeLinkData\n): ChordLayoutOutputData {\n  const options = getDefaultOptions(chordLayoutOptions);\n  const nodeById = {};\n  const nodes = chordLayoutInputData.nodes;\n  const links = chordLayoutInputData.links;\n  nodes.forEach((node) => {\n    const id = options.id(node);\n    nodeById[id] = node;\n  });\n  processGraph(nodeById, links, options);\n  sortNodes(nodes, options);\n  const outputNodes = layoutNodes(nodes, options);\n  const outputLinks = locatingEdges(nodeById, links, options);\n  return {\n    nodes: outputNodes,\n    links: outputLinks,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}