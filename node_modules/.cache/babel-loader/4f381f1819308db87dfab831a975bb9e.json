{"ast":null,"code":"import { each } from '@antv/util';\nvar MAX_TIMES = 100;\n/**\n * @ignore\n * Greedy 贪婪算法\n */\n\nvar Greedy =\n/** @class */\nfunction () {\n  function Greedy(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.bitmap = {};\n    var _a = cfg.xGap,\n        xGap = _a === void 0 ? 1 : _a,\n        _b = cfg.yGap,\n        yGap = _b === void 0 ? 8 : _b;\n    this.xGap = xGap;\n    this.yGap = yGap;\n  }\n\n  Greedy.prototype.hasGap = function (bbox) {\n    var hasGap = true;\n    var bitmap = this.bitmap;\n    var minX = Math.round(bbox.minX);\n    var maxX = Math.round(bbox.maxX);\n    var minY = Math.round(bbox.minY);\n    var maxY = Math.round(bbox.maxY);\n\n    for (var i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n        continue;\n      }\n\n      if (i === minX || i === maxX) {\n        for (var j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n\n    return hasGap;\n  };\n\n  Greedy.prototype.fillGap = function (bbox) {\n    var bitmap = this.bitmap;\n    var minX = Math.round(bbox.minX);\n    var maxX = Math.round(bbox.maxX);\n    var minY = Math.round(bbox.minY);\n    var maxY = Math.round(bbox.maxY); // filling grid\n\n    for (var i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n      }\n    }\n\n    for (var i = minX; i <= maxX; i += this.xGap) {\n      for (var j = minY; j <= maxY; j += this.yGap) {\n        bitmap[i][j] = true;\n      }\n\n      bitmap[i][maxY] = true;\n    } // filling y edges\n\n\n    if (this.yGap !== 1) {\n      for (var i = minY; i <= maxY; i += 1) {\n        bitmap[minX][i] = true;\n        bitmap[maxX][i] = true;\n      }\n    } // filling x edges\n\n\n    if (this.xGap !== 1) {\n      for (var i = minX; i <= maxX; i += 1) {\n        bitmap[i][minY] = true;\n        bitmap[i][maxY] = true;\n      }\n    }\n  };\n\n  Greedy.prototype.destroy = function () {\n    this.bitmap = {};\n  };\n\n  return Greedy;\n}();\n\nfunction spiralFill(label, greedy, maxTimes) {\n  if (maxTimes === void 0) {\n    maxTimes = MAX_TIMES;\n  }\n\n  var dt = -1;\n\n  var _a = label.attr(),\n      x = _a.x,\n      y = _a.y;\n\n  var bbox = label.getCanvasBBox();\n  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  var dxdy;\n  var t = -dt;\n  var dx = 0;\n  var dy = 0;\n\n  var f = function (param) {\n    var nt = param * 0.1;\n    return [nt * Math.cos(nt), nt * Math.sin(nt)];\n  };\n\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n\n  var canFill = false;\n  var times = 0;\n  var accessedCache = {};\n\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {\n    dxdy = f(t += dt);\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n\n    if (!dx && !dy || accessedCache[\"\".concat(dx, \"-\").concat(dy)]) {\n      continue;\n    }\n\n    label.attr({\n      x: x + dx,\n      y: y + dy\n    });\n\n    if (dx + dy < 0) {\n      label.attr('textAlign', 'right');\n    }\n\n    times++;\n\n    if (greedy.hasGap(label.getCanvasBBox())) {\n      greedy.fillGap(label.getCanvasBBox());\n      canFill = true;\n      accessedCache[\"\".concat(dx, \"-\").concat(dy)] = true;\n      break;\n    }\n  }\n\n  return canFill;\n}\n/*\n *  根据如下规则尝试放置label\n *                5\n *        ------------------\n *        |    1   |   0   |\n *    8   —————————4————————   7\n *        |    2   |   3   |\n *        ——————————————————\n *                 6\n */\n\n\nfunction adjustLabelPosition(label, x, y, index) {\n  var _a = label.getCanvasBBox(),\n      width = _a.width,\n      height = _a.height;\n\n  var attrs = {\n    x: x,\n    y: y,\n    textAlign: 'center'\n  };\n\n  switch (index) {\n    case 0:\n      attrs.y -= height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n\n    case 1:\n      attrs.y -= height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n\n    case 2:\n      attrs.y += height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n\n    case 3:\n      attrs.y += height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n\n    case 5:\n      attrs.y -= height * 2 + 2;\n      break;\n\n    case 6:\n      attrs.y += height * 2 + 2;\n      break;\n\n    case 7:\n      attrs.x += width + 1;\n      attrs.textAlign = 'left';\n      break;\n\n    case 8:\n      attrs.x -= width + 1;\n      attrs.textAlign = 'right';\n      break;\n\n    default:\n      break;\n  }\n\n  label.attr(attrs);\n  return label.getCanvasBBox();\n}\n/**\n * @ignore\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\n\n\nexport function fixedOverlap(items, labels, shapes, region) {\n  var greedy = new Greedy();\n  each(labels, function (label) {\n    var labelShape = label.find(function (shape) {\n      return shape.get('type') === 'text';\n    });\n\n    if (!spiralFill(labelShape, greedy)) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}\n/**\n * @ignore\n * label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label\n * @param labels 参与布局调整的 label 数组集合\n */\n\nexport function overlap(items, labels, shapes, region) {\n  var greedy = new Greedy();\n  each(labels, function (label) {\n    var labelShape = label.find(function (shape) {\n      return shape.get('type') === 'text';\n    });\n\n    var _a = labelShape.attr(),\n        x = _a.x,\n        y = _a.y;\n\n    var canFill = false;\n\n    for (var i = 0; i <= 8; i++) {\n      var bbox = adjustLabelPosition(labelShape, x, y, i);\n\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n\n    if (!canFill) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}","map":{"version":3,"mappings":"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","names":["each","MAX_TIMES","cfg","_a","_b","yGap","xGap","Greedy","bbox","hasGap","bitmap","minX","Math","round","maxX","minY","maxY","i","j","spiralFill","label","greedy","maxTimes","dt","attr","x","y","getCanvasBBox","maxDelta","sqrt","width","height","dxdy","t","dx","dy","f","param","nt","cos","sin","fillGap","canFill","times","accessedCache","min","abs","concat","adjustLabelPosition","index","attrs","textAlign","fixedOverlap","items","labels","shapes","region","labelShape","find","shape","get","remove","destroy","overlap"],"sourceRoot":"","sources":["../../../../src/geometry/label/layout/overlap.ts"],"sourcesContent":["import { each } from '@antv/util';\nimport { BBox, IGroup, IShape } from '../../../dependents';\nimport { LabelItem } from '../interface';\n\nconst MAX_TIMES = 100;\n\n/** @ignore */\ninterface Bitmap {\n  [key: number]: {\n    [key: number]: boolean;\n  };\n}\n\n/** @ignore */\ninterface GreedyCfg {\n  readonly xGap?: number;\n  readonly yGap?: number;\n}\n\n/**\n * @ignore\n * Greedy 贪婪算法\n */\nclass Greedy {\n  public readonly xGap: number;\n  /** optimizing for text overlapping detection: use a min text height as gap */\n  public readonly yGap: number;\n\n  private bitmap: Bitmap = {};\n\n  constructor(cfg: GreedyCfg = {}) {\n    const { xGap = 1, yGap = 8 } = cfg;\n    this.xGap = xGap;\n    this.yGap = yGap;\n  }\n\n  public hasGap(bbox: BBox): boolean {\n    let hasGap = true;\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n        continue;\n      }\n      if (i === minX || i === maxX) {\n        for (let j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n    return hasGap;\n  }\n\n  public fillGap(bbox: BBox): void {\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    // filling grid\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n      }\n    }\n    for (let i = minX; i <= maxX; i += this.xGap) {\n      for (let j = minY; j <= maxY; j += this.yGap) {\n        bitmap[i][j] = true;\n      }\n      bitmap[i][maxY] = true;\n    }\n\n    // filling y edges\n    if (this.yGap !== 1) {\n      for (let i = minY; i <= maxY; i += 1) {\n        bitmap[minX][i] = true;\n        bitmap[maxX][i] = true;\n      }\n    }\n\n    // filling x edges\n    if (this.xGap !== 1) {\n      for (let i = minX; i <= maxX; i += 1) {\n        bitmap[i][minY] = true;\n        bitmap[i][maxY] = true;\n      }\n    }\n  }\n\n  public destroy(): void {\n    this.bitmap = {};\n  }\n}\n\nfunction spiralFill(label: IShape, greedy: Greedy, maxTimes: number = MAX_TIMES) {\n  const dt = -1;\n  const { x, y } = label.attr();\n  const bbox = label.getCanvasBBox();\n  const maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  let dxdy;\n  let t = -dt;\n  let dx = 0;\n  let dy = 0;\n  const f = (param: number) => {\n    const nt = param * 0.1;\n    return [nt * Math.cos(nt), nt * Math.sin(nt)];\n  };\n\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n  let canFill = false;\n  let times = 0;\n  const accessedCache = {};\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {\n    dxdy = f((t += dt));\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n    if ((!dx && !dy) || accessedCache[`${dx}-${dy}`]) {\n      continue;\n    }\n    label.attr({ x: x + dx, y: y + dy });\n    if (dx + dy < 0) {\n      label.attr('textAlign', 'right');\n    }\n    times++;\n    if (greedy.hasGap(label.getCanvasBBox())) {\n      greedy.fillGap(label.getCanvasBBox());\n      canFill = true;\n      accessedCache[`${dx}-${dy}`] = true;\n      break;\n    }\n  }\n  return canFill;\n}\n\n/*\n *  根据如下规则尝试放置label\n *                5\n *        ------------------\n *        |    1   |   0   |\n *    8   —————————4————————   7\n *        |    2   |   3   |\n *        ——————————————————\n *                 6\n */\nfunction adjustLabelPosition(label: IShape, x: number, y: number, index: number) {\n  const { width, height } = label.getCanvasBBox();\n  const attrs = {\n    x,\n    y,\n    textAlign: 'center',\n  };\n  switch (index) {\n    case 0:\n      attrs.y -= height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 1:\n      attrs.y -= height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 2:\n      attrs.y += height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 3:\n      attrs.y += height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 5:\n      attrs.y -= height * 2 + 2;\n      break;\n    case 6:\n      attrs.y += height * 2 + 2;\n      break;\n    case 7:\n      attrs.x += width + 1;\n      attrs.textAlign = 'left';\n      break;\n    case 8:\n      attrs.x -= width + 1;\n      attrs.textAlign = 'right';\n      break;\n    default:\n      break;\n  }\n  label.attr(attrs);\n  return label.getCanvasBBox();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function fixedOverlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    if (!spiralFill(labelShape, greedy)) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function overlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    const { x, y } = labelShape.attr();\n    let canFill = false;\n    for (let i = 0; i <= 8; i++) {\n      const bbox = adjustLabelPosition(labelShape, x, y, i);\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n    if (!canFill) {\n      label.remove(true);\n    }\n  });\n\n  greedy.destroy();\n}\n"]},"metadata":{},"sourceType":"module"}